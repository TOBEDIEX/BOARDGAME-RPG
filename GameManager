-- GameManager.lua
-- โมดูลหลักที่ควบคุมลอจิกของเกมทั้งหมด
-- Version: 2.1.0 (Optimized)

local GameManager = {}
GameManager.__index = GameManager

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Constants
local MIN_PLAYERS = 2
local MAX_PLAYERS = 4
local CLASS_SELECTION_TIME = 30 -- วินาที

-- ฟังก์ชันรับ Remote Events
local function getRemotes()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")

	return {
		game = {
			startGame = gameRemotes:WaitForChild("StartGame"),
			endGame = gameRemotes:WaitForChild("EndGame"),
			updateTurn = gameRemotes:WaitForChild("UpdateTurn")
		},
		ui = {
			updateLoading = uiRemotes:WaitForChild("UpdateLoading"),
			updatePlayersReady = uiRemotes:WaitForChild("UpdatePlayersReady"),
			showClassSelection = uiRemotes:WaitForChild("ShowClassSelection"),
			updateClassSelection = uiRemotes:WaitForChild("UpdateClassSelection"),
			updateClassSelectionTimer = uiRemotes:WaitForChild("UpdateClassSelectionTimer"),
			notifyRandomClass = uiRemotes:WaitForChild("NotifyRandomClass"),
			showMainGameUI = uiRemotes:WaitForChild("ShowMainGameUI")
		}
	}
end

function GameManager.new()
	local self = setmetatable({}, GameManager)

	-- Game state
	self.gameState = {
		isLoading = true,
		isClassSelection = false,
		isGameStarted = false,
		isGameEnded = false,
		currentTurn = 0,
		gameTime = 0,
		selectionTimeLeft = CLASS_SELECTION_TIME
	}

	-- Player tracking
	self.playerManager = nil
	self.classSystem = nil
	self.boardSystem = nil
	self.turnSystem = nil

	-- Players ready status
	self.playersReady = {}
	self.playersSelectedClass = {}

	-- ตัวแปรจับเวลา
	self.timers = {
		playerCheck = nil,
		classSelection = nil,
		playerCheckTimestamp = 0,
		classSelectionTimestamp = 0
	}

	-- Get remote events
	self.remotes = getRemotes()

	return self
end

function GameManager:Initialize()
	-- ตรวจสอบ PlayerManager และ ClassSystem
	if not self.playerManager or not self.classSystem then
		error("PlayerManager and ClassSystem must be set before initializing GameManager")
	end

	-- เชื่อมต่อเหตุการณ์ผู้เล่น
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)

	Players.PlayerRemoving:Connect(function(player)
		self:OnPlayerRemoving(player)
	end)

	-- เริ่มต้นผู้เล่นที่มีอยู่
	for _, player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end

	-- เริ่มตรวจสอบจำนวนผู้เล่น
	self:StartPlayerCheck()
end

function GameManager:StartPlayerCheck()
	-- ล้างตัวจับเวลาเดิม
	if self.timers.playerCheck then
		self.timers.playerCheck:Disconnect()
		self.timers.playerCheck = nil
	end

	-- เริ่มเก็บเวลาที่เริ่มตรวจสอบ
	self.timers.playerCheckTimestamp = tick()

	-- ตรวจสอบจำนวนผู้เล่นทุกๆ 1 วินาที
	self.timers.playerCheck = RunService.Heartbeat:Connect(function()
		-- คำนวณเวลาที่ผ่านไป
		local currentTime = tick()
		local elapsedTime = currentTime - self.timers.playerCheckTimestamp
		if elapsedTime < 1 then return end

		-- อัปเดตเวลา
		self.timers.playerCheckTimestamp = currentTime

		-- ไม่ตรวจสอบถ้าเกมจบแล้ว
		if self.gameState.isGameEnded then return end

		local playerCount = self.playerManager:GetPlayerCount()
		local readyCount = self:CountReadyPlayers()

		-- ส่งข้อมูลผู้เล่นที่พร้อม
		self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)

		-- ตรวจสอบเงื่อนไขการเริ่มเกม
		if not self.gameState.isGameStarted then
			if playerCount >= MIN_PLAYERS then
				if self.gameState.isLoading then
					if self:AreAllPlayersReady() and playerCount > 0 then
						self:FinishLoading()
					end
				end
			end
		else
			-- ตรวจสอบผู้เล่นที่เหลือ
			if playerCount < MIN_PLAYERS then
				self:EndGame("ผู้เล่นไม่เพียงพอสำหรับเล่นต่อ (ต้องมีอย่างน้อย " .. MIN_PLAYERS .. " คน)")
			end
		end
	end)
end

function GameManager:CountReadyPlayers()
	local readyCount = 0
	for _, isReady in pairs(self.playersReady) do
		if isReady then readyCount = readyCount + 1 end
	end
	return readyCount
end

function GameManager:AreAllPlayersReady()
	for _, isReady in pairs(self.playersReady) do
		if not isReady then return false end
	end
	return true
end

function GameManager:HaveAllPlayersSelectedClass()
	for _, player in pairs(Players:GetPlayers()) do
		if not self.playersSelectedClass[player.UserId] then
			return false
		end
	end
	return true
end

function GameManager:OnPlayerAdded(player)
	-- ลงทะเบียนผู้เล่น
	self.playerManager:RegisterPlayer(player)

	-- ตั้งค่าสถานะความพร้อม
	self.playersReady[player.UserId] = false

	-- แสดงหน้าโหลด
	self.remotes.ui.updateLoading:FireClient(player, 0)

	-- แจ้งจำนวนผู้เล่นใหม่
	local playerCount = self.playerManager:GetPlayerCount()
	local readyCount = self:CountReadyPlayers()
	self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)
end

function GameManager:OnPlayerReady(player)
	-- ตั้งค่าผู้เล่นว่าพร้อมแล้ว
	self.playersReady[player.UserId] = true

	-- นับจำนวนผู้เล่นที่พร้อม
	local readyCount = self:CountReadyPlayers()
	local playerCount = self.playerManager:GetPlayerCount()

	-- อัปเดตหน้าโหลด
	local progress = readyCount / playerCount
	self.remotes.ui.updateLoading:FireAllClients(progress)
	self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)

	-- ตรวจสอบเงื่อนไขการเปลี่ยนหน้า
	if self:AreAllPlayersReady() and playerCount >= MIN_PLAYERS and self.gameState.isLoading then
		self:FinishLoading()
	end
end

function GameManager:FinishLoading()
	-- เปลี่ยนจากโหลดเป็นเลือกคลาส
	self.gameState.isLoading = false
	self.gameState.isClassSelection = true

	-- แสดงหน้าเลือกคลาส
	self.remotes.ui.showClassSelection:FireAllClients()

	-- เริ่มนับเวลาเลือกคลาส
	self:StartClassSelectionTimeout()
end

function GameManager:StartClassSelectionTimeout()
	-- รีเซ็ตเวลา
	self.gameState.selectionTimeLeft = CLASS_SELECTION_TIME

	-- ล้างตัวจับเวลาเดิม
	if self.timers.classSelection then
		self.timers.classSelection:Disconnect()
		self.timers.classSelection = nil
	end

	-- เริ่มเก็บเวลา
	self.timers.classSelectionTimestamp = tick()

	-- เริ่มจับเวลา
	self.timers.classSelection = RunService.Heartbeat:Connect(function()
		-- คำนวณเวลาที่ผ่านไป
		local currentTime = tick()
		local elapsedTime = currentTime - self.timers.classSelectionTimestamp
		if elapsedTime < 1 then return end

		-- อัปเดตเวลา
		self.timers.classSelectionTimestamp = currentTime

		-- ไม่จับเวลาถ้าไม่ได้อยู่ในช่วงเลือกคลาส
		if not self.gameState.isClassSelection then return end

		-- ลดเวลา
		self.gameState.selectionTimeLeft = self.gameState.selectionTimeLeft - 1
		local timeLeft = self.gameState.selectionTimeLeft
		if timeLeft < 0 then timeLeft = 0 end

		-- อัปเดตเวลาให้ทุกคน
		self.remotes.ui.updateClassSelectionTimer:FireAllClients(timeLeft)

		-- ตรวจสอบการเลือกคลาส
		if self:HaveAllPlayersSelectedClass() then
			self.timers.classSelection:Disconnect()
			self.timers.classSelection = nil
			wait(1.5)
			self:StartGame()
			return
		end

		-- หมดเวลา
		if timeLeft <= 0 then
			self.timers.classSelection:Disconnect()
			self.timers.classSelection = nil

			-- สุ่มคลาสให้ผู้ที่ยังไม่เลือก
			for _, player in pairs(Players:GetPlayers()) do
				if not self.playersSelectedClass[player.UserId] then
					local randomClass = self.classSystem:GetRandomClass()
					self:OnPlayerSelectedClass(player, randomClass)
					self.remotes.ui.notifyRandomClass:FireClient(player, randomClass)
				end
			end

			wait(3)
			self:StartGame()
		end
	end)
end

function GameManager:OnPlayerSelectedClass(player, selectedClass)
	-- บันทึกการเลือกคลาส
	self.playersSelectedClass[player.UserId] = selectedClass

	-- กำหนดคลาส
	self.classSystem:AssignClassToPlayer(player, selectedClass)

	-- อัปเดต UI
	self.remotes.ui.updateClassSelection:FireAllClients(player.UserId, selectedClass)

	-- ตรวจสอบการเลือกคลาสครบ
	if self:HaveAllPlayersSelectedClass() and self.gameState.isClassSelection then
		if self.timers.classSelection then
			self.timers.classSelection:Disconnect()
			self.timers.classSelection = nil
		end

		wait(2)
		self:StartGame()
	end
end

function GameManager:StartGame()
	local playerCount = self.playerManager:GetPlayerCount()

	-- ตรวจสอบจำนวนผู้เล่น
	if playerCount < MIN_PLAYERS then return end

	-- เปลี่ยนสถานะเกม
	self.gameState.isClassSelection = false
	self.gameState.isGameStarted = true

	-- แสดง UI เกมหลัก
	self.remotes.ui.showMainGameUI:FireAllClients()
	self.remotes.game.startGame:FireAllClients()

	-- ตั้งค่าตำแหน่งเริ่มต้น
	self:InitializePlayerPositions()

	-- เริ่มระบบเทิร์น
	if self.turnSystem then
		self.turnSystem:CreateTurnOrderFromActivePlayers(self.playerManager)
		self.turnSystem:StartTurnSystem()
		self.gameState.currentTurn = 1
	end

	-- เริ่มจับเวลาเกม
	self:StartGameTimer()
end

function GameManager:InitializePlayerPositions()
	if not self.boardSystem then return false end

	-- ตั้งตำแหน่งเริ่มต้น
	for _, player in pairs(Players:GetPlayers()) do
		self.boardSystem:SetPlayerPosition(player.UserId, 1, 1)

		-- แจ้งตำแหน่งให้ทุกคน
		local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
		boardRemotes:WaitForChild("UpdatePlayerPosition"):FireAllClients(player.UserId, 1)
	end

	return true
end

function GameManager:StartGameTimer()
	local lastUpdateTime = tick()

	spawn(function()
		while self.gameState.isGameStarted and not self.gameState.isGameEnded do
			local currentTime = tick()
			local elapsed = currentTime - lastUpdateTime

			if elapsed >= 1 then
				lastUpdateTime = currentTime
				self.gameState.gameTime = self.gameState.gameTime + 1

				if self.gameState.gameTime % 60 == 0 then
					local minutes = math.floor(self.gameState.gameTime / 60)
				end
			end

			wait(0.2)
		end
	end)
end

function GameManager:CheckWinCondition()
	-- ตรวจสอบจำนวนผู้เล่น
	local activePlayers = self.playerManager:GetPlayerCount()
	if activePlayers <= 1 then
		-- หาผู้เล่นคนสุดท้าย
		local lastPlayer = nil
		for _, player in pairs(Players:GetPlayers()) do
			lastPlayer = player
			break
		end

		if lastPlayer then
			self:EndGame(lastPlayer.Name .. " ชนะ! (เหลือผู้เล่นเพียงคนเดียว)")
			return true
		end
	end

	-- ตรวจสอบจำนวนเทิร์น
	if self.gameState.currentTurn >= 30 then
		local richestPlayer = nil
		local highestMoney = 0

		for _, player in pairs(Players:GetPlayers()) do
			local playerData = self.playerManager:GetPlayerData(player)
			if playerData and playerData.stats and playerData.stats.money > highestMoney then
				richestPlayer = player
				highestMoney = playerData.stats.money
			end
		end

		if richestPlayer then
			self:EndGame(richestPlayer.Name .. " ชนะ ด้วยเงิน " .. highestMoney .. "!")
			return true
		end
	end

	return false
end

function GameManager:OnPlayerRemoving(player)
	-- ลบข้อมูลผู้เล่น
	self.playerManager:UnregisterPlayer(player)
	self.playersReady[player.UserId] = nil
	self.playersSelectedClass[player.UserId] = nil

	-- อัปเดตจำนวนผู้เล่น
	local playerCount = self.playerManager:GetPlayerCount()
	local readyCount = self:CountReadyPlayers()
	self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)

	-- ตรวจสอบจำนวนผู้เล่นที่เหลือ
	if self.gameState.isGameStarted and playerCount < MIN_PLAYERS then
		self:EndGame("ผู้เล่นไม่เพียงพอ (เหลือเพียง " .. playerCount .. " คน)")
	end

	-- ตรวจสอบเงื่อนไขชนะ
	self:CheckWinCondition()
end

function GameManager:EndGame(reason)
	-- ตั้งค่าสถานะเกม
	self.gameState.isGameEnded = true

	-- ยกเลิกการจับเวลา
	if self.timers.playerCheck then
		self.timers.playerCheck:Disconnect()
		self.timers.playerCheck = nil
	end

	if self.timers.classSelection then
		self.timers.classSelection:Disconnect()
		self.timers.classSelection = nil
	end

	-- รีเซ็ตระบบเทิร์น
	if self.turnSystem then
		self.turnSystem:Reset()
	end

	-- แจ้งทุกคนว่าเกมจบ
	self.remotes.game.endGame:FireAllClients(reason)

	-- แสดงสถิติ
	self:ShowGameStats(reason)
end

function GameManager:ShowGameStats(reason)
	-- สร้างข้อมูลสถิติ
	local gameStats = {
		reason = reason,
		totalTurns = self.gameState.currentTurn,
		gameDuration = self.gameState.gameTime,
		playerStats = {}
	}

	-- รวบรวมสถิติผู้เล่น
	for _, player in pairs(Players:GetPlayers()) do
		local playerData = self.playerManager:GetPlayerData(player)
		if playerData then
			table.insert(gameStats.playerStats, {
				playerName = player.Name,
				playerId = player.UserId,
				level = playerData.stats and playerData.stats.level or 1,
				money = playerData.stats and playerData.stats.money or 0,
				class = playerData.class or "Unknown"
			})
		end
	end

	-- เรียงลำดับตามเงิน
	table.sort(gameStats.playerStats, function(a, b)
		return (a.money or 0) > (b.money or 0)
	end)

	-- ส่งสถิติ
	local statsEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("GameRemotes"):FindFirstChild("GameStats")
	if not statsEvent then
		statsEvent = Instance.new("RemoteEvent")
		statsEvent.Name = "GameStats"
		statsEvent.Parent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("GameRemotes")
	end

	statsEvent:FireAllClients(gameStats)
end

function GameManager:ResetGame()
	-- รีเซ็ต Game State
	self.gameState = {
		isLoading = true,
		isClassSelection = false,
		isGameStarted = false,
		isGameEnded = false,
		currentTurn = 0,
		gameTime = 0,
		selectionTimeLeft = CLASS_SELECTION_TIME
	}

	-- ล้างข้อมูล
	self.playersReady = {}
	self.playersSelectedClass = {}

	-- ยกเลิกตัวจับเวลา
	if self.timers.playerCheck then
		self.timers.playerCheck:Disconnect()
		self.timers.playerCheck = nil
	end

	if self.timers.classSelection then
		self.timers.classSelection:Disconnect()
		self.timers.classSelection = nil
	end

	-- รีเซ็ตผู้เล่น
	for _, player in pairs(Players:GetPlayers()) do
		self.playerManager:RegisterPlayer(player)
		self.playersReady[player.UserId] = false
		self.remotes.ui.updateLoading:FireClient(player, 0)
	end

	-- เริ่มตรวจสอบใหม่
	self:StartPlayerCheck()
end

return GameManager
