-- GameManager.lua
-- Main module that controls all game logic
-- Version: 3.0.0 (Optimized)

local GameManager = {}
GameManager.__index = GameManager

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Constants
local MIN_PLAYERS = 2
local MAX_PLAYERS = 4
local CLASS_SELECTION_TIME = 60

function GameManager.new()
	local self = setmetatable({}, GameManager)

	-- Game state
	self.gameState = {
		isLoading = true,
		isClassSelection = false,
		isGameStarted = false,
		isGameEnded = false,
		currentTurn = 0,
		gameTime = 0,
		selectionTimeLeft = CLASS_SELECTION_TIME
	}

	-- System references
	self.playerManager = nil
	self.classSystem = nil
	self.boardSystem = nil
	self.turnSystem = nil

	-- Player tracking
	self.playersReady = {}
	self.playersSelectedClass = {}

	-- Timers
	self.timers = {
		playerCheck = nil,
		classSelection = nil,
		playerCheckTimestamp = 0,
		classSelectionTimestamp = 0
	}

	-- Get remote events
	self.remotes = self:GetRemoteEvents()

	return self
end

function GameManager:GetRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")

	return {
		game = {
			startGame = gameRemotes:WaitForChild("StartGame"),
			endGame = gameRemotes:WaitForChild("EndGame"),
			updateTurn = gameRemotes:WaitForChild("UpdateTurn")
		},
		ui = {
			updateLoading = uiRemotes:WaitForChild("UpdateLoading"),
			updatePlayersReady = uiRemotes:WaitForChild("UpdatePlayersReady"),
			showClassSelection = uiRemotes:WaitForChild("ShowClassSelection"),
			updateClassSelection = uiRemotes:WaitForChild("UpdateClassSelection"),
			updateClassSelectionTimer = uiRemotes:WaitForChild("UpdateClassSelectionTimer"),
			notifyRandomClass = uiRemotes:WaitForChild("NotifyRandomClass"),
			showMainGameUI = uiRemotes:WaitForChild("ShowMainGameUI")
		}
	}
end

function GameManager:Initialize()
	-- Check PlayerManager and ClassSystem
	if not self.playerManager or not self.classSystem then
		warn("PlayerManager and ClassSystem must be set before initializing GameManager")
		return
	end

	-- Connect player events
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)

	Players.PlayerRemoving:Connect(function(player)
		self:OnPlayerRemoving(player)
	end)

	-- Initialize existing players
	for _, player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end

	-- Start player check
	self:StartPlayerCheck()
end

function GameManager:StartPlayerCheck()
	-- Clear existing timer
	if self.timers.playerCheck then
		self.timers.playerCheck:Disconnect()
		self.timers.playerCheck = nil
	end

	-- Start timestamp tracking
	self.timers.playerCheckTimestamp = tick()

	-- Check player count every second
	self.timers.playerCheck = RunService.Heartbeat:Connect(function()
		-- Calculate elapsed time
		local currentTime = tick()
		local elapsedTime = currentTime - self.timers.playerCheckTimestamp
		if elapsedTime < 1 then return end

		-- Update timestamp
		self.timers.playerCheckTimestamp = currentTime

		-- Skip if game ended
		if self.gameState.isGameEnded then return end

		local playerCount = self.playerManager:GetPlayerCount()
		local readyCount = self:CountReadyPlayers()

		-- Update ready players UI
		self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)

		-- Check game start conditions
		if not self.gameState.isGameStarted then
			if playerCount >= MIN_PLAYERS then
				if self.gameState.isLoading then
					if self:AreAllPlayersReady() and playerCount > 0 then
						self:FinishLoading()
					end
				end
			end
		else
			-- Check remaining players
			if playerCount < MIN_PLAYERS then
				self:EndGame("Not enough players to continue (minimum " .. MIN_PLAYERS .. " required)")
			end
		end
	end)
end

function GameManager:CountReadyPlayers()
	local readyCount = 0
	for _, isReady in pairs(self.playersReady) do
		if isReady then readyCount = readyCount + 1 end
	end
	return readyCount
end

function GameManager:AreAllPlayersReady()
	for _, isReady in pairs(self.playersReady) do
		if not isReady then return false end
	end
	return true
end

function GameManager:HaveAllPlayersSelectedClass()
	for _, player in pairs(Players:GetPlayers()) do
		if not self.playersSelectedClass[player.UserId] then
			return false
		end
	end
	return true
end

function GameManager:OnPlayerAdded(player)
	-- Register player
	self.playerManager:RegisterPlayer(player)

	-- Set ready status
	self.playersReady[player.UserId] = false

	-- Show loading screen
	self.remotes.ui.updateLoading:FireClient(player, 0)

	-- Update player counts
	local playerCount = self.playerManager:GetPlayerCount()
	local readyCount = self:CountReadyPlayers()
	self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)
end

function GameManager:OnPlayerReady(player)
	-- Set player as ready
	self.playersReady[player.UserId] = true

	-- Count ready players
	local readyCount = self:CountReadyPlayers()
	local playerCount = self.playerManager:GetPlayerCount()

	-- Update loading UI
	local progress = readyCount / playerCount
	self.remotes.ui.updateLoading:FireAllClients(progress)
	self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)

	-- Check for transition
	if self:AreAllPlayersReady() and playerCount >= MIN_PLAYERS and self.gameState.isLoading then
		self:FinishLoading()
	end
end

function GameManager:FinishLoading()
	-- Change from loading to class selection
	self.gameState.isLoading = false
	self.gameState.isClassSelection = true

	-- Show class selection UI
	self.remotes.ui.showClassSelection:FireAllClients()

	-- Start class selection timeout
	self:StartClassSelectionTimeout()
end

function GameManager:StartClassSelectionTimeout()
	-- Reset timer
	self.gameState.selectionTimeLeft = CLASS_SELECTION_TIME

	-- Clear existing timer
	if self.timers.classSelection then
		self.timers.classSelection:Disconnect()
		self.timers.classSelection = nil
	end

	-- Start timestamp tracking
	self.timers.classSelectionTimestamp = tick()

	-- Send initial timer to clients
	self.remotes.ui.updateClassSelectionTimer:FireAllClients(self.gameState.selectionTimeLeft)

	-- Start timer
	self.timers.classSelection = RunService.Heartbeat:Connect(function()
		-- Calculate elapsed time
		local currentTime = tick()
		local elapsedTime = currentTime - self.timers.classSelectionTimestamp
		if elapsedTime < 1 then return end

		-- Update timestamp
		self.timers.classSelectionTimestamp = currentTime

		-- Skip if not in class selection
		if not self.gameState.isClassSelection then return end

		-- Decrease timer
		self.gameState.selectionTimeLeft = self.gameState.selectionTimeLeft - 1
		local timeLeft = self.gameState.selectionTimeLeft
		if timeLeft < 0 then timeLeft = 0 end

		-- Update timer for all clients
		self.remotes.ui.updateClassSelectionTimer:FireAllClients(timeLeft)

		-- Check if all players selected
		if self:HaveAllPlayersSelectedClass() then
			self.timers.classSelection:Disconnect()
			self.timers.classSelection = nil
			wait(1.5)
			self:StartGame()
			return
		end

		-- Time's up
		if timeLeft <= 0 then
			self.timers.classSelection:Disconnect()
			self.timers.classSelection = nil

			-- Randomly assign class to remaining players
			for _, player in pairs(Players:GetPlayers()) do
				if not self.playersSelectedClass[player.UserId] then
					local randomClass = self.classSystem:GetRandomClass()
					self:OnPlayerSelectedClass(player, randomClass)
					self.remotes.ui.notifyRandomClass:FireClient(player, randomClass)
				end
			end

			wait(3)
			self:StartGame()
		end
	end)
end

function GameManager:OnPlayerSelectedClass(player, selectedClass)
	-- Store class selection
	self.playersSelectedClass[player.UserId] = selectedClass

	-- Assign class
	self.classSystem:AssignClassToPlayer(player, selectedClass)

	-- Update UI
	self.remotes.ui.updateClassSelection:FireAllClients(player.UserId, selectedClass)

	-- Check if all selected
	if self:HaveAllPlayersSelectedClass() and self.gameState.isClassSelection then
		if self.timers.classSelection then
			self.timers.classSelection:Disconnect()
			self.timers.classSelection = nil
		end

		wait(2)
		self:StartGame()
	end
end

function GameManager:StartGame()
	local playerCount = self.playerManager:GetPlayerCount()

	-- Check player count
	if playerCount < MIN_PLAYERS then return end

	-- Update game state
	self.gameState.isClassSelection = false
	self.gameState.isGameStarted = true

	-- Show main game UI
	self.remotes.ui.showMainGameUI:FireAllClients()
	self.remotes.game.startGame:FireAllClients()

	-- Initialize player positions
	self:InitializePlayerPositions()

	-- Start turn system
	if self.turnSystem then
		self.turnSystem:CreateTurnOrderFromActivePlayers(self.playerManager)
		self.turnSystem:StartTurnSystem()
		self.gameState.currentTurn = 1
	end

	-- Start game timer
	self:StartGameTimer()
end

function GameManager:InitializePlayerPositions()
	if not self.boardSystem then return false end

	-- Set initial positions
	for _, player in pairs(Players:GetPlayers()) do
		self.boardSystem:SetPlayerPosition(player.UserId, 1, 1)

		-- Notify all clients
		local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
		boardRemotes:WaitForChild("UpdatePlayerPosition"):FireAllClients(player.UserId, 1)
	end

	return true
end

function GameManager:StartGameTimer()
	local lastUpdateTime = tick()

	spawn(function()
		while self.gameState.isGameStarted and not self.gameState.isGameEnded do
			local currentTime = tick()
			local elapsed = currentTime - lastUpdateTime

			if elapsed >= 1 then
				lastUpdateTime = currentTime
				self.gameState.gameTime = self.gameState.gameTime + 1
			end

			wait(0.2)
		end
	end)
end

function GameManager:CheckWinCondition()
	-- Check player count
	local activePlayers = self.playerManager:GetPlayerCount()
	if activePlayers <= 1 then
		-- Find last player
		local lastPlayer = nil
		for _, player in pairs(Players:GetPlayers()) do
			lastPlayer = player
			break
		end

		if lastPlayer then
			self:EndGame(lastPlayer.Name .. " wins! (Last player remaining)")
			return true
		end
	end

	-- Check turn count
	if self.gameState.currentTurn >= 30 then
		local richestPlayer = nil
		local highestMoney = 0

		for _, player in pairs(Players:GetPlayers()) do
			local playerData = self.playerManager:GetPlayerData(player)
			if playerData and playerData.stats and playerData.stats.money > highestMoney then
				richestPlayer = player
				highestMoney = playerData.stats.money
			end
		end

		if richestPlayer then
			self:EndGame(richestPlayer.Name .. " wins with " .. highestMoney .. " coins!")
			return true
		end
	end

	return false
end

function GameManager:OnPlayerRemoving(player)
	-- Remove player data
	self.playerManager:UnregisterPlayer(player)
	self.playersReady[player.UserId] = nil
	self.playersSelectedClass[player.UserId] = nil

	-- Update player count
	local playerCount = self.playerManager:GetPlayerCount()
	local readyCount = self:CountReadyPlayers()
	self.remotes.ui.updatePlayersReady:FireAllClients(readyCount, playerCount)

	-- Check remaining players
	if self.gameState.isGameStarted and playerCount < MIN_PLAYERS then
		self:EndGame("Not enough players remaining (only " .. playerCount .. " left)")
	end

	-- Check win condition
	self:CheckWinCondition()
end

function GameManager:EndGame(reason)
	-- Update game state
	self.gameState.isGameEnded = true

	-- Cancel timers
	if self.timers.playerCheck then
		self.timers.playerCheck:Disconnect()
		self.timers.playerCheck = nil
	end

	if self.timers.classSelection then
		self.timers.classSelection:Disconnect()
		self.timers.classSelection = nil
	end

	-- Reset turn system
	if self.turnSystem then
		self.turnSystem:Reset()
	end

	-- Notify all clients
	self.remotes.game.endGame:FireAllClients(reason)

	-- Show stats
	self:ShowGameStats(reason)
end

function GameManager:ShowGameStats(reason)
	-- Create stats data
	local gameStats = {
		reason = reason,
		totalTurns = self.gameState.currentTurn,
		gameDuration = self.gameState.gameTime,
		playerStats = {}
	}

	-- Collect player stats
	for _, player in pairs(Players:GetPlayers()) do
		local playerData = self.playerManager:GetPlayerData(player)
		if playerData then
			table.insert(gameStats.playerStats, {
				playerName = player.Name,
				playerId = player.UserId,
				level = playerData.stats and playerData.stats.level or 1,
				money = playerData.stats and playerData.stats.money or 0,
				class = playerData.class or "Unknown"
			})
		end
	end

	-- Sort by money
	table.sort(gameStats.playerStats, function(a, b)
		return (a.money or 0) > (b.money or 0)
	end)

	-- Send stats
	local statsEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("GameRemotes"):FindFirstChild("GameStats")
	if not statsEvent then
		statsEvent = Instance.new("RemoteEvent")
		statsEvent.Name = "GameStats"
		statsEvent.Parent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("GameRemotes")
	end

	statsEvent:FireAllClients(gameStats)
end

function GameManager:ResetGame()
	-- Reset game state
	self.gameState = {
		isLoading = true,
		isClassSelection = false,
		isGameStarted = false,
		isGameEnded = false,
		currentTurn = 0,
		gameTime = 0,
		selectionTimeLeft = CLASS_SELECTION_TIME
	}

	-- Clear data
	self.playersReady = {}
	self.playersSelectedClass = {}

	-- Cancel timers
	if self.timers.playerCheck then
		self.timers.playerCheck:Disconnect()
		self.timers.playerCheck = nil
	end

	if self.timers.classSelection then
		self.timers.classSelection:Disconnect()
		self.timers.classSelection = nil
	end

	-- Reset players
	for _, player in pairs(Players:GetPlayers()) do
		self.playerManager:RegisterPlayer(player)
		self.playersReady[player.UserId] = false
		self.remotes.ui.updateLoading:FireClient(player, 0)
	end

	-- Start player check
	self:StartPlayerCheck()
end

return GameManager
