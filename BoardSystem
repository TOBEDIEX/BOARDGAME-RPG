-- BoardSystem.lua
-- โมดูลหลักสำหรับระบบกระดานและการเคลื่อนที่ของตัวละคร
-- Version: 2.1.0 (Optimized)

local BoardSystem = {}
BoardSystem.__index = BoardSystem

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")

-- โหลดโมดูลที่เกี่ยวข้อง
local DirectionalPathfinder = require(script.Parent:WaitForChild("DirectionalPathfinder"))

-- Constants for board directions
local DIRECTIONS = DirectionalPathfinder.DIRECTIONS

function BoardSystem.new()
	local self = setmetatable({}, BoardSystem)

	self.tiles = {}
	self.connections = {}
	self.playerPositions = {}
	self.playerLastTile = {}
	self.playerRemainingSteps = {}
	self.playerMovementState = {}
	self.playerAutoPath = {}
	self.tilePositions = {}
	self.entitySpawnPoints = {}
	self.onPlayerMoved = nil
	self.onPlayerPathComplete = nil
	self.onTileEffect = nil

	return self
end

function BoardSystem:LoadMap(mapData)
	if not mapData or type(mapData) ~= "table" then return false end

	-- Reset data
	self.tiles = {}
	self.connections = {}
	self.tilePositions = {}

	-- Load tile data
	for id, tile in pairs(mapData.tiles or {}) do
		self.tiles[id] = {
			id = id,
			type = tile.type or "normal",
			properties = tile.properties or {},
			position = tile.position
		}

		if tile.position then
			self.tilePositions[id] = tile.position
		end
	end

	-- Load connections
	for id, connections in pairs(mapData.connections or {}) do
		self.connections[id] = connections
	end

	-- Load spawn points
	self.entitySpawnPoints = mapData.entitySpawnPoints or {}

	return true
end

function BoardSystem:CountTiles()
	local count = 0
	for _ in pairs(self.tiles) do
		count = count + 1
	end
	return count
end

function BoardSystem:SetPlayerPosition(playerId, tileId, lastTileId)
	if not playerId or not tileId then return false end

	-- Store previous position
	self.playerLastTile[playerId] = lastTileId or self.playerPositions[playerId]

	-- Set new position
	self.playerPositions[playerId] = tileId

	-- Call callback if set
	if self.onPlayerMoved then
		self.onPlayerMoved(playerId, self.playerLastTile[playerId], tileId)
	end

	return true
end

function BoardSystem:GetPlayerTile(playerId)
	return self.playerPositions[playerId]
end

function BoardSystem:GetTilePosition(tileId)
	return self.tilePositions[tileId]
end

function BoardSystem:GetTileInfo(tileId)
	return self.tiles[tileId]
end

function BoardSystem:GetTilesByType(tileType)
	local result = {}

	for id, tile in pairs(self.tiles) do
		if tile.type == tileType then
			table.insert(result, id)
		end
	end

	return result
end

function BoardSystem:GetAvailableDirections(tileId, prevTileId)
	-- Use DirectionalPathfinder for direction calculation
	local pathOptions = DirectionalPathfinder.getPathOptions(
		prevTileId, tileId, self.connections, self.tilePositions)

	return pathOptions
end

function BoardSystem:GetNextTileFromDirection(tileId, direction, prevTileId)
	local availableDirections = self:GetAvailableDirections(tileId, prevTileId)

	for _, dirInfo in ipairs(availableDirections) do
		if dirInfo.direction == direction then
			return dirInfo.tileId
		end
	end

	return nil
end

function BoardSystem:GetPlayersOnTile(tileId)
	local players = {}

	for playerId, playerTileId in pairs(self.playerPositions) do
		if playerTileId == tileId then
			table.insert(players, playerId)
		end
	end

	return players
end

function BoardSystem:GenerateAutoPath(playerId, startTileId, prevTileId, stepsRemaining)
	local currentTileId = startTileId
	local currentPrevTileId = prevTileId
	local path = {currentTileId}
	local remainingSteps = stepsRemaining

	while remainingSteps > 0 do
		-- Get available directions
		local availableDirections = self:GetAvailableDirections(currentTileId, currentPrevTileId)

		-- Stop if dead end
		if #availableDirections == 0 then break end

		-- Auto-move only when there's only one way forward
		if #availableDirections == 1 then
			local nextTileId = availableDirections[1].tileId

			-- Make sure we're not going backwards
			if nextTileId ~= currentPrevTileId then
				table.insert(path, nextTileId)
				currentPrevTileId = currentTileId
				currentTileId = nextTileId
				remainingSteps = remainingSteps - 1
			else
				break -- Found previous tile, treat as fork
			end
		else
			break -- Multiple directions, player must choose
		end
	end

	-- Return path info
	return {
		path = path,
		autoComplete = remainingSteps == 0,
		endTileId = path[#path],
		stepsRemaining = remainingSteps,
		endPrevTileId = path[#path-1] or currentPrevTileId,
		availableDirections = remainingSteps > 0 and 
			self:GetAvailableDirections(path[#path], path[#path-1] or currentPrevTileId) or {}
	}
end

function BoardSystem:ProcessPlayerMove(playerId, diceResult)
	local currentTileId = self.playerPositions[playerId]
	local prevTileId = self.playerLastTile[playerId]

	if not currentTileId then return false end

	-- Store remaining steps
	self.playerRemainingSteps = self.playerRemainingSteps or {}
	self.playerRemainingSteps[playerId] = diceResult

	-- Generate auto path
	local pathInfo = self:GenerateAutoPath(playerId, currentTileId, prevTileId, diceResult)

	-- Store path for reference
	self.playerAutoPath[playerId] = pathInfo.path

	-- Set movement state and handle path
	if pathInfo.autoComplete then
		-- Auto-complete path
		self.playerMovementState[playerId] = "auto_complete"

		-- Move player to final tile
		if #pathInfo.path > 1 then
			self:SetPlayerPosition(playerId, pathInfo.endTileId, pathInfo.endPrevTileId)
		end

		-- Reset remaining steps
		self.playerRemainingSteps[playerId] = 0

		-- Trigger tile effect
		if self.onTileEffect then
			self.onTileEffect(playerId, pathInfo.endTileId, self.tiles[pathInfo.endTileId])
		end

		-- Call path complete callback
		if self.onPlayerPathComplete then
			self.onPlayerPathComplete(playerId, pathInfo.endTileId)
		end

		return {
			autoPath = pathInfo.path,
			endTileId = pathInfo.endTileId,
			stepsRemaining = 0,
			availableDirections = {},
			requiresChoice = false,
			autoComplete = true
		}
	else
		-- Path to fork then requires choice
		self.playerMovementState[playerId] = "need_choice"

		-- Move player to last auto-path tile
		if #pathInfo.path > 1 then
			self:SetPlayerPosition(playerId, pathInfo.endTileId, pathInfo.endPrevTileId)
		end

		-- Update remaining steps
		self.playerRemainingSteps[playerId] = pathInfo.stepsRemaining

		return {
			autoPath = pathInfo.path,
			endTileId = pathInfo.endTileId,
			stepsRemaining = pathInfo.stepsRemaining,
			availableDirections = pathInfo.availableDirections,
			requiresChoice = true,
			autoComplete = false
		}
	end
end

function BoardSystem:ProcessDirectionChoice(playerId, direction)
	local currentTileId = self.playerPositions[playerId]
	local prevTileId = self.playerLastTile[playerId]
	local stepsRemaining = self.playerRemainingSteps[playerId] or 0

	if stepsRemaining <= 0 then return false end

	-- Get next tile based on direction
	local nextTileId = self:GetNextTileFromDirection(currentTileId, direction, prevTileId)
	if not nextTileId then return false end

	-- Move one step in chosen direction
	self:SetPlayerPosition(playerId, nextTileId, currentTileId)

	-- Reduce remaining steps
	stepsRemaining = stepsRemaining - 1
	self.playerRemainingSteps[playerId] = stepsRemaining

	-- Continue movement if steps remain
	if stepsRemaining > 0 then
		-- Generate new auto path from chosen tile
		local pathInfo = self:GenerateAutoPath(playerId, nextTileId, currentTileId, stepsRemaining)

		-- Update auto path
		self.playerAutoPath[playerId] = pathInfo.path

		if pathInfo.autoComplete then
			-- Auto-complete remaining path
			self.playerMovementState[playerId] = "auto_complete"

			-- Move player to final tile
			if #pathInfo.path > 1 then
				self:SetPlayerPosition(playerId, pathInfo.endTileId, pathInfo.endPrevTileId)
			end

			-- Reset remaining steps
			self.playerRemainingSteps[playerId] = 0

			-- Trigger tile effect
			if self.onTileEffect then
				self.onTileEffect(playerId, pathInfo.endTileId, self.tiles[pathInfo.endTileId])
			end

			-- Call path complete callback
			if self.onPlayerPathComplete then
				self.onPlayerPathComplete(playerId, pathInfo.endTileId)
			end

			return {
				autoPath = pathInfo.path,
				endTileId = pathInfo.endTileId,
				stepsRemaining = 0,
				availableDirections = {},
				requiresChoice = false,
				autoComplete = true,
				moveComplete = true
			}
		else
			-- Path to next fork, requires another choice
			self.playerMovementState[playerId] = "need_choice"

			-- Move player to last auto-path tile
			if #pathInfo.path > 1 then
				self:SetPlayerPosition(playerId, pathInfo.endTileId, pathInfo.endPrevTileId)
			end

			-- Update remaining steps
			self.playerRemainingSteps[playerId] = pathInfo.stepsRemaining

			return {
				autoPath = pathInfo.path,
				endTileId = pathInfo.endTileId,
				stepsRemaining = pathInfo.stepsRemaining,
				availableDirections = pathInfo.availableDirections,
				requiresChoice = true,
				autoComplete = false,
				moveComplete = false
			}
		end
	else
		-- Movement complete (used all steps)
		self.playerRemainingSteps[playerId] = 0
		self.playerMovementState[playerId] = "waiting"

		-- Trigger tile effect
		if self.onTileEffect then
			self.onTileEffect(playerId, nextTileId, self.tiles[nextTileId])
		end

		-- Call path complete callback
		if self.onPlayerPathComplete then
			self.onPlayerPathComplete(playerId, nextTileId)
		end

		return {
			autoPath = {currentTileId, nextTileId},
			endTileId = nextTileId,
			stepsRemaining = 0,
			availableDirections = {},
			requiresChoice = false,
			autoComplete = true,
			moveComplete = true
		}
	end
end

function BoardSystem:SetupCallbacks(onPlayerMoved, onPlayerPathComplete, onTileEffect)
	self.onPlayerMoved = onPlayerMoved
	self.onPlayerPathComplete = onPlayerPathComplete
	self.onTileEffect = onTileEffect
end

return BoardSystem
