-- PlayerManager.lua
-- Version: 5.0.4 (Formatted - No Debug, No Comments)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local ClassData = nil
local success, result = pcall(function()
	return require(ReplicatedStorage:WaitForChild("SharedModules"):WaitForChild("ClassData"))
end)
if success then
	ClassData = result
else
	ClassData = {
		Classes = {
			Warrior = { BaseStats = { MaxHP = 125, MaxMP = 50, ATK = 95, MAGIC = 10 } },
			Mage = { BaseStats = { MaxHP = 85, MaxMP = 120, ATK = 25, MAGIC = 95 } },
			Thief = { BaseStats = { MaxHP = 100, MaxMP = 60, ATK = 75, MAGIC = 30 } }
		},
		GetClassInfo = function(self, className) return self.Classes[className] end,
		GetDefaultStats = function(self, className) return self.Classes[className] and self.Classes[className].BaseStats end
	}
end

local HEALTH_SYNC_INTERVAL = 0.5
local AUTO_HEAL_ENABLED = false
local AUTO_HEAL_INTERVAL = 10
local AUTO_HEAL_AMOUNT = 5
local MAX_AUTO_HEAL_PERCENT = 50

local PlayerManager = {}
PlayerManager.__index = PlayerManager

function PlayerManager.new(gameManager)
	local self = setmetatable({}, PlayerManager)
	self.gameManager = gameManager
	self.players = {}
	self.playerCount = 0
	self.healthSyncConnections = {}
	self:InitializeRemotes()
	return self
end

function PlayerManager:InitializeRemotes()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local healthRemotes = remotes:FindFirstChild("HealthRemotes")
	if not healthRemotes then
		healthRemotes = Instance.new("Folder")
		healthRemotes.Name = "HealthRemotes"
		healthRemotes.Parent = remotes
	end
	self.updatePlayerStatsEvent = uiRemotes:FindFirstChild("UpdatePlayerStats") or Instance.new("RemoteEvent", uiRemotes)
	self.updatePlayerStatsEvent.Name = "UpdatePlayerStats"
	self.statChangedEvent = uiRemotes:FindFirstChild("StatChanged") or Instance.new("RemoteEvent", uiRemotes)
	self.statChangedEvent.Name = "StatChanged"
	self.playerDamagedEvent = uiRemotes:FindFirstChild("PlayerDamaged") or Instance.new("RemoteEvent", uiRemotes)
	self.playerDamagedEvent.Name = "PlayerDamaged"
	self.requestHealFunction = healthRemotes:FindFirstChild("RequestHeal") or Instance.new("RemoteFunction", healthRemotes)
	self.requestHealFunction.Name = "RequestHeal"
end

function PlayerManager:SetupHealthRequestFunctions()
	self.requestHealFunction.OnServerInvoke = function(player, healAmount)
		local playerData = self:GetPlayerData(player)
		if not playerData then return false, "Player data not found" end
		healAmount = healAmount or 10
		if healAmount == "full" then
			healAmount = playerData.stats.maxHp - playerData.stats.hp
		else
			healAmount = math.min(tonumber(healAmount) or 0, 50)
		end
		if healAmount <= 0 then return false, "Invalid heal amount" end
		local newHP = math.min(playerData.stats.hp + healAmount, playerData.stats.maxHp)
		local actualHeal = newHP - playerData.stats.hp
		if actualHeal > 0 then
			self:UpdatePlayerHP(player, newHP)
			return true, "Healed for " .. actualHeal
		else
			return false, "Already at full health"
		end
	end
end

function PlayerManager:GetDefaultStatsForClass(className)
	local defaultStats = {
		level = 1, hp = 100, maxHp = 100, mp = 50, maxMp = 50,
		attack = 10, defense = 10, magic = 10, money = 100
	}
	if not className then return defaultStats end
	local classStats = ClassData and ClassData.GetDefaultStats and ClassData:GetDefaultStats(className)
	if not classStats then
		if className == "Warrior" then
			defaultStats = { level = 1, hp = 125, maxHp = 125, mp = 50, maxMp = 50, attack = 95, defense = 10, magic = 10, money = 100 }
		elseif className == "Mage" then
			defaultStats = { level = 1, hp = 85, maxHp = 85, mp = 120, maxMp = 120, attack = 25, defense = 10, magic = 95, money = 100 }
		elseif className == "Thief" then
			defaultStats = { level = 1, hp = 100, maxHp = 100, mp = 60, maxMp = 60, attack = 75, defense = 10, magic = 30, money = 150 }
		end
		return defaultStats
	end
	local stats = {
		level = 1,
		hp = classStats.MaxHP or defaultStats.maxHp,
		maxHp = classStats.MaxHP or defaultStats.maxHp,
		mp = classStats.MaxMP or defaultStats.maxMp,
		maxMp = classStats.MaxMP or defaultStats.maxMp,
		attack = classStats.ATK or defaultStats.attack,
		defense = classStats.DEF or defaultStats.defense,
		magic = classStats.MAGIC or defaultStats.magic,
		money = defaultStats.money
	}
	if className == "Thief" then stats.money = 150 end
	return stats
end

function PlayerManager:RegisterPlayer(player, className)
	if not player then return nil end
	local userId = player.UserId
	if self.players[userId] then
		self.players[userId].player = player
		self.players[userId].isConnected = true
		self:ConnectPlayerHealth(player)
		self:SyncPlayerStats(player)
		return self.players[userId]
	end
	local initialStats = self:GetDefaultStatsForClass(className)
	self.players[userId] = {
		player = player,
		isConnected = true,
		joinTime = os.time(),
		class = className or "Unknown",
		stats = initialStats,
		baseStats = table.clone(initialStats),
		inventory = {},
		position = nil,
		isAlive = true
	}
	self.playerCount = self.playerCount + 1
	self:ConnectPlayerHealth(player)
	self:SyncPlayerStats(player)
	return self.players[userId]
end

function PlayerManager:UnregisterPlayer(player)
	if not player then return end
	local userId = player.UserId
	if self.players[userId] then
		self:DisconnectPlayerHealth(player)
		self.players[userId] = nil
		self.playerCount = self.playerCount - 1
		self.playerCount = math.max(0, self.playerCount)
	end
end

function PlayerManager:ConnectPlayerHealth(player)
	if not player then return end
	self:DisconnectPlayerHealth(player)
	local character = player.Character or player.CharacterAdded:Wait()
	if not character then return end
	self:SetupCharacterHealth(player, character)
	player.CharacterAdded:Connect(function(newCharacter)
		self:DisconnectPlayerHealth(player)
		self:SetupCharacterHealth(player, newCharacter)
	end)
end

function PlayerManager:SetupCharacterHealth(player, character)
	if not player or not character then return end
	local humanoid = character:WaitForChild("Humanoid", 5)
	if not humanoid then return end
	local playerData = self:GetPlayerData(player)
	if not playerData then return end
	local statsHP = playerData.stats.hp
	local statsMaxHP = playerData.stats.maxHp
	humanoid.MaxHealth = statsMaxHP
	humanoid.Health = math.min(statsHP, statsMaxHP)
	local healthRegenScript = humanoid:FindFirstChild("Health")
	if healthRegenScript and healthRegenScript:IsA("Script") then
		healthRegenScript.Disabled = true
	end

	local healthChangedConnection = humanoid.HealthChanged:Connect(function(newHealth)
		local currentStatsHP = playerData.stats.hp
		if newHealth < currentStatsHP and self.healthSyncConnections[player.UserId] and not self.healthSyncConnections[player.UserId].isSyncing then
			self:UpdatePlayerHP(player, newHealth)
		end
	end)

	local syncConnection = RunService.Heartbeat:Connect(function()
		if not self.players[player.UserId] or not character or not character.Parent or not humanoid or not humanoid.Parent then
			self:DisconnectPlayerHealth(player)
			return
		end
		local currentPlayerData = self.players[player.UserId]
		local currentStatsHP = currentPlayerData.stats.hp
		local currentStatsMaxHP = currentPlayerData.stats.maxHp
		self.healthSyncConnections[player.UserId].isSyncing = true
		if humanoid.MaxHealth ~= currentStatsMaxHP then humanoid.MaxHealth = currentStatsMaxHP end
		if math.abs(humanoid.Health - currentStatsHP) > 0.1 then humanoid.Health = math.min(currentStatsHP, currentStatsMaxHP) end
		self.healthSyncConnections[player.UserId].isSyncing = false
	end)

	local healCoroutine = nil
	if AUTO_HEAL_ENABLED then
		healCoroutine = task.spawn(function()
			while self.healthSyncConnections[player.UserId] do
				task.wait(AUTO_HEAL_INTERVAL)
				if not self.players[player.UserId] then break end
				local currentPlayerData = self.players[player.UserId]
				local currentStatsHP = currentPlayerData.stats.hp
				local currentStatsMaxHP = currentPlayerData.stats.maxHp
				local maxHealThreshold = currentStatsMaxHP * (MAX_AUTO_HEAL_PERCENT / 100)
				if currentStatsHP < maxHealThreshold and currentPlayerData.isAlive then
					local newHP = math.min(currentStatsHP + AUTO_HEAL_AMOUNT, maxHealThreshold)
					self:UpdatePlayerHP(player, newHP)
				end
			end
		end)
	end

	self.healthSyncConnections[player.UserId] = {
		humanoid = humanoid,
		healthChanged = healthChangedConnection,
		sync = syncConnection,
		healCoroutine = healCoroutine,
		isSyncing = false
	}
end

function PlayerManager:DisconnectPlayerHealth(player)
	if not player then return end
	local userId = player.UserId
	local connections = self.healthSyncConnections[userId]
	if connections then
		if connections.healthChanged then connections.healthChanged:Disconnect() end
		if connections.sync then connections.sync:Disconnect() end
		if connections.healCoroutine then task.cancel(connections.healCoroutine) end
		self.healthSyncConnections[userId] = nil
	end
end

function PlayerManager:GetPlayerCount()
	return self.playerCount
end

function PlayerManager:GetAllPlayers()
	local result = {}
	for _, pd in pairs(self.players) do
		if pd.isConnected and pd.player and pd.player.Parent then
			table.insert(result, pd.player)
		end
	end
	return result
end

function PlayerManager:GetPlayerData(playerOrUserId)
	local userId = (typeof(playerOrUserId) == "Instance" and playerOrUserId:IsA("Player")) and playerOrUserId.UserId or (type(playerOrUserId) == "number" and playerOrUserId)
	return userId and self.players[userId]
end

function PlayerManager:SetPlayerClass(player, className)
	local playerData = self:GetPlayerData(player)
	if not playerData then return false end
	if playerData.class == className then return true end
	playerData.class = className
	local newBaseStats = self:GetDefaultStatsForClass(className)
	playerData.baseStats = table.clone(newBaseStats)
	for statName, baseValue in pairs(playerData.baseStats) do
		playerData.stats[statName] = baseValue
	end
	playerData.stats.hp = playerData.stats.maxHp
	playerData.stats.mp = playerData.stats.maxMp
	self:ApplyEquipmentStatsToPlayer(player)
	return true
end

function PlayerManager:ApplyEquipmentStatsToPlayer(player)
	local playerData = self:GetPlayerData(player)
	if not playerData then return false, "Player data not found" end
	if not playerData.baseStats then
		playerData.baseStats = self:GetDefaultStatsForClass(playerData.class)
		for k, v in pairs(playerData.baseStats) do playerData.stats[k] = v end
		playerData.stats.hp = playerData.stats.maxHp
		playerData.stats.mp = playerData.stats.maxMp
	end
	local inventoryService = self.gameManager and self.gameManager.inventoryService
	local inventory = inventoryService and inventoryService.GetPlayerInventory(player)
	local equipmentStats = inventory and inventory:CalculateEquipmentStats() or {}
	local finalStats = {}
	for k, v in pairs(playerData.baseStats) do
		finalStats[k] = v + (equipmentStats[k] or 0)
	end
	for k, v in pairs(finalStats) do
		playerData.stats[k] = v
	end
	playerData.stats.hp = playerData.stats.maxHp
	playerData.stats.mp = playerData.stats.maxMp
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		local h = player.Character.Humanoid
		h.MaxHealth = playerData.stats.maxHp
		h.Health = playerData.stats.hp
	end
	self:SyncPlayerStats(player)
	return true
end

function PlayerManager:UpdatePlayerStats(player, statUpdates)
	local playerData = self:GetPlayerData(player)
	if not playerData then return false, "Player data not found" end
	if not statUpdates or next(statUpdates) == nil then return false, "No stats provided" end
	local changedStats = {}
	local hpChanged, mpChanged = false, false
	for stat, value in pairs(statUpdates) do
		if playerData.stats[stat] ~= nil and playerData.stats[stat] ~= value then
			playerData.stats[stat] = value
			changedStats[stat] = { oldValue = playerData.stats[stat], newValue = value }
			if stat == "hp" or stat == "maxHp" then hpChanged = true end
			if stat == "mp" or stat == "maxMp" then mpChanged = true end
		end
	end
	if hpChanged then
		playerData.stats.hp = math.clamp(playerData.stats.hp, 0, playerData.stats.maxHp)
		if changedStats.hp and changedStats.hp.newValue ~= playerData.stats.hp then
			changedStats.hp.newValue = playerData.stats.hp
		end
	end
	if mpChanged then
		playerData.stats.mp = math.clamp(playerData.stats.mp, 0, playerData.stats.maxMp)
		if changedStats.mp and changedStats.mp.newValue ~= playerData.stats.mp then
			changedStats.mp.newValue = playerData.stats.mp
		end
	end
	if next(changedStats) ~= nil then
		if self.statChangedEvent then self.statChangedEvent:FireClient(player, changedStats) end
		self:SyncPlayerStats(player)
		if hpChanged then self:UpdateHumanoidHP(player) end
		if hpChanged and playerData.stats.hp <= 0 and playerData.isAlive then
			playerData.isAlive = false
			self:HandlePlayerDeath(player)
		end
		return true, changedStats
	else
		return false, "No stats were changed"
	end
end

function PlayerManager:SyncPlayerStats(player)
	local playerData = self:GetPlayerData(player)
	if not playerData or not playerData.isConnected then return false, "Player data not found or disconnected" end
	if not self.updatePlayerStatsEvent then return false, "RemoteEvent missing" end
	local playerObject = playerData.player
	if not playerObject or not playerObject.Parent then return false, "Player object invalid" end
	local userId = playerObject.UserId
	local statsToSync = {
		hp = playerData.stats.hp, maxHp = playerData.stats.maxHp,
		mp = playerData.stats.mp, maxMp = playerData.stats.maxMp,
		attack = playerData.stats.attack, defense = playerData.stats.defense, magic = playerData.stats.magic,
		level = playerData.stats.level or 1, class = playerData.class, money = playerData.stats.money
	}
	self.updatePlayerStatsEvent:FireClient(playerObject, userId, statsToSync)
	return true
end

function PlayerManager:UpdatePlayerHP(player, newHP)
	local playerData = self:GetPlayerData(player)
	if not playerData then return false, "Player data not found" end
	local oldHP = playerData.stats.hp
	local maxHP = playerData.stats.maxHp
	local clampedHP = math.clamp(newHP, 0, maxHP)
	if clampedHP == oldHP then
		self:UpdateHumanoidHP(player)
		return false, "HP unchanged"
	end
	playerData.stats.hp = clampedHP
	if self.statChangedEvent then
		self.statChangedEvent:FireClient(player, { hp = { oldValue = oldHP, newValue = clampedHP } })
	end
	self:SyncPlayerStats(player)
	self:UpdateHumanoidHP(player)
	if clampedHP <= 0 and playerData.isAlive then
		playerData.isAlive = false
		self:HandlePlayerDeath(player)
	end
	return true, "HP updated"
end

function PlayerManager:UpdateHumanoidHP(player)
	local playerData = self:GetPlayerData(player)
	if not playerData or not player.Character then return end
	local humanoid = player.Character:FindFirstChild("Humanoid")
	if not humanoid then return end
	if humanoid.MaxHealth ~= playerData.stats.maxHp then humanoid.MaxHealth = playerData.stats.maxHp end
	if math.abs(humanoid.Health - playerData.stats.hp) > 0.1 then humanoid.Health = playerData.stats.hp end
end

function PlayerManager:UpdatePlayerMP(player, newMP)
	local playerData = self:GetPlayerData(player)
	if not playerData then return false, "Player data not found" end
	local oldMP = playerData.stats.mp
	local maxMP = playerData.stats.maxMp
	local clampedMP = math.clamp(newMP, 0, maxMP)
	if clampedMP == oldMP then return false, "MP unchanged" end
	playerData.stats.mp = clampedMP
	if self.statChangedEvent then
		self.statChangedEvent:FireClient(player, { mp = { oldValue = oldMP, newValue = clampedMP } })
	end
	self:SyncPlayerStats(player)
	return true, "MP updated"
end

function PlayerManager:HandlePlayerDeath(player)
	local playerData = self:GetPlayerData(player)
	if not playerData or not playerData.isAlive then return end
	playerData.isAlive = false
	task.delay(3, function()
		local currentPlayerData = self:GetPlayerData(player)
		if currentPlayerData and not currentPlayerData.isAlive then
			currentPlayerData.stats.hp = currentPlayerData.stats.maxHp
			currentPlayerData.stats.mp = currentPlayerData.stats.maxMp
			currentPlayerData.isAlive = true
			player:LoadCharacter()
			task.wait(0.5)
			self:UpdateHumanoidHP(player)
			self:SyncPlayerStats(player)
		end
	end)
end

function PlayerManager:GetPlayersSortedByJoinTime()
	local sortedPlayersData = {}
	for _, pd in pairs(self.players) do
		if pd.isConnected then table.insert(sortedPlayersData, pd) end
	end
	table.sort(sortedPlayersData, function(a, b) return a.joinTime < b.joinTime end)
	return sortedPlayersData
end

function PlayerManager:DamagePlayer(player, damageAmount, source)
	local playerData = self:GetPlayerData(player)
	if not playerData or not playerData.isAlive then return false, "Player not found or already dead" end
	damageAmount = math.max(0, tonumber(damageAmount) or 0)
	source = source or "Unknown"
	if damageAmount == 0 then return false, "No damage dealt" end
	local oldHP = playerData.stats.hp
	local newHP = oldHP - damageAmount
	local success, message = self:UpdatePlayerHP(player, newHP)
	if success and self.playerDamagedEvent then
		self.playerDamagedEvent:FireClient(player, {
			oldHP = oldHP, newHP = playerData.stats.hp, maxHP = playerData.stats.maxHp,
			damage = damageAmount, source = source
		})
	end
	return success, message
end

function PlayerManager:SetAutoHealSettings(enabled, interval, amount, maxPercent)
	AUTO_HEAL_ENABLED = enabled or false
	AUTO_HEAL_INTERVAL = math.max(1, interval or AUTO_HEAL_INTERVAL)
	AUTO_HEAL_AMOUNT = math.max(1, amount or AUTO_HEAL_AMOUNT)
	MAX_AUTO_HEAL_PERCENT = math.clamp(maxPercent or MAX_AUTO_HEAL_PERCENT, 0, 100)
end

function PlayerManager:ResetPlayerStats(player)
	local playerData = self:GetPlayerData(player)
	if not playerData then return false, "Player data not found" end
	local className = playerData.class
	if not className then return false, "Player class unknown" end
	local newBaseStats = self:GetDefaultStatsForClass(className)
	playerData.baseStats = table.clone(newBaseStats)
	for k, v in pairs(playerData.baseStats) do playerData.stats[k] = v end
	playerData.stats.hp = playerData.stats.maxHp
	playerData.stats.mp = playerData.stats.maxMp
	self:ApplyEquipmentStatsToPlayer(player)
	return true
end

return PlayerManager
