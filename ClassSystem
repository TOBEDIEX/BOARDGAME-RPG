-- ClassSystem.lua
-- โมดูลจัดการระบบคลาสและการอัพเลเวลของผู้เล่น
-- Version: 1.2.0 (Optimized)

local ClassSystem = {}
ClassSystem.__index = ClassSystem

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Class data configurations
local CLASS_DATA = {
	Warrior = {
		name = "Warrior",
		description = "Strong physical attacker with high HP and defense.",
		baseStats = {
			hp = 120, mp = 40, attack = 15, defense = 12, magic = 5
		},
		growthRates = {
			hp = 12, mp = 4, attack = 3.5, defense = 2.5, magic = 1
		},
		specialAbilities = {"Strike", "PowerUp"},
		advancedClass = "Knight"
	},
	Mage = {
		name = "Mage",
		description = "Powerful magic user with high MP but lower defense.",
		baseStats = {
			hp = 80, mp = 100, attack = 6, defense = 7, magic = 18
		},
		growthRates = {
			hp = 7, mp = 10, attack = 1, defense = 1.5, magic = 4
		},
		specialAbilities = {"Spell", "MagicDefend"},
		advancedClass = "Wizard"
	},
	Thief = {
		name = "Thief",
		description = "Agile character with balanced stats and gold bonus.",
		baseStats = {
			hp = 90, mp = 60, attack = 11, defense = 9, magic = 8
		},
		growthRates = {
			hp = 8, mp = 6, attack = 2.5, defense = 2, magic = 1.5
		},
		specialAbilities = {"Counter", "Strike"},
		advancedClass = "Assassin"
	}
}

function ClassSystem.new()
	local self = setmetatable({}, ClassSystem)

	self.playerClasses = {}
	self.playerLevels = {}
	self.playerClassLevels = {}
	self.playerExp = {}
	self.playerClassExp = {}
	self.onClassAssigned = nil

	return self
end

function ClassSystem:GetAllClasses()
	local classes = {}
	for className in pairs(CLASS_DATA) do
		table.insert(classes, className)
	end
	return classes
end

function ClassSystem:GetClassData(className)
	return CLASS_DATA[className]
end

function ClassSystem:GetRandomClass()
	local classes = self:GetAllClasses()
	return classes[math.random(1, #classes)]
end

function ClassSystem:AssignClassToPlayer(player, className)
	if not CLASS_DATA[className] then return false end

	-- Store class assignment
	self.playerClasses[player.UserId] = className

	-- Initialize level and experience
	self.playerLevels[player.UserId] = 1
	self.playerClassLevels[player.UserId] = 1
	self.playerExp[player.UserId] = 0
	self.playerClassExp[player.UserId] = 0

	-- Update player stats via GameManager
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if playerManager then
		playerManager:SetPlayerClass(player, className)
	end

	-- Fire remote event to inform client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local classAssignedEvent = uiRemotes:WaitForChild("ClassAssigned")
	classAssignedEvent:FireClient(player, className, CLASS_DATA[className])

	-- Call event callback if set
	if self.onClassAssigned then
		self.onClassAssigned(player, className, CLASS_DATA[className])
	end

	return true
end

function ClassSystem:GetPlayerClass(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClasses[userId]
end

function ClassSystem:AddExperience(player, amount)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player

	if not self.playerExp[userId] then return false end

	-- Add experience
	self.playerExp[userId] = self.playerExp[userId] + amount
	self.playerClassExp[userId] = self.playerClassExp[userId] + math.floor(amount * 0.7)

	-- Check for level ups
	local leveledUp = self:CheckLevelUp(userId)
	local classLeveledUp = self:CheckClassLevelUp(userId)

	return leveledUp or classLeveledUp
end

function ClassSystem:CheckLevelUp(userId)
	-- Level formula: Level = sqrt(Experience / 100) + 1
	local newLevel = math.floor(math.sqrt(self.playerExp[userId] / 100)) + 1

	if newLevel > self.playerLevels[userId] then
		local oldLevel = self.playerLevels[userId]
		self.playerLevels[userId] = newLevel

		-- Calculate stat increases
		local className = self.playerClasses[userId]
		local classData = CLASS_DATA[className]
		local statIncreases = {}

		for stat, growthRate in pairs(classData.growthRates) do
			statIncreases[stat] = math.floor(growthRate * (newLevel - oldLevel))
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local levelUpEvent = uiRemotes:WaitForChild("LevelUp")
			levelUpEvent:FireClient(player, newLevel, statIncreases)

			-- Update player stats
			self:ApplyStatIncreases(player, statIncreases)
		end

		return true
	end

	return false
end

function ClassSystem:CheckClassLevelUp(userId)
	-- Class level formula: sqrt(ClassExp / 150) + 1
	local newClassLevel = math.floor(math.sqrt(self.playerClassExp[userId] / 150)) + 1

	if newClassLevel > self.playerClassLevels[userId] then
		local oldClassLevel = self.playerClassLevels[userId]
		self.playerClassLevels[userId] = newClassLevel

		-- Calculate class-specific stat increases
		local className = self.playerClasses[userId]
		local classData = CLASS_DATA[className]
		local statIncreases = {}

		for stat, growthRate in pairs(classData.growthRates) do
			-- Enhanced growth for primary class stats
			local enhancement = 1.0
			if className == "Warrior" and (stat == "attack" or stat == "defense" or stat == "hp") then
				enhancement = 1.5
			elseif className == "Mage" and (stat == "magic" or stat == "mp") then
				enhancement = 1.5
			elseif className == "Thief" and (stat == "attack" or stat == "defense") then
				enhancement = 1.3
			end

			statIncreases[stat] = math.floor(growthRate * enhancement * (newClassLevel - oldClassLevel))
		end

		-- Check for advanced class
		local advancedClass = newClassLevel >= 10 and classData.advancedClass or nil

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send class level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local classLevelUpEvent = uiRemotes:WaitForChild("ClassLevelUp")
			classLevelUpEvent:FireClient(player, newClassLevel, statIncreases, advancedClass)

			-- Update player stats and class
			self:ApplyStatIncreases(player, statIncreases)

			-- Update class if advanced
			if advancedClass then
				local playerManager = _G.GameManager and _G.GameManager.playerManager
				if playerManager and playerManager:GetPlayerData(player) then
					playerManager:GetPlayerData(player).class = advancedClass
				end
			end
		end

		return true
	end

	return false
end

-- Helper function to apply stat increases
function ClassSystem:ApplyStatIncreases(player, statIncreases)
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if not playerManager then return end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then return end

	for stat, increase in pairs(statIncreases) do
		if stat == "hp" then
			playerData.stats.maxHp = playerData.stats.maxHp + increase
			playerData.stats.hp = playerData.stats.maxHp -- Full heal on level up
		elseif stat == "mp" then
			playerData.stats.maxMp = playerData.stats.maxMp + increase
			playerData.stats.mp = playerData.stats.maxMp -- Full MP restore on level up
		else
			playerData.stats[stat] = (playerData.stats[stat] or 0) + increase
		end
	end
end

function ClassSystem:GetPlayerLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerLevels[userId] or 1
end

function ClassSystem:GetPlayerClassLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClassLevels[userId] or 1
end

return ClassSystem
