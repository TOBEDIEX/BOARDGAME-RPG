-- ClassSystem.lua
-- Module for managing player classes and class upgrades
-- Version: 4.0.0 (Optimized)

local ClassSystem = {}
ClassSystem.__index = ClassSystem

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Starter classes
local STARTER_CLASSES = {
	Warrior = true,
	Mage = true,
	Thief = true
}

-- Load ClassData module
local ClassData = require(ReplicatedStorage:WaitForChild("SharedModules"):WaitForChild("ClassData"))

-- Constants
local EXP_TO_LEVEL_DIVIDER = 100  -- For calculating level from exp
local CLASS_EXP_DIVIDER = 150     -- For calculating class level from exp

function ClassSystem.new()
	local self = setmetatable({}, ClassSystem)

	self.playerClasses = {}       -- Player classes
	self.playerLevels = {}        -- Player levels
	self.playerClassLevels = {}   -- Player class levels
	self.playerExp = {}           -- Player experience
	self.playerClassExp = {}      -- Player class experience
	self.onClassAssigned = nil    -- Called when class assigned
	self.onLevelUp = nil          -- Called when player levels up
	self.onClassLevelUp = nil     -- Called when class levels up

	return self
end

-- Get all starter classes
function ClassSystem:GetStarterClasses()
	local classes = {}
	for className, _ in pairs(STARTER_CLASSES) do
		table.insert(classes, className)
	end
	return classes
end

-- Get all classes (including upgrades)
function ClassSystem:GetAllClasses()
	local classes = {}
	for className, _ in pairs(ClassData.Classes) do
		table.insert(classes, className)
	end
	return classes
end

-- Get class data
function ClassSystem:GetClassData(className)
	return ClassData:GetClassInfo(className)
end

-- Get random starter class
function ClassSystem:GetRandomClass()
	local starterClasses = self:GetStarterClasses()
	return starterClasses[math.random(1, #starterClasses)]
end

-- Assign class to player
function ClassSystem:AssignClassToPlayer(player, className)
	-- Validate class
	if not ClassData:GetClassInfo(className) then 
		warn("Class not found: " .. tostring(className))
		return false 
	end

	-- Store class assignment
	self.playerClasses[player.UserId] = className

	-- Initialize level and experience
	self.playerLevels[player.UserId] = 1
	self.playerClassLevels[player.UserId] = 1
	self.playerExp[player.UserId] = 0
	self.playerClassExp[player.UserId] = 0

	-- Update player stats via GameManager
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if playerManager then
		self:UpdatePlayerStatsFromClass(player, playerManager)
	end

	-- Send RemoteEvent to client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local classAssignedEvent = uiRemotes:WaitForChild("ClassAssigned")
	local classData = ClassData:GetClassInfo(className)

	if classAssignedEvent and classData then
		classAssignedEvent:FireClient(player, className, classData)
	end

	-- Call callback if assigned
	if self.onClassAssigned then
		self.onClassAssigned(player, className, classData)
	end

	return true
end

-- Update player stats based on class
function ClassSystem:UpdatePlayerStatsFromClass(player, playerManager)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	local className = self.playerClasses[userId]

	if not className then
		warn("No class assigned to player: " .. tostring(userId))
		return false
	end

	local classData = ClassData:GetClassInfo(className)
	if not classData then
		warn("Invalid class data for: " .. tostring(className))
		return false
	end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then
		warn("No player data found for: " .. tostring(userId))
		return false
	end

	-- Update base stats
	local baseStats = classData.BaseStats
	if baseStats then
		-- Update HP and MP
		playerData.stats.maxHp = baseStats.MaxHP
		playerData.stats.hp = baseStats.MaxHP  -- Start with full health
		playerData.stats.maxMp = baseStats.MaxMP
		playerData.stats.mp = baseStats.MaxMP  -- Start with full mana

		-- Update combat stats
		playerData.stats.attack = baseStats.ATK
		playerData.stats.defense = baseStats.DEF
		playerData.stats.magic = baseStats.MAGIC
		playerData.stats.magicDefense = baseStats.MDEF or baseStats.DEF  -- Use DEF if MDEF not specified
		playerData.stats.agility = baseStats.AGI

		-- Store class
		playerData.class = className

		-- Send new stats to player
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local uiRemotes = remotes:WaitForChild("UIRemotes")
		local updatePlayerStatsEvent = uiRemotes:WaitForChild("UpdatePlayerStats")

		if updatePlayerStatsEvent then
			updatePlayerStatsEvent:FireClient(player, userId, {
				hp = playerData.stats.hp,
				maxHp = playerData.stats.maxHp,
				mp = playerData.stats.mp,
				maxMp = playerData.stats.maxMp,
				attack = playerData.stats.attack,
				defense = playerData.stats.defense,
				magic = playerData.stats.magic,
				magicDefense = playerData.stats.magicDefense,
				agility = playerData.stats.agility,
				level = self.playerLevels[userId] or 1,
				class = className,
				money = playerData.stats.money or 100
			})
		end

		return true
	end

	return false
end

-- Get player's class
function ClassSystem:GetPlayerClass(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClasses[userId]
end

-- Get player's level
function ClassSystem:GetPlayerLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerLevels[userId] or 1
end

-- Get player's class level
function ClassSystem:GetPlayerClassLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClassLevels[userId] or 1
end

-- Get exp required for next level
function ClassSystem:GetExpForNextLevel(level)
	return (level + 1) * (level + 1) * EXP_TO_LEVEL_DIVIDER
end

-- Get class exp required for next level
function ClassSystem:GetClassExpForNextLevel(classLevel)
	return (classLevel + 1) * (classLevel + 1) * CLASS_EXP_DIVIDER
end

-- Add experience to player
function ClassSystem:AddExperience(player, amount)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player

	if not self.playerExp[userId] then return false end

	-- Add experience
	self.playerExp[userId] = self.playerExp[userId] + amount
	self.playerClassExp[userId] = self.playerClassExp[userId] + math.floor(amount * 0.7)

	-- Check for level up
	local leveledUp = self:CheckLevelUp(userId)
	local classLeveledUp = self:CheckClassLevelUp(userId)

	-- Send updated exp to client
	local player = Players:GetPlayerByUserId(userId)
	if player then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local uiRemotes = remotes:WaitForChild("UIRemotes")
		local updateExpEvent = uiRemotes:FindFirstChild("UpdateExperience")

		if updateExpEvent then
			updateExpEvent:FireClient(player, {
				exp = self.playerExp[userId],
				nextLevelExp = self:GetExpForNextLevel(self.playerLevels[userId]),
				classExp = self.playerClassExp[userId],
				nextClassLevelExp = self:GetClassExpForNextLevel(self.playerClassLevels[userId])
			})
		end
	end

	return leveledUp or classLeveledUp
end

-- Check for level up
function ClassSystem:CheckLevelUp(userId)
	-- Calculate level: Level = sqrt(Experience / EXP_TO_LEVEL_DIVIDER) + 1
	local newLevel = math.floor(math.sqrt(self.playerExp[userId] / EXP_TO_LEVEL_DIVIDER)) + 1

	if newLevel > self.playerLevels[userId] then
		local oldLevel = self.playerLevels[userId]
		local levelDiff = newLevel - oldLevel
		self.playerLevels[userId] = newLevel

		-- Calculate stat increases
		local className = self.playerClasses[userId]
		local classData = ClassData:GetClassInfo(className)
		local statIncreases = {}

		if classData and classData.BaseStats then
			-- Growth rates for each stat
			local growthRates = {
				MaxHP = 0.1,    -- 10% of base value per level
				MaxMP = 0.08,   -- 8% of base value per level
				ATK = 0.12,     -- 12% of base value per level
				DEF = 0.09,     -- 9% of base value per level
				MAGIC = 0.11,   -- 11% of base value per level
				MDEF = 0.09,    -- 9% of base value per level
				AGI = 0.08      -- 8% of base value per level
			}

			-- Calculate stat increases
			for stat, baseValue in pairs(classData.BaseStats) do
				local growthRate = growthRates[stat] or 0.1
				statIncreases[stat] = math.floor(baseValue * growthRate * levelDiff)
			end
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local levelUpEvent = uiRemotes:WaitForChild("LevelUp")
			levelUpEvent:FireClient(player, newLevel, statIncreases)

			-- Apply stat increases
			self:ApplyStatIncreases(player, statIncreases)

			-- Call level up callback
			if self.onLevelUp then
				self.onLevelUp(player, newLevel, oldLevel, statIncreases)
			end
		end

		return true
	end

	return false
end

-- Check for class level up
function ClassSystem:CheckClassLevelUp(userId)
	-- Calculate class level: sqrt(ClassExp / CLASS_EXP_DIVIDER) + 1
	local newClassLevel = math.floor(math.sqrt(self.playerClassExp[userId] / CLASS_EXP_DIVIDER)) + 1

	if newClassLevel > self.playerClassLevels[userId] then
		local oldClassLevel = self.playerClassLevels[userId]
		local levelDiff = newClassLevel - oldClassLevel
		self.playerClassLevels[userId] = newClassLevel

		-- Calculate class-specific stat increases
		local className = self.playerClasses[userId]
		local classData = ClassData:GetClassInfo(className)
		local statIncreases = {}

		if classData and classData.BaseStats then
			-- Growth rates for each stat
			local growthRates = {
				MaxHP = 0.12,    -- 12% of base value per level
				MaxMP = 0.10,    -- 10% of base value per level
				ATK = 0.15,      -- 15% of base value per level
				DEF = 0.12,      -- 12% of base value per level
				MAGIC = 0.15,    -- 15% of base value per level
				MDEF = 0.12,     -- 12% of base value per level
				AGI = 0.10       -- 10% of base value per level
			}

			-- Calculate stat increases with class bonuses
			for stat, baseValue in pairs(classData.BaseStats) do
				local growthRate = growthRates[stat] or 0.12

				-- Class-specific bonuses
				local enhancement = 1.0
				if className == "Warrior" and (stat == "ATK" or stat == "DEF" or stat == "MaxHP") then
					enhancement = 1.5 -- 50% bonus for Warriors' ATK, DEF, HP
				elseif className == "Knight" and (stat == "DEF" or stat == "MaxHP") then
					enhancement = 1.8 -- 80% bonus for Knights' DEF, HP
				elseif className == "Paladin" and (stat == "DEF" or stat == "MaxHP" or stat == "MDEF") then
					enhancement = 2.0 -- 100% bonus for Paladins' DEF, HP, MDEF
				elseif className == "Mage" and (stat == "MAGIC" or stat == "MaxMP") then
					enhancement = 1.5 -- 50% bonus for Mages' MAGIC, MP
				elseif className == "Wizard" and (stat == "MAGIC" or stat == "MaxMP") then
					enhancement = 1.8 -- 80% bonus for Wizards' MAGIC, MP
				elseif className == "Archmage" and (stat == "MAGIC" or stat == "MaxMP" or stat == "MDEF") then
					enhancement = 2.0 -- 100% bonus for Archmages' MAGIC, MP, MDEF
				elseif className == "Thief" and (stat == "ATK" or stat == "AGI") then
					enhancement = 1.3 -- 30% bonus for Thieves' ATK, AGI
				elseif className == "Assassin" and (stat == "ATK" or stat == "AGI") then
					enhancement = 1.6 -- 60% bonus for Assassins' ATK, AGI
				elseif className == "Shadow" and (stat == "ATK" or stat == "AGI" or stat == "DEF") then
					enhancement = 1.8 -- 80% bonus for Shadows' ATK, AGI, DEF
				end

				statIncreases[stat] = math.floor(baseValue * growthRate * enhancement * levelDiff)
			end
		end

		-- Check for class upgrade
		local nextClass = nil
		local upgradeCondition = nil

		if classData then
			nextClass = classData.NextClass
			upgradeCondition = classData.UpgradeCondition
		end

		local canUpgradeClass = false

		-- Check upgrade condition
		if upgradeCondition and nextClass then
			if upgradeCondition.Type == "Level" and newClassLevel >= upgradeCondition.Value then
				canUpgradeClass = true
			end
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send class level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local classLevelUpEvent = uiRemotes:WaitForChild("ClassLevelUp")

			classLevelUpEvent:FireClient(
				player, 
				newClassLevel, 
				statIncreases, 
				canUpgradeClass and nextClass or nil
			)

			-- Apply stat increases
			self:ApplyStatIncreases(player, statIncreases)

			-- Notify if class upgrade available
			if canUpgradeClass and nextClass then
				local classUpgradeEvent = uiRemotes:FindFirstChild("ClassUpgradeAvailable")
				if classUpgradeEvent then
					local nextClassData = ClassData:GetClassInfo(nextClass)
					classUpgradeEvent:FireClient(player, nextClass, nextClassData)
				end
			end

			-- Call class level up callback
			if self.onClassLevelUp then
				self.onClassLevelUp(player, newClassLevel, oldClassLevel, statIncreases, canUpgradeClass and nextClass or nil)
			end
		end

		return true
	end

	return false
end

-- Apply stat increases to player
function ClassSystem:ApplyStatIncreases(player, statIncreases)
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if not playerManager then return end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then return end

	-- Map ClassData stat names to PlayerManager stat names
	local statMapping = {
		MaxHP = "maxHp",
		MaxMP = "maxMp",
		ATK = "attack",
		DEF = "defense",
		MAGIC = "magic",
		MDEF = "magicDefense",
		AGI = "agility"
	}

	-- Update each stat
	for classDataStat, increase in pairs(statIncreases) do
		local playerDataStat = statMapping[classDataStat]

		if playerDataStat then
			if playerDataStat == "maxHp" then
				playerData.stats.maxHp = playerData.stats.maxHp + increase
				playerData.stats.hp = playerData.stats.maxHp -- Restore full HP on level up
			elseif playerDataStat == "maxMp" then
				playerData.stats.maxMp = playerData.stats.maxMp + increase
				playerData.stats.mp = playerData.stats.maxMp -- Restore full MP on level up
			else
				playerData.stats[playerDataStat] = (playerData.stats[playerDataStat] or 0) + increase
			end
		end
	end

	-- Send updated stats to client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local updatePlayerStatsEvent = uiRemotes:WaitForChild("UpdatePlayerStats")

	updatePlayerStatsEvent:FireClient(player, player.UserId, {
		hp = playerData.stats.hp,
		maxHp = playerData.stats.maxHp,
		mp = playerData.stats.mp,
		maxMp = playerData.stats.maxMp,
		attack = playerData.stats.attack,
		defense = playerData.stats.defense,
		magic = playerData.stats.magic,
		magicDefense = playerData.stats.magicDefense,
		agility = playerData.stats.agility,
		level = self:GetPlayerLevel(player),
		class = self:GetPlayerClass(player),
		money = playerData.stats.money or 100
	})
end

-- Reset all player class data (for game restart)
function ClassSystem:ResetAllPlayerClasses()
	self.playerClasses = {}
	self.playerLevels = {}
	self.playerClassLevels = {}
	self.playerExp = {}
	self.playerClassExp = {}
end

return ClassSystem
