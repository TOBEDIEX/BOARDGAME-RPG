-- ClassSystem.lua
-- Module for managing player classes and stats
-- Location: ServerStorage/Modules/ClassSystem.lua
-- Version: 1.0.0

local ClassSystem = {}
ClassSystem.__index = ClassSystem

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Load ClassData module
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local ClassData = require(SharedModules:WaitForChild("ClassData"))

-- Constants
local EXP_TO_LEVEL_DIVIDER = 100  -- For calculating level from exp
local CLASS_EXP_DIVIDER = 150     -- For calculating class level from exp

-- Constructor
function ClassSystem.new()
	local self = setmetatable({}, ClassSystem)

	-- Player data storage
	self.playerClasses = {}       -- Player classes
	self.playerLevels = {}        -- Player levels
	self.playerClassLevels = {}   -- Player class levels
	self.playerExp = {}           -- Player experience
	self.playerClassExp = {}      -- Player class experience

	-- Event callbacks
	self.onClassAssigned = nil    -- Called when class assigned
	self.onLevelUp = nil          -- Called when player levels up
	self.onClassLevelUp = nil     -- Called when class levels up

	return self
end

-- Get all starter classes
function ClassSystem:GetStarterClasses()
	return ClassData:GetStarterClasses()
end

-- Get all classes (including upgrades)
function ClassSystem:GetAllClasses()
	return ClassData:GetAllClasses()
end

-- Get class info
function ClassSystem:GetClassInfo(className)
	return ClassData:GetClassInfo(className)
end

-- Get random starter class
function ClassSystem:GetRandomClass()
	local starterClasses = self:GetStarterClasses()
	return starterClasses[math.random(1, #starterClasses)]
end

-- Calculate stats for a player based on class and level
function ClassSystem:CalculatePlayerStats(userId, className, level)
	className = className or self.playerClasses[userId]
	level = level or self.playerLevels[userId] or 1

	if not className then
		return ClassData.DefaultStats
	end

	return ClassData:CalculateStatsAtLevel(className, level)
end

-- Assign class to player
function ClassSystem:AssignClassToPlayer(player, className)
	-- Get player ID
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player

	-- Validate class
	if not ClassData:GetClassInfo(className) then 
		warn("[ClassSystem] Class not found: " .. tostring(className))
		return false 
	end

	-- Store class assignment
	self.playerClasses[userId] = className

	-- Log assignment
	print("[ClassSystem] Assigning class " .. className .. " to player " .. (typeof(player) == "Instance" and player.Name or tostring(userId)))

	-- Initialize level and experience
	self.playerLevels[userId] = 1
	self.playerClassLevels[userId] = 1
	self.playerExp[userId] = 0
	self.playerClassExp[userId] = 0

	-- Update player stats via GameManager (if available)
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if playerManager then
		self:UpdatePlayerStatsFromClass(player, playerManager)
	end

	-- Send RemoteEvent to client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local classAssignedEvent = uiRemotes:WaitForChild("ClassAssigned")
	local classInfo = ClassData:GetClassInfo(className)

	if classAssignedEvent and classInfo then
		classAssignedEvent:FireClient(player, className, classInfo)
	end

	-- Call callback if assigned
	if self.onClassAssigned then
		self.onClassAssigned(player, className, classInfo)
	end

	return true
end

-- Update player stats based on class
function ClassSystem:UpdatePlayerStatsFromClass(player, playerManager)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	local className = self.playerClasses[userId]
	local level = self.playerLevels[userId] or 1

	if not className then
		warn("[ClassSystem] No class assigned to player: " .. tostring(userId))
		return false
	end

	-- Calculate stats based on class and level
	local stats = self:CalculatePlayerStats(userId, className, level)
	if not stats then
		warn("[ClassSystem] Failed to calculate stats for player: " .. tostring(userId))
		return false
	end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then
		warn("[ClassSystem] No player data found for: " .. tostring(userId))
		return false
	end

	-- Log stats for debugging
	print("[ClassSystem] Applying stats for " .. className .. " (Level " .. level .. "): " ..
		"MaxHP=" .. stats.MaxHP .. ", MaxMP=" .. stats.MaxMP .. 
		", ATK=" .. stats.ATK .. ", DEF=" .. stats.DEF .. 
		", MAGIC=" .. stats.MAGIC)

	-- Store current HP and MP values for percentage calculation
	local oldMaxHp = playerData.stats.maxHp
	local oldMaxMp = playerData.stats.maxMp
	local oldHp = playerData.stats.hp
	local oldMp = playerData.stats.mp

	-- If this is initial class assignment, use full stats
	local isInitialAssignment = oldMaxHp == 0 or oldMaxHp == 100 -- Default HP is 100

	-- Update base values
	playerData.stats.maxHp = stats.MaxHP
	playerData.stats.maxMp = stats.MaxMP
	playerData.stats.attack = stats.ATK
	playerData.stats.defense = stats.DEF
	playerData.stats.magic = stats.MAGIC
	playerData.stats.level = level
	playerData.class = className

	-- Update current values
	-- For initial assignment, set to full health/mana
	if isInitialAssignment then
		playerData.stats.hp = stats.MaxHP  -- Start with full health
		playerData.stats.mp = stats.MaxMP  -- Start with full mana
		print("[ClassSystem] Initial class assignment - setting full HP/MP")
	else
		-- Don't update HP/MP values, let them stay as they are
		-- This prevents overriding HP values that might have been changed by damage
		print("[ClassSystem] Class update - preserving current HP/MP values")
	end

	-- Store base stats for equipment calculations
	playerData.baseStats = {
		maxHp = stats.MaxHP,
		hp = playerData.stats.hp,
		maxMp = stats.MaxMP,
		mp = playerData.stats.mp,
		attack = stats.ATK,
		defense = stats.DEF,
		magic = stats.MAGIC,
		level = level,
		money = playerData.stats.money or 100
	}

	-- Update character's humanoid directly if available
	if typeof(player) == "Instance" and player.Character and player.Character:FindFirstChild("Humanoid") then
		local humanoid = player.Character:FindFirstChild("Humanoid")
		humanoid.MaxHealth = stats.MaxHP

		-- Only set Health on initial assignment to avoid overriding damage changes
		if isInitialAssignment then
			humanoid.Health = stats.MaxHP
		end
	end

	-- Send updated stats to client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local updatePlayerStatsEvent = uiRemotes:WaitForChild("UpdatePlayerStats")

	if updatePlayerStatsEvent then
		updatePlayerStatsEvent:FireClient(player, userId, {
			hp = playerData.stats.hp,
			maxHp = playerData.stats.maxHp,
			mp = playerData.stats.mp,
			maxMp = playerData.stats.maxMp,
			attack = playerData.stats.attack,
			defense = playerData.stats.defense,
			magic = playerData.stats.magic,
			level = level,
			class = className,
			money = playerData.stats.money or 100
		})
	end

	print("[ClassSystem] Updated player stats for " .. className .. ": HP=" .. 
		playerData.stats.hp .. "/" .. playerData.stats.maxHp)

	return true
end

-- Check for level up
function ClassSystem:CheckLevelUp(userId)
	-- Calculate level: Level = sqrt(Experience / EXP_TO_LEVEL_DIVIDER) + 1
	local newLevel = math.floor(math.sqrt(self.playerExp[userId] / EXP_TO_LEVEL_DIVIDER)) + 1

	if newLevel > self.playerLevels[userId] then
		local oldLevel = self.playerLevels[userId]
		local levelDiff = newLevel - oldLevel
		self.playerLevels[userId] = newLevel

		-- Calculate new stats based on level
		local className = self.playerClasses[userId]
		local oldStats = self:CalculatePlayerStats(userId, className, oldLevel)
		local newStats = self:CalculatePlayerStats(userId, className, newLevel)

		-- Calculate stat increases
		local statIncreases = {}
		for stat, newValue in pairs(newStats) do
			statIncreases[stat] = newValue - (oldStats[stat] or 0)
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local levelUpEvent = uiRemotes:WaitForChild("LevelUp")
			levelUpEvent:FireClient(player, newLevel, statIncreases)

			-- Apply stat increases
			self:ApplyStatIncreases(player, statIncreases)

			-- Call level up callback
			if self.onLevelUp then
				self.onLevelUp(player, newLevel, oldLevel, statIncreases)
			end
		end

		return true
	end

	return false
end

-- Apply stat increases to player
function ClassSystem:ApplyStatIncreases(player, statIncreases)
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if not playerManager then return end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then return end

	-- Map ClassData stat names to PlayerManager stat names
	local statMapping = {
		MaxHP = "maxHp",
		MaxMP = "maxMp",
		ATK = "attack",
		DEF = "defense",
		MAGIC = "magic"
	}

	-- Update each stat
	for classDataStat, increase in pairs(statIncreases) do
		local playerDataStat = statMapping[classDataStat]

		if playerDataStat then
			if playerDataStat == "maxHp" then
				playerData.stats.maxHp = playerData.stats.maxHp + increase
				playerData.stats.hp = playerData.stats.maxHp -- Restore full HP on level up

				-- Update baseStats too
				if playerData.baseStats then
					playerData.baseStats.maxHp = playerData.baseStats.maxHp + increase
					playerData.baseStats.hp = playerData.baseStats.maxHp
				end
			elseif playerDataStat == "maxMp" then
				playerData.stats.maxMp = playerData.stats.maxMp + increase
				playerData.stats.mp = playerData.stats.maxMp -- Restore full MP on level up

				-- Update baseStats too
				if playerData.baseStats then
					playerData.baseStats.maxMp = playerData.baseStats.maxMp + increase
					playerData.baseStats.mp = playerData.baseStats.maxMp
				end
			else
				playerData.stats[playerDataStat] = (playerData.stats[playerDataStat] or 0) + increase

				-- Update baseStats too
				if playerData.baseStats then
					playerData.baseStats[playerDataStat] = (playerData.baseStats[playerDataStat] or 0) + increase
				end
			end
		end
	end

	-- Send updated stats to client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local updatePlayerStatsEvent = uiRemotes:WaitForChild("UpdatePlayerStats")

	updatePlayerStatsEvent:FireClient(player, player.UserId, {
		hp = playerData.stats.hp,
		maxHp = playerData.stats.maxHp,
		mp = playerData.stats.mp,
		maxMp = playerData.stats.maxMp,
		attack = playerData.stats.attack,
		defense = playerData.stats.defense,
		magic = playerData.stats.magic,
		level = self:GetPlayerLevel(player),
		class = self:GetPlayerClass(player),
		money = playerData.stats.money or 100
	})
end

-- Get player's class
function ClassSystem:GetPlayerClass(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClasses[userId]
end

-- Get player's level
function ClassSystem:GetPlayerLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerLevels[userId] or 1
end

-- Get player's class level
function ClassSystem:GetPlayerClassLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClassLevels[userId] or 1
end

-- Get exp required for next level
function ClassSystem:GetExpForNextLevel(level)
	return (level + 1) * (level + 1) * EXP_TO_LEVEL_DIVIDER
end

-- Get class exp required for next level
function ClassSystem:GetClassExpForNextLevel(classLevel)
	return (classLevel + 1) * (classLevel + 1) * CLASS_EXP_DIVIDER
end

-- Add experience to player
function ClassSystem:AddExperience(player, amount)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player

	if not self.playerExp[userId] then return false end

	-- Add experience
	self.playerExp[userId] = self.playerExp[userId] + amount
	self.playerClassExp[userId] = self.playerClassExp[userId] + math.floor(amount * 0.7)

	-- Check for level up
	local leveledUp = self:CheckLevelUp(userId)
	local classLeveledUp = self:CheckClassLevelUp(userId)

	-- Send updated exp to client
	local player = Players:GetPlayerByUserId(userId)
	if player then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local uiRemotes = remotes:WaitForChild("UIRemotes")
		local updateExpEvent = uiRemotes:FindFirstChild("UpdateExperience")

		if updateExpEvent then
			updateExpEvent:FireClient(player, {
				exp = self.playerExp[userId],
				nextLevelExp = self:GetExpForNextLevel(self.playerLevels[userId]),
				classExp = self.playerClassExp[userId],
				nextClassLevelExp = self:GetClassExpForNextLevel(self.playerClassLevels[userId])
			})
		end
	end

	return leveledUp or classLeveledUp
end

-- Check for class level up and possible class upgrade
function ClassSystem:CheckClassLevelUp(userId)
	-- Calculate class level: sqrt(ClassExp / CLASS_EXP_DIVIDER) + 1
	local newClassLevel = math.floor(math.sqrt(self.playerClassExp[userId] / CLASS_EXP_DIVIDER)) + 1

	if newClassLevel > self.playerClassLevels[userId] then
		local oldClassLevel = self.playerClassLevels[userId]
		local levelDiff = newClassLevel - oldClassLevel
		self.playerClassLevels[userId] = newClassLevel

		-- Get current class and info
		local className = self.playerClasses[userId]
		local classInfo = ClassData:GetClassInfo(className)

		-- Calculate stat increases from class level up
		-- Here we're just using a fraction of the normal level up increases
		local oldStats = self:CalculatePlayerStats(userId, className, self.playerLevels[userId])
		local newStats = self:CalculatePlayerStats(userId, className, self.playerLevels[userId])

		local statIncreases = {}
		for stat, value in pairs(oldStats) do
			local baseIncrease = (newStats[stat] - value) * 0.3 -- 30% of normal level up
			statIncreases[stat] = math.floor(baseIncrease * levelDiff)
		end

		-- Check for class upgrade
		local nextClass = classInfo and classInfo.NextClass
		local upgradeCondition = classInfo and classInfo.UpgradeCondition

		local canUpgradeClass = false

		-- Check upgrade condition
		if upgradeCondition and nextClass then
			if upgradeCondition.Type == "Level" and newClassLevel >= upgradeCondition.Value then
				canUpgradeClass = true
			end
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send class level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local classLevelUpEvent = uiRemotes:WaitForChild("ClassLevelUp")

			classLevelUpEvent:FireClient(
				player, 
				newClassLevel, 
				statIncreases, 
				canUpgradeClass and nextClass or nil
			)

			-- Apply stat increases
			self:ApplyStatIncreases(player, statIncreases)

			-- Notify if class upgrade available
			if canUpgradeClass and nextClass then
				local classUpgradeEvent = uiRemotes:FindFirstChild("ClassUpgradeAvailable")
				if classUpgradeEvent then
					local nextClassInfo = ClassData:GetClassInfo(nextClass)
					classUpgradeEvent:FireClient(player, nextClass, nextClassInfo)
				end
			end

			-- Call class level up callback
			if self.onClassLevelUp then
				self.onClassLevelUp(player, newClassLevel, oldClassLevel, statIncreases, canUpgradeClass and nextClass or nil)
			end
		end

		return true
	end

	return false
end

-- Upgrade player to next class
function ClassSystem:UpgradePlayerClass(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	local currentClass = self.playerClasses[userId]

	if not currentClass then
		return false, "No class assigned to player"
	end

	local classInfo = ClassData:GetClassInfo(currentClass)
	if not classInfo or not classInfo.NextClass then
		return false, "No upgrade available for this class"
	end

	local nextClass = classInfo.NextClass
	local upgradeCondition = classInfo.UpgradeCondition

	-- Check upgrade condition
	if upgradeCondition then
		if upgradeCondition.Type == "Level" then
			local classLevel = self.playerClassLevels[userId] or 1
			if classLevel < upgradeCondition.Value then
				return false, "Class level too low for upgrade"
			end
		elseif upgradeCondition.Type == "Quest" or upgradeCondition.Type == "Item" or upgradeCondition.Type == "Skill" then
			-- In a real game, check if quest completed, item owned, or skill mastered
			-- For now, we'll assume the condition is met if it's not level-based
		end
	end

	-- Perform the upgrade
	return self:AssignClassToPlayer(player, nextClass)
end

-- Reset all player class data (for game restart)
function ClassSystem:ResetAllPlayerClasses()
	self.playerClasses = {}
	self.playerLevels = {}
	self.playerClassLevels = {}
	self.playerExp = {}
	self.playerClassExp = {}
end

return ClassSystem
