-- ClassSystem.lua
-- Module for managing player classes and class upgrades
-- Version: 4.2.0 (แก้ไขปัญหา BaseStats และรองรับกรณีเรียก ClassData ไม่ได้)

local ClassSystem = {}
ClassSystem.__index = ClassSystem

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Starter classes
local STARTER_CLASSES = {
	Warrior = true,
	Mage = true,
	Thief = true
}

-- Load ClassData module
local ClassData

-- ใช้ pcall เพื่อป้องกันกรณีโหลด ClassData ไม่ได้
local success, result = pcall(function()
	return require(ReplicatedStorage:WaitForChild("SharedModules"):WaitForChild("ClassData"))
end)

if success then
	ClassData = result
	print("[ClassSystem] Successfully loaded ClassData module")
else
	warn("[ClassSystem] Failed to load ClassData module: " .. tostring(result))
	-- สร้าง ClassData จำลอง
	ClassData = {
		Classes = {
			Warrior = { 
				BaseStats = { MaxHP = 125, MaxMP = 50, ATK = 95, MAGIC = 10 }
			},
			Mage = { 
				BaseStats = { MaxHP = 85, MaxMP = 120, ATK = 25, MAGIC = 95 }
			},
			Thief = { 
				BaseStats = { MaxHP = 100, MaxMP = 60, ATK = 75, MAGIC = 30 }
			}
		},
		GetClassInfo = function(self, className)
			return self.Classes[className]
		end
	}
end

-- Constants
local EXP_TO_LEVEL_DIVIDER = 100  -- For calculating level from exp
local CLASS_EXP_DIVIDER = 150     -- For calculating class level from exp

-- แก้ไข: เพิ่มฟังก์ชั่นสำหรับสร้างสถานะพื้นฐาน
local function createDefaultStats(className)
	local defaultStats = {
		MaxHP = 100,
		MaxMP = 50,
		ATK = 10,
		MAGIC = 10
	}

	-- ปรับแต่งตามคลาส
	if className == "Warrior" then
		defaultStats.MaxHP = 125
		defaultStats.ATK = 95
	elseif className == "Mage" then
		defaultStats.MaxHP = 85
		defaultStats.MaxMP = 120
		defaultStats.MAGIC = 95
	elseif className == "Thief" then
		defaultStats.ATK = 75
	end

	return defaultStats
end

function ClassSystem.new()
	local self = setmetatable({}, ClassSystem)

	self.playerClasses = {}       -- Player classes
	self.playerLevels = {}        -- Player levels
	self.playerClassLevels = {}   -- Player class levels
	self.playerExp = {}           -- Player experience
	self.playerClassExp = {}      -- Player class experience
	self.onClassAssigned = nil    -- Called when class assigned
	self.onLevelUp = nil          -- Called when player levels up
	self.onClassLevelUp = nil     -- Called when class levels up

	return self
end

-- Get all starter classes
function ClassSystem:GetStarterClasses()
	local classes = {}
	for className, _ in pairs(STARTER_CLASSES) do
		table.insert(classes, className)
	end
	return classes
end

-- Get all classes (including upgrades)
function ClassSystem:GetAllClasses()
	local classes = {}
	if ClassData and ClassData.Classes then
		for className, _ in pairs(ClassData.Classes) do
			table.insert(classes, className)
		end
	else
		-- ถ้าไม่มี ClassData ให้ใช้แค่คลาสเริ่มต้น
		for className, _ in pairs(STARTER_CLASSES) do
			table.insert(classes, className)
		end
	end
	return classes
end

-- Get class data
function ClassSystem:GetClassData(className)
	if not ClassData then
		warn("[ClassSystem] ClassData module not available")
		return {
			BaseStats = createDefaultStats(className)
		}
	end

	local classInfo = ClassData:GetClassInfo(className)
	if not classInfo then
		warn("[ClassSystem] Class info not found for: " .. tostring(className))
		return {
			BaseStats = createDefaultStats(className)
		}
	end

	return classInfo
end

-- Get random starter class
function ClassSystem:GetRandomClass()
	local starterClasses = self:GetStarterClasses()
	return starterClasses[math.random(1, #starterClasses)]
end

-- Assign class to player
function ClassSystem:AssignClassToPlayer(player, className)
	-- Validate class
	if not self:GetClassData(className) then 
		warn("[ClassSystem] Class not found: " .. tostring(className))
		return false 
	end

	-- Store class assignment
	self.playerClasses[player.UserId] = className

	-- Initialize level and experience
	self.playerLevels[player.UserId] = 1
	self.playerClassLevels[player.UserId] = 1
	self.playerExp[player.UserId] = 0
	self.playerClassExp[player.UserId] = 0

	-- Update player stats via GameManager
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if playerManager then
		self:UpdatePlayerStatsFromClass(player, playerManager)
	end

	-- Send RemoteEvent to client
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local classAssignedEvent = uiRemotes:WaitForChild("ClassAssigned")
	local classData = self:GetClassData(className)

	if classAssignedEvent and classData then
		classAssignedEvent:FireClient(player, className, classData)
	end

	-- Call callback if assigned
	if self.onClassAssigned then
		self.onClassAssigned(player, className, classData)
	end

	return true
end

-- Update player stats based on class
function ClassSystem:UpdatePlayerStatsFromClass(player, playerManager)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	local className = self.playerClasses[userId]

	if not className then
		warn("[ClassSystem] No class assigned to player: " .. tostring(userId))
		return false
	end

	local classData = self:GetClassData(className)
	if not classData then
		warn("[ClassSystem] Invalid class data for: " .. tostring(className))
		return false
	end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then
		warn("[ClassSystem] No player data found for: " .. tostring(userId))
		return false
	end

	-- Update base stats
	local baseStats = classData.BaseStats
	if baseStats then
		-- แก้ไข: ใช้ baseStats โดยตรง และจัดการกับค่าที่ไม่มี
		print("[ClassSystem] Loading stats for " .. className .. ": MaxHP=" .. (baseStats.MaxHP or "nil") .. 
			", MaxMP=" .. (baseStats.MaxMP or "nil") .. ", ATK=" .. (baseStats.ATK or "nil") .. 
			", MAGIC=" .. (baseStats.MAGIC or "nil"))

		-- Update HP and MP
		playerData.stats.maxHp = baseStats.MaxHP or 100
		playerData.stats.hp = baseStats.MaxHP or 100  -- Start with full health
		playerData.stats.maxMp = baseStats.MaxMP or 50
		playerData.stats.mp = baseStats.MaxMP or 50   -- Start with full mana

		-- Update combat stats - ใช้ค่าที่มีหรือค่าพื้นฐานถ้าไม่มี
		playerData.stats.attack = baseStats.ATK or 10
		playerData.stats.defense = 10  -- แก้ไข: ค่าพื้นฐานถ้าไม่มี DEF
		playerData.stats.magic = baseStats.MAGIC or 10
		playerData.stats.magicDefense = 10  -- แก้ไข: ค่าพื้นฐานถ้าไม่มี MDEF
		playerData.stats.agility = 10  -- แก้ไข: ค่าพื้นฐานถ้าไม่มี AGI

		-- Store class
		playerData.class = className

		-- บันทึกค่าพื้นฐานเพื่อใช้ในการคำนวณอุปกรณ์
		playerData.baseStats = {
			maxHp = playerData.stats.maxHp,
			hp = playerData.stats.hp,
			maxMp = playerData.stats.maxMp,
			mp = playerData.stats.mp,
			attack = playerData.stats.attack,
			defense = playerData.stats.defense,
			magic = playerData.stats.magic,
			magicDefense = playerData.stats.magicDefense,
			agility = playerData.stats.agility,
			level = playerData.stats.level or 1,
			money = playerData.stats.money or 100
		}

		-- Send new stats to player
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local uiRemotes = remotes:WaitForChild("UIRemotes")
		local updatePlayerStatsEvent = uiRemotes:WaitForChild("UpdatePlayerStats")

		if updatePlayerStatsEvent then
			updatePlayerStatsEvent:FireClient(player, userId, {
				hp = playerData.stats.hp,
				maxHp = playerData.stats.maxHp,
				mp = playerData.stats.mp,
				maxMp = playerData.stats.maxMp,
				attack = playerData.stats.attack,
				defense = playerData.stats.defense,
				magic = playerData.stats.magic,
				magicDefense = playerData.stats.magicDefense,
				agility = playerData.stats.agility,
				level = self.playerLevels[userId] or 1,
				class = className,
				money = playerData.stats.money or 100
			})
		end

		return true
	end

	return false
end

-- Check for level up
function ClassSystem:CheckLevelUp(userId)
	-- Calculate level: Level = sqrt(Experience / EXP_TO_LEVEL_DIVIDER) + 1
	local newLevel = math.floor(math.sqrt(self.playerExp[userId] / EXP_TO_LEVEL_DIVIDER)) + 1

	if newLevel > self.playerLevels[userId] then
		local oldLevel = self.playerLevels[userId]
		local levelDiff = newLevel - oldLevel
		self.playerLevels[userId] = newLevel

		-- Calculate stat increases
		local className = self.playerClasses[userId]
		local classData = self:GetClassData(className)
		local statIncreases = {}

		if classData and classData.BaseStats then
			-- แก้ไข: ปรับอัตราการเติบโตให้เข้ากับสถานะที่เรามี
			local growthRates = {
				MaxHP = 0.1,    -- 10% of base value per level
				MaxMP = 0.08,   -- 8% of base value per level
				ATK = 0.12,     -- 12% of base value per level
				MAGIC = 0.11    -- 11% of base value per level
			}

			-- Calculate stat increases
			for stat, baseValue in pairs(classData.BaseStats) do
				local growthRate = growthRates[stat] or 0.1
				statIncreases[stat] = math.floor(baseValue * growthRate * levelDiff)
			end
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local levelUpEvent = uiRemotes:WaitForChild("LevelUp")
			levelUpEvent:FireClient(player, newLevel, statIncreases)

			-- Apply stat increases
			self:ApplyStatIncreases(player, statIncreases)

			-- Call level up callback
			if self.onLevelUp then
				self.onLevelUp(player, newLevel, oldLevel, statIncreases)
			end
		end

		return true
	end

	return false
end

-- Apply stat increases to player
function ClassSystem:ApplyStatIncreases(player, statIncreases)
	local playerManager = _G.GameManager and _G.GameManager.playerManager
	if not playerManager then return end

	local playerData = playerManager:GetPlayerData(player)
	if not playerData then return end

	-- Map ClassData stat names to PlayerManager stat names
	local statMapping = {
		MaxHP = "maxHp",
		MaxMP = "maxMp",
		ATK = "attack",
		MAGIC = "magic"
	}

	-- Update each stat
	for classDataStat, increase in pairs(statIncreases) do
		local playerDataStat = statMapping[classDataStat]

		if playerDataStat then
			if playerDataStat == "maxHp" then
				playerData.stats.maxHp = playerData.stats.maxHp + increase
				playerData.stats.hp = playerData.stats.maxHp -- Restore full HP on level up

				-- อัปเดต baseStats ด้วย
				if playerData.baseStats then
					playerData.baseStats.maxHp = playerData.baseStats.maxHp + increase
					playerData.baseStats.hp = playerData.baseStats.maxHp
				end
			elseif playerDataStat == "maxMp" then
				playerData.stats.maxMp = playerData.stats.maxMp + increase
				playerData.stats.mp = playerData.stats.maxMp -- Restore full MP on level up

				-- อัปเดต baseStats ด้วย
				if playerData.baseStats then
					playerData.baseStats.maxMp = playerData.baseStats.maxMp + increase
					playerData.baseStats.mp = playerData.baseStats.maxMp
				end
			else
				playerData.stats[playerDataStat] = (playerData.stats[playerDataStat] or 0) + increase

				-- อัปเดต baseStats ด้วย
				if playerData.baseStats then
					playerData.baseStats[playerDataStat] = (playerData.baseStats[playerDataStat] or 0) + increase
				end
			end
		end
	end

		-- Send updated stats to client
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local uiRemotes = remotes:WaitForChild("UIRemotes")
local updatePlayerStatsEvent = uiRemotes:WaitForChild("UpdatePlayerStats")

updatePlayerStatsEvent:FireClient(player, player.UserId, {
	hp = playerData.stats.hp,
	maxHp = playerData.stats.maxHp,
	mp = playerData.stats.mp,
	maxMp = playerData.stats.maxMp,
	attack = playerData.stats.attack,
	defense = playerData.stats.defense,
	magic = playerData.stats.magic,
	magicDefense = playerData.stats.magicDefense,
	agility = playerData.stats.agility,
	level = self:GetPlayerLevel(player),
	class = self:GetPlayerClass(player),
	money = playerData.stats.money or 100
})
end

-- Get player's class
function ClassSystem:GetPlayerClass(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClasses[userId]
end

-- Get player's level
function ClassSystem:GetPlayerLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerLevels[userId] or 1
end

-- Get player's class level
function ClassSystem:GetPlayerClassLevel(player)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player
	return self.playerClassLevels[userId] or 1
end

-- Get exp required for next level
function ClassSystem:GetExpForNextLevel(level)
	return (level + 1) * (level + 1) * EXP_TO_LEVEL_DIVIDER
end

-- Get class exp required for next level
function ClassSystem:GetClassExpForNextLevel(classLevel)
	return (classLevel + 1) * (classLevel + 1) * CLASS_EXP_DIVIDER
end

-- Add experience to player
function ClassSystem:AddExperience(player, amount)
	local userId = typeof(player) == "Instance" and player:IsA("Player") and player.UserId or player

	if not self.playerExp[userId] then return false end

	-- Add experience
	self.playerExp[userId] = self.playerExp[userId] + amount
	self.playerClassExp[userId] = self.playerClassExp[userId] + math.floor(amount * 0.7)

	-- Check for level up
	local leveledUp = self:CheckLevelUp(userId)
	local classLeveledUp = self:CheckClassLevelUp(userId)

	-- Send updated exp to client
	local player = Players:GetPlayerByUserId(userId)
	if player then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local uiRemotes = remotes:WaitForChild("UIRemotes")
		local updateExpEvent = uiRemotes:FindFirstChild("UpdateExperience")

		if updateExpEvent then
			updateExpEvent:FireClient(player, {
				exp = self.playerExp[userId],
				nextLevelExp = self:GetExpForNextLevel(self.playerLevels[userId]),
				classExp = self.playerClassExp[userId],
				nextClassLevelExp = self:GetClassExpForNextLevel(self.playerClassLevels[userId])
			})
		end
	end

	return leveledUp or classLeveledUp
end

-- Check for class level up
function ClassSystem:CheckClassLevelUp(userId)
	-- Calculate class level: sqrt(ClassExp / CLASS_EXP_DIVIDER) + 1
	local newClassLevel = math.floor(math.sqrt(self.playerClassExp[userId] / CLASS_EXP_DIVIDER)) + 1

	if newClassLevel > self.playerClassLevels[userId] then
		local oldClassLevel = self.playerClassLevels[userId]
		local levelDiff = newClassLevel - oldClassLevel
		self.playerClassLevels[userId] = newClassLevel

		-- Calculate class-specific stat increases
		local className = self.playerClasses[userId]
		local classData = self:GetClassData(className)
		local statIncreases = {}

		if classData and classData.BaseStats then
			-- Growth rates for each stat
			local growthRates = {
				MaxHP = 0.12,    -- 12% of base value per level
				MaxMP = 0.10,    -- 10% of base value per level
				ATK = 0.15,      -- 15% of base value per level
				MAGIC = 0.15     -- 15% of base value per level
			}

			-- Calculate stat increases with class bonuses
			for stat, baseValue in pairs(classData.BaseStats) do
				local growthRate = growthRates[stat] or 0.12

				-- Class-specific bonuses
				local enhancement = 1.0
				if className == "Warrior" and (stat == "ATK" or stat == "MaxHP") then
					enhancement = 1.5 -- 50% bonus for Warriors' ATK, HP
				elseif className == "Knight" and (stat == "MaxHP") then
					enhancement = 1.8 -- 80% bonus for Knights' HP
				elseif className == "Paladin" and (stat == "MaxHP") then
					enhancement = 2.0 -- 100% bonus for Paladins' HP
				elseif className == "Mage" and (stat == "MAGIC" or stat == "MaxMP") then
					enhancement = 1.5 -- 50% bonus for Mages' MAGIC, MP
				elseif className == "Wizard" and (stat == "MAGIC" or stat == "MaxMP") then
					enhancement = 1.8 -- 80% bonus for Wizards' MAGIC, MP
				elseif className == "Archmage" and (stat == "MAGIC" or stat == "MaxMP") then
					enhancement = 2.0 -- 100% bonus for Archmages' MAGIC, MP
				elseif className == "Thief" and (stat == "ATK") then
					enhancement = 1.3 -- 30% bonus for Thieves' ATK
				elseif className == "Assassin" and (stat == "ATK") then
					enhancement = 1.6 -- 60% bonus for Assassins' ATK
				elseif className == "Shadow" and (stat == "ATK") then
					enhancement = 1.8 -- 80% bonus for Shadows' ATK
				end

				statIncreases[stat] = math.floor(baseValue * growthRate * enhancement * levelDiff)
			end
		end

		-- Check for class upgrade
		local nextClass = nil
		local upgradeCondition = nil

		if classData then
			nextClass = classData.NextClass
			upgradeCondition = classData.UpgradeCondition
		end

		local canUpgradeClass = false

		-- Check upgrade condition
		if upgradeCondition and nextClass then
			if upgradeCondition.Type == "Level" and newClassLevel >= upgradeCondition.Value then
				canUpgradeClass = true
			end
		end

		-- Notify client and update stats
		local player = Players:GetPlayerByUserId(userId)
		if player then
			-- Send class level up notification
			local remotes = ReplicatedStorage:WaitForChild("Remotes")
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local classLevelUpEvent = uiRemotes:WaitForChild("ClassLevelUp")

			classLevelUpEvent:FireClient(
				player, 
				newClassLevel, 
				statIncreases, 
				canUpgradeClass and nextClass or nil
			)

			-- Apply stat increases
			self:ApplyStatIncreases(player, statIncreases)

			-- Notify if class upgrade available
			if canUpgradeClass and nextClass then
				local classUpgradeEvent = uiRemotes:FindFirstChild("ClassUpgradeAvailable")
				if classUpgradeEvent then
					local nextClassData = self:GetClassData(nextClass)
					classUpgradeEvent:FireClient(player, nextClass, nextClassData)
				end
			end

			-- Call class level up callback
			if self.onClassLevelUp then
				self.onClassLevelUp(player, newClassLevel, oldClassLevel, statIncreases, canUpgradeClass and nextClass or nil)
			end
		end

		return true
	end

	return false
end

-- Reset all player class data (for game restart)
function ClassSystem:ResetAllPlayerClasses()
	self.playerClasses = {}
	self.playerLevels = {}
	self.playerClassLevels = {}
	self.playerExp = {}
	self.playerClassExp = {}
end

return ClassSystem
