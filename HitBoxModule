-- Advanced Server-Authoritative Hitbox Module (v2)
-- ปรับปรุง: รวม LoS Check, I-Frames, Debounce, MaxHits เข้าใน Module

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService") -- Get Service ครั้งเดียว
local ServerScriptService = game:GetService("ServerScriptService") -- ตัวอย่าง Path

local HitboxService = {}
HitboxService.__index = HitboxService
-- ใช้ Weak Table เพื่อให้ Hitbox ที่ถูก Destroyed ถูก Garbage Collect อัตโนมัติ
HitboxService.ActiveHitboxes = setmetatable({}, {__mode = "k"}) -- Store active server-side hitboxes

local DEFAULT_DEBOUNCE = 0.1
local DEFAULT_IFRAME_DURATION = 0.5
local IFRAME_ATTRIBUTE_NAME = "InvincibleUntil"
local MAX_DISTANCE_CHECK = 150 -- ระยะห่างสูงสุดที่ยอมรับได้สำหรับการโจมตี (ปรับตามเกม)
local LOS_CHECK_ENABLED = true -- เปิด/ปิด การตรวจสอบ Line of Sight (แนะนำให้เปิด)

-- // Private Helper Functions

local function GetHumanoid(part: BasePart): Humanoid?
	local character = part:FindFirstAncestorOfClass("Model")
	if character then
		return character:FindFirstChildOfClass("Humanoid")
	end
	return nil
end

--[[
	IsValidTarget (Server-Side Validation - Stage 1: Initial Filter)
	ตรวจสอบ Humanoid, Health, Server-Side I-Frames, Server-Side Debounce
	* ลบการเช็ค MaxHits ออกจากที่นี่ จะไปเช็คหลัง LoS *
]]
local function IsValidTarget(hitPart: BasePart, hitboxInstance: table): (boolean, Humanoid?, Model?)
	local humanoid = GetHumanoid(hitPart)
	if not humanoid or humanoid.Health <= 0 then
		return false, nil, nil
	end

	local targetCharacter = humanoid.Parent
	local attackerCharacter = hitboxInstance.AttackerCharacter

	-- ป้องกันการโจมตีตัวเอง (ถ้าไม่ได้ตั้งใจให้ทำได้)
	if attackerCharacter and targetCharacter == attackerCharacter then
		-- ตรวจสอบ CastParams อีกครั้ง (เผื่อกรณีที่ Filter ไม่ทำงานตามคาด)
		if table.find(hitboxInstance.CastParams.FilterDescendantsInstances, targetCharacter) then
			return false, nil, nil
		end
		-- ถ้าไม่ได้อยู่ใน Filter แต่เป็นตัวเดียวกัน ก็ไม่ควรผ่าน (ยกเว้นเกมดีไซน์อนุญาต)
		-- return false, nil, nil
	end

	-- ตรวจสอบ I-frames (Server time)
	if hitboxInstance.IFramesEnabled then
		local invincibleUntil = targetCharacter:GetAttribute(IFRAME_ATTRIBUTE_NAME)
		if invincibleUntil and typeof(invincibleUntil) == "number" and tick() < invincibleUntil then
			-- print(targetCharacter.Name, "is invincible (I-Frame)")
			return false, nil, nil -- ยังอยู่ในช่วง I-frames (Server)
		end
	end

	-- ตรวจสอบ Debounce (Server time, ต่อ Hitbox Instance นี้)
	local lastHitTime = hitboxInstance.HitTargetsDebounce[humanoid]
	if lastHitTime and (tick() - lastHitTime) < hitboxInstance.Debounce then
		-- print(targetCharacter.Name, "is invincible (Debounce)")
		return false, nil, nil -- โดน Debounce (Server)
	end

	-- ผ่านการกรองเบื้องต้น
	return true, humanoid, targetCharacter
end

--[[
	ApplyIFrames (Server-Side)
	ตั้งค่า Attribute บน Character เป้าหมาย โดยใช้ Server time (tick())
]]
local function ApplyIFrames(humanoid: Humanoid, duration: number)
	local character = humanoid.Parent
	if character then
		character:SetAttribute(IFRAME_ATTRIBUTE_NAME, tick() + duration)
		-- print("Applied I-Frames to", character.Name, "until", character:GetAttribute(IFRAME_ATTRIBUTE_NAME))
	end
end

--[[
	PerformLineOfSightCheck (Server-Side Validation - Stage 2)
	ตรวจสอบว่ามีสิ่งกีดขวางระหว่างผู้โจมตีกับเป้าหมายหรือไม่
]]
local function PerformLineOfSightCheck(attackerRoot: BasePart, targetRoot: BasePart, filterInstances: {Instance}): boolean
	if not attackerRoot or not targetRoot then return false end -- ไม่มี Root Part

	local origin = attackerRoot.Position
	local direction = (targetRoot.Position - origin)
	local distance = direction.Magnitude

	if distance < 0.1 then return true end -- อยู่ใกล้กันมาก ถือว่าเห็น

	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	-- Filter ผู้โจมตีและเป้าหมาย เพื่อไม่ให้ Raycast โดนตัวเอง
	raycastParams.FilterDescendantsInstances = filterInstances
	raycastParams.IgnoreWater = true

	local result = workspace:Raycast(origin, direction.Unit * distance, raycastParams)

	if result then
		-- มีบางอย่างขวางอยู่ ตรวจสอบว่าเป็นส่วนหนึ่งของเป้าหมายหรือไม่ (เผื่อโดนแขนขาตัวเอง)
		if result.Instance:IsDescendantOf(targetRoot.Parent) then
			-- print("LoS clear (hit part of target)")
			return true -- โดนส่วนอื่นของเป้าหมายเอง ไม่นับว่า Blocked
		else
			-- print("LoS blocked by:", result.Instance:GetFullName(), "between", attackerRoot.Parent.Name, "and", targetRoot.Parent.Name)
			return false -- มีสิ่งกีดขวางอื่น
		end
	else
		-- ไม่มีอะไรขวาง
		-- print("LoS clear between", attackerRoot.Parent.Name, "and", targetRoot.Parent.Name)
		return true
	end
end


--[[ Visualizer Functions (เหมือนเดิม แต่ปรับปรุงเล็กน้อย) ]]

local function CreateVisualizer(hitboxInstance: table)
	local visualizerFolder = game:GetService("ReplicatedStorage"):FindFirstChild("HitboxVisualizers")
	if not visualizerFolder then
		visualizerFolder = Instance.new("Folder")
		visualizerFolder.Name = "HitboxVisualizers"
		visualizerFolder.Parent = game:GetService("ReplicatedStorage")
	end

	local visualizer = Instance.new("Part")
	visualizer.Name = "HitboxVisualizer_" .. hitboxInstance.UniqueId
	visualizer.Transparency = 0.7
	visualizer.BrickColor = BrickColor.Red()
	visualizer.CanCollide = false
	visualizer.CanQuery = false
	visualizer.CanTouch = false
	visualizer.Anchored = true
	visualizer.Material = Enum.Material.Neon
	visualizer.Parent = visualizerFolder -- เก็บใน ReplicatedStorage

	if hitboxInstance.Shape == "Box" then
		visualizer.Shape = Enum.PartType.Block
		visualizer.Size = hitboxInstance.Size
	elseif hitboxInstance.Shape == "Sphere" then
		visualizer.Shape = Enum.PartType.Ball
		local diameter = hitboxInstance.Size * 2
		visualizer.Size = Vector3.new(diameter, diameter, diameter)
	end
	-- ตั้งค่า Network Ownership เป็น Server เพื่อป้องกัน Client เปลี่ยนตำแหน่ง (ไม่จำเป็นมากนักเพราะอยู่ใน RS)
	-- visualizer:SetNetworkOwner(nil)

	hitboxInstance.Visualizer = visualizer
	-- ส่ง Event บอก Client ให้สร้าง (ถ้าต้องการ)
	-- game.ReplicatedStorage.HitboxVisualizeEvent:FireAllClients("Create", hitboxInstance.UniqueId, hitboxInstance:GetCFrame(), hitboxInstance.Shape, hitboxInstance.Size)
end

local function UpdateVisualizer(hitboxInstance: table)
	if hitboxInstance.Visualizer and hitboxInstance.Visualizer.Parent then
		local cframe = hitboxInstance:GetCFrame()
		-- ใช้ TweenService เพื่อให้การเคลื่อนที่ของ Visualizer ใน ReplicatedStorage ดู Smooth ขึ้น (ถ้า Client ดึงไปใช้)
		-- หรือจะ Update ตรงๆ ก็ได้ถ้า Client สร้าง Visualizer ของตัวเองตาม Event
		hitboxInstance.Visualizer.CFrame = cframe
		-- ส่ง Event บอก Client ให้อัปเดต
		-- game.ReplicatedStorage.HitboxVisualizeEvent:FireAllClients("Update", hitboxInstance.UniqueId, cframe)
	elseif hitboxInstance.Visualizer and not hitboxInstance.Visualizer.Parent then
		-- Visualizer ถูกลบไปแล้ว (อาจจะจาก Code อื่น)
		hitboxInstance.Visualizer = nil
	end
end

local function CleanupVisualizer(hitboxInstance: table)
	if hitboxInstance.Visualizer then
		-- ส่ง Event บอก Client ให้ลบ
		-- game.ReplicatedStorage.HitboxVisualizeEvent:FireAllClients("Destroy", hitboxInstance.UniqueId)
		hitboxInstance.Visualizer:Destroy()
		hitboxInstance.Visualizer = nil
	end
end


--[[
	ProcessConfirmedHit (Internal Helper)
	จัดการหลังจาก Hit ผ่านการตรวจสอบทั้งหมด (LoS included)
]]
local function ProcessConfirmedHit(hitboxInstance: table, hitPart: BasePart, humanoid: Humanoid)
	local currentTime = tick()

	-- 1. Apply I-Frames (Server-Side)
	if hitboxInstance.IFramesEnabled then
		ApplyIFrames(humanoid, hitboxInstance.IFrameDuration)
	end

	-- 2. Update Debounce Table (Server-Side)
	hitboxInstance.HitTargetsDebounce[humanoid] = currentTime

	-- 3. Update Confirmed Hits List & Counter (Server-Side)
	table.insert(hitboxInstance.ConfirmedHitList, humanoid)
	hitboxInstance.ConfirmedHits = hitboxInstance.ConfirmedHits + 1
	-- print("Confirmed hit on", humanoid.Parent.Name, "- Total hits:", hitboxInstance.ConfirmedHits)


	-- 4. Fire OnHit Event (Server-Side - Signifies a CONFIRMED hit)
	-- ใช้ task.spawn เพื่อไม่ให้ Listener ที่ใช้เวลานาน Block การทำงานหลัก
	task.spawn(function()
		-- ส่ง Part ที่โดน, Humanoid, และ Damage ที่กำหนดไว้
		hitboxInstance.OnHit:Fire(hitPart, humanoid, hitboxInstance.Damage)
	end)

	-- 5. Check Max Hits (Server-Side)
	if hitboxInstance.MaxHits and hitboxInstance.ConfirmedHits >= hitboxInstance.MaxHits then
		-- print("Max hits reached for hitbox:", hitboxInstance.UniqueId)
		hitboxInstance:Stop() -- หยุด Hitbox ทันทีเมื่อถึง MaxHits
	end
end

--[[
	PerformCast (Server-Side Detection - Revised Logic)
	ใช้ OverlapParams, กรองเบื้องต้น, ตรวจสอบ LoS, แล้วจึงยืนยัน Hit
]]
local function PerformCast(hitboxInstance: table)
	-- ตรวจสอบว่า Hitbox ยัง Active อยู่หรือไม่ ก่อนเริ่ม Cast
	if not hitboxInstance.IsActive then return end

	local hitboxCFrame = hitboxInstance:GetCFrame()
	local results

	-- ตรวจสอบความสมเหตุสมผลของตำแหน่ง Hitbox (ป้องกันการ Exploit ตำแหน่ง)
	local attackerRoot = hitboxInstance.AttackerCharacter and hitboxInstance.AttackerCharacter:FindFirstChild("HumanoidRootPart")
	if attackerRoot and (hitboxCFrame.Position - attackerRoot.Position).Magnitude > MAX_DISTANCE_CHECK then
		warn("Hitbox position ("..tostring(hitboxCFrame.Position)..") is too far from attacker ("..tostring(attackerRoot.Position).."). Stopping hitbox.", hitboxInstance.AttackerCharacter.Name)
		hitboxInstance:Stop() -- หยุด Hitbox ที่น่าสงสัย
		return
	end

	-- Perform the appropriate spatial query
	if hitboxInstance.Shape == "Box" then
		results = workspace:GetPartBoundsInBox(
			hitboxCFrame,
			hitboxInstance.Size,
			hitboxInstance.CastParams
		)
	elseif hitboxInstance.Shape == "Sphere" then
		results = workspace:GetPartBoundsInRadius(
			hitboxCFrame.Position,
			hitboxInstance.Size, -- Radius
			hitboxInstance.CastParams
		)
	else
		warn("Invalid Hitbox Shape for Casting:", hitboxInstance.Shape)
		return
	end

	-- ใช้ Dictionary เพื่อป้องกันการประมวลผล Humanoid เดียวกันซ้ำซ้อนใน Cast เดียว
	local processedHumanoidsInCast = {}

	for _, hitPart in ipairs(results) do
		-- Stage 1: Initial Filtering (Health, Self-Hit, I-Frames, Debounce)
		local isValid, humanoid, targetCharacter = IsValidTarget(hitPart, hitboxInstance)

		if isValid and humanoid and targetCharacter and not processedHumanoidsInCast[humanoid] then
			processedHumanoidsInCast[humanoid] = true -- Mark as processed for this cast cycle

			-- Stage 2: Line of Sight (LoS) Check (ถ้าเปิดใช้งาน)
			local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
			local losPassed = true -- Assume true if LoS check is disabled or no roots found

			if LOS_CHECK_ENABLED and attackerRoot and targetRoot then
				-- สร้าง Filter List สำหรับ LoS Raycast: กรองผู้โจมตีและเป้าหมาย
				local losFilter = {hitboxInstance.AttackerCharacter, targetCharacter}
				-- อาจจะเพิ่ม Visualizer เข้าไปด้วย ถ้ามันอยู่ใน Workspace (แต่ตอนนี้อยู่ใน RS)
				-- if hitboxInstance.Visualizer and hitboxInstance.Visualizer.Parent == workspace then
				--    table.insert(losFilter, hitboxInstance.Visualizer)
				-- end
				losPassed = PerformLineOfSightCheck(attackerRoot, targetRoot, losFilter)
			elseif LOS_CHECK_ENABLED and (not attackerRoot or not targetRoot) then
				warn("Cannot perform LoS check: Attacker or Target HumanoidRootPart not found.")
				losPassed = false -- ถ้าหา Root ไม่เจอ ถือว่า LoS ไม่ผ่านเพื่อความปลอดภัย
			end

			-- Stage 3: Process Confirmed Hit (ถ้า LoS ผ่าน)
			if losPassed then
				-- *** ยืนยัน Hit และดำเนินการต่อ ***
				ProcessConfirmedHit(hitboxInstance, hitPart, humanoid)

				-- ตรวจสอบอีกครั้งว่า MaxHits ทำให้ Hitbox หยุดทำงานไปหรือยัง
				if not hitboxInstance.IsActive then
					break -- หยุดวน Loop ของ Cast นี้ ถ้า Hitbox ถูก Stop ไปแล้ว
				end
			end
		end
	end
end


-- // Hitbox Class Methods

function HitboxService.new(params: table)
	assert(RunService:IsServer(), "HitboxService.new should only be called from the server!")

	local self = setmetatable({}, HitboxService)

	-- Validate required parameters (เหมือนเดิม)
	assert(params.Shape and (params.Shape == "Box" or params.Shape == "Sphere"), "Hitbox requires a valid Shape ('Box' or 'Sphere')")
	assert(params.Size and (typeof(params.Size) == "Vector3" or typeof(params.Size) == "number"), "Hitbox requires a valid Size (Vector3 for Box, number for Sphere radius)")
	if params.Shape == "Box" then assert(typeof(params.Size) == "Vector3", "Box shape requires a Vector3 Size") end
	if params.Shape == "Sphere" then assert(typeof(params.Size) == "number", "Sphere shape requires a number Size (radius)") end
	assert(params.Attachment or params.Part, "Hitbox requires either an Attachment or a Part to attach to")
	if params.Attachment then assert(params.Attachment:IsA("Attachment"), "Attachment parameter must be an Attachment instance") end
	if params.Part then assert(params.Part:IsA("BasePart"), "Part parameter must be a BasePart instance") end
	assert(params.AttackerCharacter and params.AttackerCharacter:IsA("Model") and params.AttackerCharacter:FindFirstChild("Humanoid"), "Hitbox requires a valid AttackerCharacter (Model with Humanoid)")

	-- Assign properties
	self.UniqueId = HttpService:GenerateGUID(false)
	self.Shape = params.Shape
	self.Size = params.Size
	self.Attachment = params.Attachment
	self.Part = params.Part
	self.AttackerCharacter = params.AttackerCharacter
	self.Offset = params.Offset or CFrame.new()
	self.CastParams = params.CastParams or Instance.new("OverlapParams")
	self.Visualize = params.Visualize or false
	self.Duration = params.Duration -- nil means infinite until Stop()
	self.Debounce = params.Debounce or DEFAULT_DEBOUNCE
	self.MaxHits = params.MaxHits -- nil means infinite hits
	self.IFramesEnabled = params.IFramesEnabled == nil and true or params.IFramesEnabled
	self.IFrameDuration = params.IFrameDuration or DEFAULT_IFRAME_DURATION
	self.Damage = params.Damage or 10 -- Default damage if not specified

	-- Internal state (Server-Side)
	self.IsActive = false
	self.StartTime = 0
	self.HitTargetsDebounce = {} -- [Humanoid] = lastHitTime (for Debounce)
	self.ConfirmedHitList = {} -- List of humanoids confirmed hit (for reference/debugging)
	self.ConfirmedHits = 0 -- Counter for MaxHits
	self.Visualizer = nil

	-- Events (Server-Side)
	self.OnHit = Instance.new("BindableEvent") -- Fires with CONFIRMED hits (passed LoS, Debounce, I-Frames)

	-- Ensure CastParams filter includes the attacker character
	-- (Important: Do this *after* potentially creating default OverlapParams)
	if self.CastParams.FilterType == Enum.RaycastFilterType.Blacklist then
		local alreadyFiltered = false
		for _, instance in ipairs(self.CastParams.FilterDescendantsInstances) do
			if instance == self.AttackerCharacter then
				alreadyFiltered = true
				break
			end
		end
		if not alreadyFiltered then
			-- สร้าง Table ใหม่เพื่อหลีกเลี่ยงการแก้ไข Table ที่อาจใช้ร่วมกัน
			local newFilter = table.clone(self.CastParams.FilterDescendantsInstances)
			table.insert(newFilter, self.AttackerCharacter)
			self.CastParams.FilterDescendantsInstances = newFilter
			-- print("Added attacker to blacklist filter:", self.AttackerCharacter.Name)
		end
	elseif self.CastParams.FilterType == Enum.RaycastFilterType.Whitelist then
		-- Whitelist mode: Ensure the attacker is NOT in the whitelist unless intended
		local newFilter = {}
		local attackerFound = false
		for _, instance in ipairs(self.CastParams.FilterDescendantsInstances) do
			if instance ~= self.AttackerCharacter then
				table.insert(newFilter, instance)
			else
				attackerFound = true -- Found the attacker in the whitelist
			end
		end
		-- Only update if the attacker was actually removed
		if attackerFound then
			self.CastParams.FilterDescendantsInstances = newFilter
			-- print("Removed attacker from whitelist filter:", self.AttackerCharacter.Name)
		end
	end
	-- print("Final Filter Instances:", self.CastParams.FilterDescendantsInstances)


	-- Create visualizer representation if requested
	if self.Visualize then
		CreateVisualizer(self)
	end

	return self
end

function HitboxService:GetCFrame(): CFrame
	if self.Attachment and self.Attachment.Parent then
		return self.Attachment.WorldCFrame * self.Offset
	elseif self.Part and self.Part.Parent then
		return self.Part.CFrame * self.Offset
	else
		-- Anchor หายไป -> หยุด Hitbox เพื่อป้องกัน Error และพฤติกรรมไม่คาดคิด
		if self.IsActive then
			warn("Hitbox anchor (Part/Attachment) not found for active hitbox. Stopping hitbox.", self.UniqueId)
			self:Stop()
		end
		-- Return a default CFrame or the last known good CFrame if available
		return CFrame.new(0, -10000, 0) -- ส่งไปไกลๆ เพื่อไม่ให้เกิด Hit โดยบังเอิญ
	end
end

function HitboxService:Start()
	if not RunService:IsServer() then
		warn("HitboxService:Start() can only be called from the server.")
		return
	end
	if self.IsActive then return end

	-- ตรวจสอบว่า Anchor ยังอยู่ดีไหมก่อนเริ่ม
	if (self.Attachment and not self.Attachment.Parent) or (self.Part and not self.Part.Parent) then
		warn("Cannot start hitbox: Anchor (Part/Attachment) not found.", self.UniqueId)
		self:Destroy() -- ทำลายไปเลยถ้า Anchor หายไปก่อนเริ่ม
		return
	end

	self.IsActive = true
	self.StartTime = tick()
	self.HitTargetsDebounce = {} -- Reset debounce list
	self.ConfirmedHitList = {} -- Reset confirmed hit list
	self.ConfirmedHits = 0 -- Reset counter

	-- Add to the global server-side update loop
	HitboxService.ActiveHitboxes[self] = true
	-- print("Hitbox started:", self.UniqueId)


	-- ถ้า Visualize, อัปเดตตำแหน่งเริ่มต้นและส่ง Event (ถ้าใช้ Event)
	if self.Visualize then
		UpdateVisualizer(self) -- Update position once at start
		-- game.ReplicatedStorage.HitboxVisualizeEvent:FireAllClients("Create", self.UniqueId, self:GetCFrame(), self.Shape, self.Size)
	end
end

function HitboxService:Stop()
	if not RunService:IsServer() then return end -- ควรมี Guard Clause เสมอ
	if not self.IsActive then return end

	self.IsActive = false
	-- Remove from the global update loop (weak table handles removal eventually)
	HitboxService.ActiveHitboxes[self] = nil -- Explicit removal is still good practice
	-- print("Hitbox stopped:", self.UniqueId)

	-- ถ้า Visualize, ส่ง Event หยุดให้ Client และ Cleanup ทันที
	if self.Visualize then
		CleanupVisualizer(self) -- Cleanup server-side visualizer part
		-- game.ReplicatedStorage.HitboxVisualizeEvent:FireAllClients("Destroy", self.UniqueId)
	end
end

function HitboxService:Destroy()
	if not RunService:IsServer() then return end

	self:Stop() -- Ensure it's stopped first

	-- Clean up events
	if self.OnHit then
		self.OnHit:Destroy()
		self.OnHit = nil -- Clear reference
	end

	-- Clean up visualizer just in case Stop() didn't catch it
	CleanupVisualizer(self)

	-- Explicitly remove from active list if somehow still there
	HitboxService.ActiveHitboxes[self] = nil

	-- Clear references (weak table helps, but explicit nil is clearer for other fields)
	for k in pairs(self) do
		self[k] = nil
	end
	setmetatable(self, nil) -- Remove metatable
	-- print("Hitbox destroyed")
end

-- // Global Server-Side Update Loop

RunService.Heartbeat:Connect(function(deltaTime)
	-- Loop นี้ทำงานบน Server เท่านั้น
	if not RunService:IsServer() then return end

	local currentTime = tick()

	-- ใช้ pairs บน weak table ได้ปกติ, การวนซ้ำจะไม่เก็บ Reference ถาวร
	for hitboxInstance, _ in pairs(HitboxService.ActiveHitboxes) do
		-- Double-check if the instance is still valid and active
		-- (It might have been destroyed or stopped during the loop iteration)
		if not hitboxInstance or not hitboxInstance.IsActive then
			continue
		end

		-- ตรวจสอบว่า Anchor (Part/Attachment) ยังอยู่หรือไม่
		if (hitboxInstance.Attachment and not hitboxInstance.Attachment.Parent) or (hitboxInstance.Part and not hitboxInstance.Part.Parent) then
			if hitboxInstance.IsActive then -- เช็คอีกครั้งก่อน Destroy
				warn("Hitbox anchor lost during update loop. Destroying hitbox.", hitboxInstance.UniqueId)
				hitboxInstance:Destroy() -- ทำลาย Hitbox ที่ไม่มี Anchor
			end
			continue -- ไปยัง Hitbox ถัดไป
		end

		-- Update CFrame for visualizer (if enabled)
		if hitboxInstance.Visualize then
			UpdateVisualizer(hitboxInstance)
		end

		-- Check duration (if set)
		if hitboxInstance.Duration and (currentTime - hitboxInstance.StartTime) >= hitboxInstance.Duration then
			-- print("Hitbox duration ended:", hitboxInstance.UniqueId)
			hitboxInstance:Stop()
			continue -- หยุดและไป Hitbox ถัดไป
		end

		-- Perform detection (Shapecasting, LoS, Hit Confirmation)
		-- *** Function นี้จะจัดการเรื่อง Hit Confirmation และ Stop ถ้าถึง MaxHits ด้วย ***
		PerformCast(hitboxInstance)

	end
end)


return HitboxService
