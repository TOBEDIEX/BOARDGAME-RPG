-- Fixed ClassService.server.lua
-- จัดการระบบคลาสและการเลือกคลาส server-side
-- Version: 3.0.0 (Fully Fixed)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Debug mode for detailed logging
local DEBUG_MODE = false

-- Helper function for logging
local function debugLog(message)
	if DEBUG_MODE then
		print("[ClassService] " .. message)
	end
end

-- Get modules and remote events
local Modules = ServerStorage:WaitForChild("Modules")
local ClassSystem = require(Modules:WaitForChild("ClassSystem"))
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local ClassData = require(SharedModules:WaitForChild("ClassData"))

-- Get GameManager from global
local function getGameManager()
	local startTime = tick()
	local attempts = 0
	local maxAttempts = 20

	while not _G.GameManager and attempts < maxAttempts do
		wait(0.5)
		attempts = attempts + 1
		debugLog("Waiting for GameManager... Attempt " .. attempts)
	end

	if not _G.GameManager then
		warn("[ClassService] Failed to get GameManager after " .. maxAttempts .. " attempts.")
	else
		debugLog("GameManager found successfully.")
	end

	return _G.GameManager
end

-- Initialize player selection tracking
local playerSelections = {}
local playerReadyStatus = {}
local selectionTimer = nil
local DEFAULT_SELECTION_TIME = 30

-- Initialize remote events
local function initializeRemoteEvents()
	debugLog("Initializing remote events...")

	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes")

	-- Create required remotes if they don't exist
	local function ensureRemoteEvent(parent, name)
		local event = parent:FindFirstChild(name)
		if not event then
			event = Instance.new("RemoteEvent")
			event.Name = name
			event.Parent = parent
			debugLog("Created RemoteEvent: " .. name)
		end
		return event
	end

	-- UI Remotes
	local classAssignedEvent = ensureRemoteEvent(uiRemotes, "ClassAssigned")
	local playerSelectedClassEvent = ensureRemoteEvent(uiRemotes, "PlayerSelectedClass")
	local updateClassSelectionEvent = ensureRemoteEvent(uiRemotes, "UpdateClassSelection")
	local updateClassSelectionTimerEvent = ensureRemoteEvent(uiRemotes, "UpdateClassSelectionTimer")
	local notifyRandomClassEvent = ensureRemoteEvent(uiRemotes, "NotifyRandomClass")
	local showMainGameUIEvent = ensureRemoteEvent(uiRemotes, "ShowMainGameUI")
	local levelUpEvent = ensureRemoteEvent(uiRemotes, "LevelUp")
	local classLevelUpEvent = ensureRemoteEvent(uiRemotes, "ClassLevelUp")
	local updatePlayerStatsEvent = ensureRemoteEvent(uiRemotes, "UpdatePlayerStats")
	local showClassSelectionEvent = ensureRemoteEvent(uiRemotes, "ShowClassSelection")

	debugLog("All remote events initialized.")

	return {
		classAssigned = classAssignedEvent,
		playerSelectedClass = playerSelectedClassEvent,
		updateClassSelection = updateClassSelectionEvent,
		updateClassSelectionTimer = updateClassSelectionTimerEvent,
		notifyRandomClass = notifyRandomClassEvent,
		showMainGameUI = showMainGameUIEvent,
		levelUp = levelUpEvent,
		classLevelUp = classLevelUpEvent,
		updatePlayerStats = updatePlayerStatsEvent,
		showClassSelection = showClassSelectionEvent
	}
end

-- Check if all players are loaded (ready for class selection)
local function areAllPlayersReady()
	local allPlayers = Players:GetPlayers()
	local readyCount = 0

	for _, player in ipairs(allPlayers) do
		if playerReadyStatus[player.UserId] then
			readyCount = readyCount + 1
		end
	end

	return readyCount == #allPlayers and #allPlayers > 0
end

-- Monitor player ready state from GameManager
local function monitorPlayerReadyState(gameManager)
	if not gameManager then return end

	debugLog("Starting player ready state monitoring...")

	-- Connect to game events
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes")
	local assetsLoadedEvent = gameRemotes:WaitForChild("AssetsLoaded")

	-- Track loading state
	assetsLoadedEvent.OnServerEvent:Connect(function(player)
		playerReadyStatus[player.UserId] = true
		debugLog("Player ready: " .. player.Name)

		-- Check if all players are ready to proceed to class selection
		if areAllPlayersReady() then
			-- Wait a moment to ensure everyone's loading screen is complete
			wait(1)
			debugLog("All players ready, transitioning to class selection...")

			-- Show class selection UI to all players
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local showClassSelectionEvent = uiRemotes:WaitForChild("ShowClassSelection")
			showClassSelectionEvent:FireAllClients()

			-- Start selection timer
			startSelectionTimer(initializeRemoteEvents())
		end
	end)

	-- Monitor player joins
	Players.PlayerAdded:Connect(function(player)
		playerReadyStatus[player.UserId] = false
		debugLog("Player joined: " .. player.Name)
	end)

	-- Monitor player leaves
	Players.PlayerRemoving:Connect(function(player)
		playerReadyStatus[player.UserId] = nil
		playerSelections[player.UserId] = nil
		debugLog("Player left: " .. player.Name)
	end)

	debugLog("Player ready state monitoring initialized.")
end

-- Finish class selection and transition to game
local function finishClassSelection(remotes)
	debugLog("Finishing class selection...")

	local gameManager = getGameManager()
	if not gameManager then
		warn("[ClassService] GameManager not found, cannot finish class selection")
		return
	end

	-- Assign classes to all players
	for userId, className in pairs(playerSelections) do
		local player = nil

		-- Find player from UserId
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.UserId == userId then
				player = plr
				break
			end
		end

		if player then
			-- Get class data
			local classInfo = ClassData:GetClassInfo(className)
			debugLog("Assigning class " .. className .. " to player " .. player.Name)

			-- Assign class via ClassSystem
			if gameManager.classSystem then
				gameManager.classSystem:AssignClassToPlayer(player, className)
			end

			-- Assign class via PlayerManager
			if gameManager.playerManager then
				gameManager.playerManager:SetPlayerClass(player, className)

				-- Get player data for UI update
				local playerData = gameManager.playerManager:GetPlayerData(player)
				if playerData then
					-- Update player's UI with stats
					local updatePlayerStatsEvent = remotes.updatePlayerStats

					updatePlayerStatsEvent:FireClient(player, player.UserId, {
						hp = playerData.stats.hp,
						maxHp = playerData.stats.maxHp,
						mp = playerData.stats.mp,
						maxMp = playerData.stats.maxMp,
						level = playerData.stats.level or 1,
						class = className,
						money = playerData.stats.money
					})
				end
			end
		end
	end

	-- Show main game UI to all players after a brief delay
	debugLog("Waiting 1 second before transitioning to main game...")
	wait(1)
	remotes.showMainGameUI:FireAllClients()
	debugLog("All players transitioned to main game UI")

	-- Clean up
	for _, player in pairs(Players:GetPlayers()) do
		playerReadyStatus[player.UserId] = nil
	end
	playerSelections = {}

	-- If timer is running, cancel it
	if selectionTimer then
		selectionTimer:Disconnect()
		selectionTimer = nil
	end

	-- Start game
	if gameManager.turnSystem then
		debugLog("Starting turn system...")
		gameManager.turnSystem:StartTurnSystem()
	end
end

-- Start class selection timer
local function startSelectionTimer(remotes)
	debugLog("Starting selection timer: " .. DEFAULT_SELECTION_TIME .. " seconds")

	local timeLeft = DEFAULT_SELECTION_TIME

	-- Cancel existing timer if running
	if selectionTimer then
		selectionTimer:Disconnect()
		selectionTimer = nil
		debugLog("Cancelled existing timer")
	end

	-- Immediately send timer value to clients
	remotes.updateClassSelectionTimer:FireAllClients(timeLeft)

	-- Create new timer
	local lastUpdateTime = tick()

	selectionTimer = RunService.Heartbeat:Connect(function()
		local currentTime = tick()
		local elapsed = currentTime - lastUpdateTime

		-- Update timer approximately every second
		if elapsed >= 1 then
			lastUpdateTime = currentTime
			timeLeft = timeLeft - 1

			-- Send timer update to clients
			remotes.updateClassSelectionTimer:FireAllClients(timeLeft)
			debugLog("Timer update: " .. timeLeft .. " seconds")

			-- When time is up, assign random classes to players without selection
			if timeLeft <= 0 then
				selectionTimer:Disconnect()
				selectionTimer = nil
				debugLog("Selection time expired")

				for _, player in pairs(Players:GetPlayers()) do
					if not playerSelections[player.UserId] then
						local randomClass = ClassSystem:GetRandomClass()
						playerSelections[player.UserId] = randomClass
						debugLog("Random class assigned to " .. player.Name .. ": " .. randomClass)

						-- Notify player of random selection
						remotes.notifyRandomClass:FireClient(player, randomClass)

						-- Update all clients
						remotes.updateClassSelection:FireAllClients(player.UserId, randomClass)
					end
				end

				-- Delay to let animations finish
				wait(2)

				-- Continue game setup
				finishClassSelection(remotes)
			end
		end
	end)
end

-- Handle player selection
local function handlePlayerSelection(player, className, remotes)
	if not player or not className then 
		debugLog("Invalid player selection parameters")
		return 
	end

	-- Validate class name
	if className ~= "Warrior" and className ~= "Mage" and className ~= "Thief" then
		debugLog("Invalid class selected by " .. player.Name .. ": " .. tostring(className))
		return
	end

	-- Store selection
	playerSelections[player.UserId] = className
	debugLog(player.Name .. " selected class: " .. className)

	-- Broadcast to all clients
	remotes.updateClassSelection:FireAllClients(player.UserId, className)

	-- Check if all players have selected
	local allSelected = true
	for _, plr in pairs(Players:GetPlayers()) do
		if not playerSelections[plr.UserId] then
			allSelected = false
			break
		end
	end

	-- If all selected, continue game setup
	if allSelected and #Players:GetPlayers() > 0 then
		if selectionTimer then
			selectionTimer:Disconnect()
			selectionTimer = nil
			debugLog("Timer cancelled - all players made selections")
		end

		debugLog("All players selected classes, transitioning to game...")
		wait(2) -- Give time for animations
		finishClassSelection(remotes)
	end
end

-- Reset player selections
local function resetPlayerSelections()
	playerSelections = {}
	playerReadyStatus = {}

	if selectionTimer then
		selectionTimer:Disconnect()
		selectionTimer = nil
	end

	debugLog("Player selections and ready status reset")
end

-- Initialize service
local function initializeClassService()
	debugLog("Initializing ClassService...")

	-- Wait for GameManager
	local gameManager = getGameManager()
	if not gameManager then
		debugLog("GameManager not found, initializing own ClassSystem")
		gameManager = {
			classSystem = ClassSystem.new()
		}
		_G.GameManager = gameManager
	end

	-- Create ClassSystem if needed
	if not gameManager.classSystem then
		debugLog("Creating new ClassSystem")
		gameManager.classSystem = ClassSystem.new()
	end

	-- Initialize remote events
	local remotes = initializeRemoteEvents()
	debugLog("Remote events initialized")

	-- Set up class assignment handler
	local function handleClassAssignment(player, className, classData)
		-- Could update character appearance based on class
		debugLog("Handling class assignment for " .. player.Name .. ": " .. className)

		-- Update UI
		remotes.classAssigned:FireClient(player, className, classData)
	end

	-- Connect to player selected class event
	remotes.playerSelectedClass.OnServerEvent:Connect(function(player, className)
		handlePlayerSelection(player, className, remotes)
	end)

	-- Connect to class system events
	gameManager.classSystem.onClassAssigned = handleClassAssignment

	-- Set up player ready monitoring
	monitorPlayerReadyState(gameManager)

	-- Handle player joining mid-game
	Players.PlayerAdded:Connect(function(player)
		debugLog("Player joined: " .. player.Name)
		playerReadyStatus[player.UserId] = false

		-- If we're in the middle of class selection, update timers
		if selectionTimer then
			wait(1) -- Give time for client to load
			remotes.updateClassSelectionTimer:FireClient(player, DEFAULT_SELECTION_TIME)
		end
	end)

	-- Add public methods to GameManager
	gameManager.resetPlayerSelections = resetPlayerSelections
	gameManager.startClassSelection = function()
		resetPlayerSelections()
		startSelectionTimer(remotes)
	end

	debugLog("ClassService initialization complete")
	return gameManager
end

-- Enable debug logging
local function setDebugMode(enabled)
	DEBUG_MODE = enabled
	debugLog("Debug mode " .. (enabled and "enabled" or "disabled"))
end

-- Initialize with debug mode off
setDebugMode(false)

-- Start the service
local gameManager = initializeClassService()
return gameManager
