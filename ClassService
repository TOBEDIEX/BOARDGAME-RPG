-- Fixed ClassService.server.lua
-- จัดการระบบคลาสและการเลือกคลาส server-side
-- Version: 3.1.0 (Timer Removed)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Debug mode for detailed logging
local DEBUG_MODE = false

-- Helper function for logging
local function debugLog(message)
	if DEBUG_MODE then
		print("[ClassService] " .. message)
	end
end

-- Get modules and remote events
local Modules = ServerStorage:WaitForChild("Modules")
local ClassSystem = require(Modules:WaitForChild("ClassSystem"))
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local ClassData = require(SharedModules:WaitForChild("ClassData"))

-- Get GameManager from global
local function getGameManager()
	local startTime = tick()
	local attempts = 0
	local maxAttempts = 20

	while not _G.GameManager and attempts < maxAttempts do
		wait(0.5)
		attempts = attempts + 1
		debugLog("Waiting for GameManager... Attempt " .. attempts)
	end

	if not _G.GameManager then
		warn("[ClassService] Failed to get GameManager after " .. maxAttempts .. " attempts.")
	else
		debugLog("GameManager found successfully.")
	end

	return _G.GameManager
end

-- Initialize player selection tracking
local playerSelections = {}
local playerReadyStatus = {}

-- Initialize remote events
local function initializeRemoteEvents()
	debugLog("Initializing remote events...")

	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local uiRemotes = remotes:WaitForChild("UIRemotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes")

	-- Create required remotes if they don't exist
	local function ensureRemoteEvent(parent, name)
		local event = parent:FindFirstChild(name)
		if not event then
			event = Instance.new("RemoteEvent")
			event.Name = name
			event.Parent = parent
			debugLog("Created RemoteEvent: " .. name)
		end
		return event
	end

	-- UI Remotes
	local classAssignedEvent = ensureRemoteEvent(uiRemotes, "ClassAssigned")
	local playerSelectedClassEvent = ensureRemoteEvent(uiRemotes, "PlayerSelectedClass")
	local updateClassSelectionEvent = ensureRemoteEvent(uiRemotes, "UpdateClassSelection")
	-- local updateClassSelectionTimerEvent = ensureRemoteEvent(uiRemotes, "UpdateClassSelectionTimer") -- ลบออก: RemoteEvent สำหรับอัปเดตเวลา
	-- local notifyRandomClassEvent = ensureRemoteEvent(uiRemotes, "NotifyRandomClass") -- ลบออก: RemoteEvent สำหรับแจ้งเตือนการสุ่มคลาส
	local showMainGameUIEvent = ensureRemoteEvent(uiRemotes, "ShowMainGameUI")
	local levelUpEvent = ensureRemoteEvent(uiRemotes, "LevelUp")
	local classLevelUpEvent = ensureRemoteEvent(uiRemotes, "ClassLevelUp")
	local updatePlayerStatsEvent = ensureRemoteEvent(uiRemotes, "UpdatePlayerStats")
	local showClassSelectionEvent = ensureRemoteEvent(uiRemotes, "ShowClassSelection")

	debugLog("All remote events initialized.")

	return {
		classAssigned = classAssignedEvent,
		playerSelectedClass = playerSelectedClassEvent,
		updateClassSelection = updateClassSelectionEvent,
		showMainGameUI = showMainGameUIEvent,
		levelUp = levelUpEvent,
		classLevelUp = classLevelUpEvent,
		updatePlayerStats = updatePlayerStatsEvent,
		showClassSelection = showClassSelectionEvent
	}
end

-- Finish class selection and transition to game
local function finishClassSelection(remotes)
	debugLog("Finishing class selection...")

	local gameManager = getGameManager()
	if not gameManager then
		warn("[ClassService] GameManager not found, cannot finish class selection")
		return
	end

	-- Assign classes to all players
	for userId, className in pairs(playerSelections) do
		local player = nil

		-- Find player from UserId
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.UserId == userId then
				player = plr
				break
			end
		end

		if player then
			-- Get class data
			local classInfo = ClassData:GetClassInfo(className)
			debugLog("Assigning class " .. className .. " to player " .. player.Name)

			-- Assign class via ClassSystem
			if gameManager.classSystem then
				gameManager.classSystem:AssignClassToPlayer(player, className)
			end

			-- Assign class via PlayerManager
			if gameManager.playerManager then
				gameManager.playerManager:SetPlayerClass(player, className)

				-- Get player data for UI update
				local playerData = gameManager.playerManager:GetPlayerData(player)
				if playerData then
					-- Update player's UI with stats
					local updatePlayerStatsEvent = remotes.updatePlayerStats

					updatePlayerStatsEvent:FireClient(player, player.UserId, {
						hp = playerData.stats.hp,
						maxHp = playerData.stats.maxHp,
						mp = playerData.stats.mp,
						maxMp = playerData.stats.maxMp,
						level = playerData.stats.level or 1,
						class = className,
						money = playerData.stats.money
					})
				end
			end
		end
	end

	-- Show main game UI to all players after a brief delay
	debugLog("Waiting 1 second before transitioning to main game...")
	wait(1)
	remotes.showMainGameUI:FireAllClients()
	debugLog("All players transitioned to main game UI")

	-- Clean up
	for _, player in pairs(Players:GetPlayers()) do
		playerReadyStatus[player.UserId] = nil
	end
	playerSelections = {}

	-- Start game
	if gameManager.turnSystem then
		debugLog("Starting turn system...")
		gameManager.turnSystem:StartTurnSystem()
	end
end
-- Check if all players are loaded (ready for class selection)
local function areAllPlayersReady()
	local allPlayers = Players:GetPlayers()
	local readyCount = 0

	for _, player in ipairs(allPlayers) do
		if playerReadyStatus[player.UserId] then
			readyCount = readyCount + 1
		end
	end

	-- ต้องมีผู้เล่นอย่างน้อย 1 คน และทุกคนต้องพร้อม
	return #allPlayers > 0 and readyCount == #allPlayers
end


-- Monitor player ready state from GameManager
local function monitorPlayerReadyState(gameManager)
	if not gameManager then return end

	debugLog("Starting player ready state monitoring...")

	-- Connect to game events
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes")
	local assetsLoadedEvent = gameRemotes:WaitForChild("AssetsLoaded")

	-- Track loading state
	assetsLoadedEvent.OnServerEvent:Connect(function(player)
		playerReadyStatus[player.UserId] = true
		debugLog("Player ready: " .. player.Name)

		-- Check if all players are ready to proceed to class selection
		if areAllPlayersReady() then
			-- Wait a moment to ensure everyone's loading screen is complete
			wait(1)
			debugLog("All players ready, transitioning to class selection...")

			-- Show class selection UI to all players
			local uiRemotes = remotes:WaitForChild("UIRemotes")
			local showClassSelectionEvent = uiRemotes:WaitForChild("ShowClassSelection")
			showClassSelectionEvent:FireAllClients()

		end
	end)

	-- Monitor player joins
	Players.PlayerAdded:Connect(function(player)
		playerReadyStatus[player.UserId] = false
		debugLog("Player joined: " .. player.Name)
	end)

	-- Monitor player leaves
	Players.PlayerRemoving:Connect(function(player)
		playerReadyStatus[player.UserId] = nil
		playerSelections[player.UserId] = nil
		debugLog("Player left: " .. player.Name)

		-- Check if the leaving player was the last one needed to make a selection
		local allSelected = true
		local currentPlayers = Players:GetPlayers()
		if #currentPlayers > 0 then
			for _, plr in pairs(currentPlayers) do
				if plr.UserId ~= player.UserId and not playerSelections[plr.UserId] then
					allSelected = false
					break
				end
			end
		else
			allSelected = false -- ไม่มีผู้เล่นเหลือ
		end

		-- ถ้าผู้เล่นที่ออกไปทำให้ทุกคนเลือกครบแล้ว ให้เริ่มเกม
		if allSelected then
			debugLog("Last required player left, but all remaining have selected. Finishing selection.")
			finishClassSelection(initializeRemoteEvents()) -- ต้องแน่ใจว่า remotes ถูก initialize แล้ว
		end
	end)

	debugLog("Player ready state monitoring initialized.")
end


-- Handle player selection
local function handlePlayerSelection(player, className, remotes)
	if not player or not className then
		debugLog("Invalid player selection parameters")
		return
	end

	-- Validate class name
	local classInfo = ClassData:GetClassInfo(className)
	if not classInfo then
		debugLog("Invalid class selected by " .. player.Name .. ": " .. tostring(className))
		return
	end

	-- Store selection
	playerSelections[player.UserId] = className
	debugLog(player.Name .. " selected class: " .. className)

	-- Broadcast to all clients
	remotes.updateClassSelection:FireAllClients(player.UserId, className)

	-- Check if all players have selected
	local allSelected = true
	for _, plr in pairs(Players:GetPlayers()) do
		if not playerSelections[plr.UserId] then
			allSelected = false
			break
		end
	end

	-- If all selected, continue game setup
	if allSelected and #Players:GetPlayers() > 0 then

		debugLog("All players selected classes, transitioning to game...")
		wait(1) -- ลดเวลา delay ลงเล็กน้อย
		finishClassSelection(remotes)
	end
end

-- Reset player selections
local function resetPlayerSelections()
	playerSelections = {}
	playerReadyStatus = {}

	debugLog("Player selections and ready status reset")
end

-- Initialize service
local function initializeClassService()
	debugLog("Initializing ClassService...")

	-- Wait for GameManager
	local gameManager = getGameManager()
	if not gameManager then
		debugLog("GameManager not found, initializing own ClassSystem")
		gameManager = {
			classSystem = ClassSystem.new()
			-- PlayerManager ควรถูกสร้างใน GameManager หลัก
		}
		_G.GameManager = gameManager
	end

	-- Create ClassSystem if needed
	if not gameManager.classSystem then
		debugLog("Creating new ClassSystem")
		gameManager.classSystem = ClassSystem.new()
	end

	-- Initialize remote events
	local remotes = initializeRemoteEvents()
	debugLog("Remote events initialized")

	-- Set up class assignment handler
	local function handleClassAssignment(player, className, classData)
		-- Could update character appearance based on class
		debugLog("Handling class assignment for " .. player.Name .. ": " .. className)

		-- Update UI
		remotes.classAssigned:FireClient(player, className, classData)
	end

	-- Connect to player selected class event
	remotes.playerSelectedClass.OnServerEvent:Connect(function(player, className)
		handlePlayerSelection(player, className, remotes)
	end)

	-- Connect to class system events
	if gameManager.classSystem then
		gameManager.classSystem.onClassAssigned = handleClassAssignment
	end

	-- Set up player ready monitoring
	monitorPlayerReadyState(gameManager)

	-- Handle player joining mid-game (ไม่เกี่ยวกับ timer แล้ว)
	Players.PlayerAdded:Connect(function(player)
		debugLog("Player joined: " .. player.Name)
		playerReadyStatus[player.UserId] = false

	end)

	-- Add public methods to GameManager
	gameManager.resetPlayerSelections = resetPlayerSelections
	gameManager.triggerClassSelectionUI = function()
		resetPlayerSelections()
		-- ตรวจสอบว่ามีผู้เล่นพร้อมหรือไม่ก่อนแสดง UI
		if areAllPlayersReady() then
			debugLog("Triggering class selection UI for all players.")
			remotes.showClassSelection:FireAllClients()
		else
			debugLog("Cannot trigger class selection UI, not all players are ready.")
		end
	end


	debugLog("ClassService initialization complete")
	return gameManager
end

-- Enable debug logging
local function setDebugMode(enabled)
	DEBUG_MODE = enabled
	debugLog("Debug mode " .. (enabled and "enabled" or "disabled"))
end

-- Initialize with debug mode off
setDebugMode(false)

-- Start the service
local gameManager = initializeClassService()
return gameManager
