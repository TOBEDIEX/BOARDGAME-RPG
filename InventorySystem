-- InventorySystem.lua (Updated)
-- Core module for inventory management
-- Version: 2.1.0 (Optimized with Equipment UI Support)

local InventorySystem = {}
InventorySystem.__index = InventorySystem

-- Constants
local MAX_INVENTORY_SIZE = 50
local MAX_EQUIPPABLE_ITEMS = 6

-- Item types
local ITEM_TYPES = {
	GENERAL = 1,    -- General items
	EQUIPMENT = 2,  -- Weapons and armor
	SKILL = 3,      -- Skill books
	SPECIAL = 4     -- Special/quest items
}

-- Equipment slots
local EQUIPMENT_SLOTS = {
	WEAPON = 1,
	HELMET = 2,
	ARMOR = 3,
	GLOVES = 4,
	BOOTS = 5,
	ACCESSORY = 6
}

-- Constructor
function InventorySystem.new()
	local self = setmetatable({}, InventorySystem)

	-- Inventory structure
	self.items = {}            -- All items
	self.equippedItems = {}    -- Equipped items
	self.itemCount = 0         -- Total item count
	self.maxSize = MAX_INVENTORY_SIZE

	-- Initialize equipped item slots
	for i = 1, MAX_EQUIPPABLE_ITEMS do
		self.equippedItems[i] = nil
	end

	return self
end

-- Constants accessor functions
function InventorySystem.GetItemTypes()
	return ITEM_TYPES
end

function InventorySystem.GetEquipmentSlots()
	return EQUIPMENT_SLOTS
end

-- Add item to inventory
function InventorySystem:AddItem(itemData, quantity)
	if not itemData then
		warn("InventorySystem:AddItem - itemData is nil")
		return false, "Invalid item data"
	end

	quantity = quantity or 1

	-- Check if there's enough space
	if not self:HasSpace() and not self:CanStack(itemData) then
		return false, "Inventory is full"
	end

	-- Check if item is stackable
	if itemData.stackable then
		-- Look for existing stack
		for _, item in pairs(self.items) do
			if item.id == itemData.id then
				-- Calculate how many can be added
				local maxAddable = (item.maxStack or 99) - (item.quantity or 0)
				local toAdd = math.min(quantity, maxAddable)

				-- If we can add some
				if toAdd > 0 then
					item.quantity = (item.quantity or 0) + toAdd
					quantity = quantity - toAdd

					-- If we've added all
					if quantity <= 0 then
						return true, "Item added successfully"
					end
				end
			end
		end
	end

	-- If there's still quantity remaining, create new entries
	while quantity > 0 and self.itemCount < self.maxSize do
		local newItem = table.clone(itemData)
		local stackSize = math.min(quantity, newItem.maxStack or 99)

		newItem.quantity = stackSize
		newItem.inventoryId = self:GenerateInventoryId()

		table.insert(self.items, newItem)
		self.itemCount = self.itemCount + 1
		quantity = quantity - stackSize
	end

	-- If there's still quantity remaining, inventory is full
	if quantity > 0 then
		return true, "Some items were added, but inventory is now full"
	end

	return true, "Item added successfully"
end

-- Generate unique internal ID for inventory item
function InventorySystem:GenerateInventoryId()
	return tostring(os.time()) .. "_" .. math.random(1000, 9999)
end

-- Check if there's space available
function InventorySystem:HasSpace()
	return self.itemCount < self.maxSize
end

-- Check if item can stack with existing items
function InventorySystem:CanStack(itemData)
	if not itemData.stackable then
		return false
	end

	for _, item in pairs(self.items) do
		if item.id == itemData.id and (item.quantity or 0) < (item.maxStack or 99) then
			return true
		end
	end

	return false
end

-- Remove item from inventory
function InventorySystem:RemoveItem(inventoryId, quantity)
	quantity = quantity or 1

	for i, item in pairs(self.items) do
		if item.inventoryId == inventoryId then
			if (item.quantity or 1) <= quantity then
				-- Remove all
				table.remove(self.items, i)
				self.itemCount = self.itemCount - 1
				return true, "Item removed"
			else
				-- Remove some
				item.quantity = item.quantity - quantity
				return true, "Some items removed"
			end
		end
	end

	return false, "Item not found"
end

-- Remove item by ID
function InventorySystem:RemoveItemById(itemId, quantity)
	quantity = quantity or 1
	local remainingToRemove = quantity
	local removed = false

	-- Create list of indices to remove
	local indicesToRemove = {}

	-- Find items to remove
	for i, item in pairs(self.items) do
		if item.id == itemId and remainingToRemove > 0 then
			if (item.quantity or 1) <= remainingToRemove then
				-- Remove all
				table.insert(indicesToRemove, i)
				remainingToRemove = remainingToRemove - (item.quantity or 1)
				removed = true
			else
				-- Remove some
				item.quantity = item.quantity - remainingToRemove
				remainingToRemove = 0
				removed = true
				break
			end
		end
	end

	-- Remove from the end to avoid index shifts
	table.sort(indicesToRemove, function(a, b) return a > b end)
	for _, index in ipairs(indicesToRemove) do
		table.remove(self.items, index)
		self.itemCount = self.itemCount - 1
	end

	if removed then
		if remainingToRemove <= 0 then
			return true, "Items removed successfully"
		else
			return true, "Some items removed"
		end
	end

	return false, "Item not found"
end

-- Find item by inventory ID
function InventorySystem:FindItemByInventoryId(inventoryId)
	for _, item in pairs(self.items) do
		if item.inventoryId == inventoryId then
			return item
		end
	end
	return nil
end

-- Find all items by item ID
function InventorySystem:FindAllItemsById(itemId)
	local results = {}

	for _, item in pairs(self.items) do
		if item.id == itemId then
			table.insert(results, item)
		end
	end

	return results
end

-- Count total quantity of an item by ID
function InventorySystem:CountItemsById(itemId)
	local count = 0

	for _, item in pairs(self.items) do
		if item.id == itemId then
			count = count + (item.quantity or 1)
		end
	end

	return count
end

-- Use an item
function InventorySystem:UseItem(inventoryId)
	local item = self:FindItemByInventoryId(inventoryId)

	if not item then
		return false, "Item not found"
	end

	if not item.usable then
		return false, "Item cannot be used"
	end

	-- Call use function if available
	local success, result
	if type(item.useFunction) == "function" then
		success, result = pcall(item.useFunction, item)
		if not success then
			warn("Error using item: " .. tostring(result))
			return false, "Error using item"
		end
	end

	-- Remove if consumable
	if item.consumable then
		return self:RemoveItem(inventoryId, 1)
	end

	return true, result or "Item used successfully"
end

-- Equip an item
function InventorySystem:EquipItem(inventoryId)
	local item = self:FindItemByInventoryId(inventoryId)

	if not item then
		return false, "Item not found"
	end

	if item.type ~= ITEM_TYPES.EQUIPMENT then
		return false, "Item cannot be equipped"
	end

	if not item.subType or item.subType < 1 or item.subType > MAX_EQUIPPABLE_ITEMS then
		return false, "Invalid equipment type"
	end

	-- Unequip existing item in slot
	if self.equippedItems[item.subType] then
		local oldItemInventoryId = self.equippedItems[item.subType]
		self.equippedItems[item.subType] = nil

		-- Mark as unequipped
		local oldItem = self:FindItemByInventoryId(oldItemInventoryId)
		if oldItem then
			oldItem.equipped = false
		end
	end

	-- Equip new item
	self.equippedItems[item.subType] = inventoryId
	item.equipped = true

	return true, "Item equipped successfully"
end

-- Unequip an item
function InventorySystem:UnequipItem(slotType)
	if not self.equippedItems[slotType] then
		return false, "No item equipped in this slot"
	end

	local inventoryId = self.equippedItems[slotType]
	self.equippedItems[slotType] = nil

	-- Mark as unequipped
	local item = self:FindItemByInventoryId(inventoryId)
	if item then
		item.equipped = false
	end

	return true, "Item unequipped successfully"
end

-- Get all equipped items
function InventorySystem:GetEquippedItems()
	local result = {}

	for slot, inventoryId in pairs(self.equippedItems) do
		local item = self:FindItemByInventoryId(inventoryId)
		if item then
			-- Add slot information to the item for UI
			item.equippedSlot = slot
			result[slot] = item
		end
	end

	return result
end

-- Get item equipped in a specific slot
function InventorySystem:GetEquippedItemInSlot(slotType)
	local inventoryId = self.equippedItems[slotType]
	if not inventoryId then
		return nil
	end

	return self:FindItemByInventoryId(inventoryId)
end

-- Check if slot has equipment
function InventorySystem:HasEquippedItemInSlot(slotType)
	return self.equippedItems[slotType] ~= nil
end

-- Get all items
function InventorySystem:GetAllItems()
	return self.items
end

-- Get items by type
function InventorySystem:GetItemsByType(itemType)
	local result = {}

	for _, item in pairs(self.items) do
		if item.type == itemType then
			table.insert(result, item)
		end
	end

	return result
end

-- Calculate stats from equipped items
function InventorySystem:CalculateEquipmentStats()
	local stats = {
		attack = 0,
		defense = 0,
		hp = 0,
		mp = 0,
		magic = 0,
		agility = 0,
		critRate = 0,
		evasion = 0
	}

	for slotType, inventoryId in pairs(self.equippedItems) do
		local item = self:FindItemByInventoryId(inventoryId)
		if item and item.stats then
			for statName, statValue in pairs(item.stats) do
				if stats[statName] ~= nil then
					stats[statName] = stats[statName] + statValue
				else
					-- If it's a new stat, add it
					stats[statName] = statValue
				end
			end

			-- Store slot-specific stats if needed
			if slotType == EQUIPMENT_SLOTS.WEAPON and item.stats.attack then
				stats.weaponAttack = item.stats.attack
			elseif slotType == EQUIPMENT_SLOTS.ARMOR and item.stats.defense then
				stats.armorDefense = item.stats.defense
			end
		end
	end

	return stats
end

-- Serialize to JSON
function InventorySystem:Serialize()
	local data = {
		items = {},
		equippedItems = self.equippedItems,
		itemCount = self.itemCount,
		maxSize = self.maxSize
	}

	-- Copy each item (excluding functions)
	for i, item in ipairs(self.items) do
		local itemCopy = table.clone(item)
		itemCopy.useFunction = nil -- Functions can't be serialized
		table.insert(data.items, itemCopy)
	end

	return game:GetService("HttpService"):JSONEncode(data)
end

-- Deserialize from JSON
function InventorySystem:Deserialize(jsonData)
	if not jsonData or jsonData == "" then
		return false
	end

	local success, data = pcall(function()
		return game:GetService("HttpService"):JSONDecode(jsonData)
	end)

	if not success or type(data) ~= "table" then
		warn("InventorySystem:Deserialize - Invalid JSON data")
		return false
	end

	self.items = data.items or {}
	self.equippedItems = data.equippedItems or {}
	self.itemCount = data.itemCount or #self.items
	self.maxSize = data.maxSize or MAX_INVENTORY_SIZE

	return true
end

-- Get remaining space
function InventorySystem:GetRemainingSpace()
	return self.maxSize - self.itemCount
end

-- Check if there are enough items
function InventorySystem:HasEnoughItems(itemId, quantity)
	return self:CountItemsById(itemId) >= quantity
end

-- Clean up data (fix duplicates and other issues)
function InventorySystem:CleanupData()
	-- Fix item count
	local actualCount = #self.items
	if self.itemCount ~= actualCount then
		self.itemCount = actualCount
	end

	-- Check for duplicate inventory IDs
	local idMap = {}
	for i, item in ipairs(self.items) do
		if not item.inventoryId then
			item.inventoryId = self:GenerateInventoryId()
		elseif idMap[item.inventoryId] then
			-- If duplicate, generate new ID
			item.inventoryId = self:GenerateInventoryId()
		end
		idMap[item.inventoryId] = true
	end

	-- Verify equipped items exist
	for slot, inventoryId in pairs(self.equippedItems) do
		local found = false
		for _, item in ipairs(self.items) do
			if item.inventoryId == inventoryId then
				found = true
				-- Ensure equipped flag is set
				if not item.equipped then
					item.equipped = true
				end
				break
			end
		end

		if not found then
			-- If referenced item not found, clear slot
			self.equippedItems[slot] = nil
		end
	end

	return true
end

return InventorySystem
