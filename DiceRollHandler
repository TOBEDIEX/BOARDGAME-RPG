-- DiceRollHandler.lua
-- Manages dice roll interface and path selection
-- Version: 2.6.0 (Fixed Crystal Movement UI)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Get local player
local player = Players.LocalPlayer

-- Get UI elements
local PlayerGui = player:WaitForChild("PlayerGui")
local PopupUI = PlayerGui:WaitForChild("PopupUI")
local DiceRollUI = PopupUI:WaitForChild("DiceRollUI")

-- Validate UI exists
if not DiceRollUI then
	warn("DiceRollUI not found in PopupUI")
	return
end

-- Get UI components
local DiceWheel = DiceRollUI:FindFirstChild("DiceWheel")
local DiceResult = DiceWheel and DiceWheel:FindFirstChild("DiceResult")
local RollButton = DiceRollUI:FindFirstChild("RollButton")
local PathSelectionContainer = DiceRollUI:FindFirstChild("PathSelectionContainer")
local RemainingStepsText = PathSelectionContainer and PathSelectionContainer:FindFirstChild("RemainingStepsText")
local ForwardButton = PathSelectionContainer and PathSelectionContainer:FindFirstChild("ForwardButton")
local LeftButton = PathSelectionContainer and PathSelectionContainer:FindFirstChild("LeftButton")
local RightButton = PathSelectionContainer and PathSelectionContainer:FindFirstChild("RightButton")

-- Validate required components
if not DiceWheel or not DiceResult or not RollButton or not PathSelectionContainer 
	or not RemainingStepsText or not ForwardButton or not LeftButton or not RightButton then
	warn("Some required UI elements for DiceRollUI are missing")
	return
end

-- Get remotes
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local boardRemotes = remotes:WaitForChild("BoardRemotes")
local gameRemotes = remotes:WaitForChild("GameRemotes")
local inventoryRemotes = remotes:WaitForChild("InventoryRemotes", 5)

-- Get remote events
local rollDiceEvent = boardRemotes:WaitForChild("RollDice")
local showPathSelectionEvent = boardRemotes:WaitForChild("ShowPathSelection")
local choosePathEvent = boardRemotes:WaitForChild("ChoosePath")
local updateTurnEvent = gameRemotes:WaitForChild("UpdateTurn")

-- NEW: Get crystal move complete event
local crystalMoveCompleteEvent = boardRemotes:FindFirstChild("CrystalMoveComplete")
if not crystalMoveCompleteEvent then
	crystalMoveCompleteEvent = Instance.new("RemoteEvent")
	crystalMoveCompleteEvent.Name = "CrystalMoveComplete"
	crystalMoveCompleteEvent.Parent = boardRemotes
end

-- Create Remote for CrystalUIReset if needed
if not inventoryRemotes then
	inventoryRemotes = Instance.new("Folder")
	inventoryRemotes.Name = "InventoryRemotes"
	inventoryRemotes.Parent = remotes
end

local crystalUIResetEvent = inventoryRemotes:FindFirstChild("CrystalUIReset")
if not crystalUIResetEvent then
	crystalUIResetEvent = Instance.new("RemoteEvent")
	crystalUIResetEvent.Name = "CrystalUIReset"
	crystalUIResetEvent.Parent = inventoryRemotes
end

-- DiceBonus remote
local diceBonusEvent = inventoryRemotes:FindFirstChild("DiceBonus")
if not diceBonusEvent then
	diceBonusEvent = Instance.new("RemoteEvent")
	diceBonusEvent.Name = "DiceBonus"
	diceBonusEvent.Parent = inventoryRemotes
end

-- Get or create item permission update event
local itemPermissionEvent = inventoryRemotes:FindFirstChild("ItemPermissionUpdate")
if not itemPermissionEvent then
	itemPermissionEvent = Instance.new("RemoteEvent")
	itemPermissionEvent.Name = "ItemPermissionUpdate"
	itemPermissionEvent.Parent = inventoryRemotes
end

-- Constants
local DICE_ANIMATION_DURATION = 2
local DICE_VALUES = {1, 2, 3, 4, 5, 6}
local DIRECTIONS = {
	FRONT = "FRONT",
	LEFT = "LEFT",
	RIGHT = "RIGHT"
}

-- Variables
local isRolling = false
local canRoll = false
local currentDiceResult = nil
local currentPathChoices = nil
local remainingSteps = 0
local activeDiceBonus = 0
local bonusDiceResults = {}

-- NEW: Track crystal movement state
local isCrystalMovementActive = false
local crystalSteps = 0

-- Add debug mode
local DEBUG_MODE = true

-- Debug logging function
local function debugLog(message)
	if DEBUG_MODE then
		print("[DiceRollHandler] " .. tostring(message))
	end
end

-- NEW: Create Crystal UI
local function createCrystalEffectUI(steps)
	-- Remove any existing crystal effect
	for _, child in pairs(PlayerGui:GetChildren()) do
		if child.Name == "CrystalEffect" then
			child:Destroy()
		end
	end

	-- Create main frame
	local crystalEffect = Instance.new("ScreenGui")
	crystalEffect.Name = "CrystalEffect"
	crystalEffect.ResetOnSpawn = false
	crystalEffect.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	crystalEffect.Parent = PlayerGui

	-- Create container frame
	local container = Instance.new("Frame")
	container.Name = "Container"
	container.BackgroundTransparency = 1
	container.Size = UDim2.new(1, 0, 0.15, 0)
	container.Position = UDim2.new(0, 0, 0.02, 0)
	container.AnchorPoint = Vector2.new(0, 0)
	container.Parent = crystalEffect

	-- Create crystal steps text
	local stepsText = Instance.new("TextLabel")
	stepsText.Name = "StepsText"
	stepsText.Size = UDim2.new(0, 250, 0, 40)
	stepsText.Position = UDim2.new(0.5, 0, 0, 0)
	stepsText.AnchorPoint = Vector2.new(0.5, 0)
	stepsText.Font = Enum.Font.GothamBold
	stepsText.TextSize = 24
	stepsText.TextColor3 = Color3.fromRGB(100, 200, 255)
	stepsText.Text = "Crystal Movement: " .. steps .. " steps"
	stepsText.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	stepsText.BackgroundTransparency = 0.5
	stepsText.BorderSizePixel = 0
	stepsText.Parent = container

	-- Add corner
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = stepsText

	-- Add glow
	local glow = Instance.new("UIStroke")
	glow.Color = Color3.fromRGB(80, 170, 255)
	glow.Thickness = 2
	glow.Transparency = 0.2
	glow.Parent = stepsText

	-- Animation
	stepsText.TextTransparency = 1
	stepsText.BackgroundTransparency = 1

	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(stepsText, tweenInfo, {
		TextTransparency = 0,
		BackgroundTransparency = 0.5
	})
	tween:Play()

	-- Auto-destroy after movement completes
	task.delay(10, function()
		if crystalEffect and crystalEffect.Parent then
			local fadeOut = TweenService:Create(stepsText, TweenInfo.new(0.5), {
				TextTransparency = 1,
				BackgroundTransparency = 1
			})
			fadeOut:Play()
			fadeOut.Completed:Connect(function()
				crystalEffect:Destroy()
			end)
		end
	end)

	return crystalEffect
end

-- NEW: Function to explicitly signal crystal movement completion
local function signalCrystalMoveComplete()
	if isCrystalMovementActive then
		debugLog("Sending crystal move complete signal to server")

		-- Signal the server that crystal movement is complete
		crystalMoveCompleteEvent:FireServer()

		-- Also notify InventoryService
		local crystalMoveCompleteInventoryEvent = inventoryRemotes:FindFirstChild("CrystalMoveComplete")
		if crystalMoveCompleteInventoryEvent then
			crystalMoveCompleteInventoryEvent:FireServer()
		end

		-- Reset crystal state
		isCrystalMovementActive = false
		crystalSteps = 0

		-- Remove any crystal effect UI
		for _, child in pairs(PlayerGui:GetChildren()) do
			if child.Name == "CrystalEffect" then
				child:Destroy()
			end
		end
	end
end

-- Function to create bonus dice (unchanged)
local function createBonusDice(numBonusDice)
	-- Remove any old dice
	for _, dice in pairs(DiceWheel:GetChildren()) do
		if dice.Name:find("BonusDice") or dice.Name == "TotalResult" then
			dice:Destroy()
		end
	end

	bonusDiceResults = {}

	-- Main dice position
	local mainDicePosition = DiceResult.Position
	local mainDiceAnchor = DiceResult.AnchorPoint
	local mainDiceSize = DiceResult.Size

	-- Spacing between dice
	local spacing = 1.5 -- Multiple of dice width

	debugLog("Creating " .. numBonusDice .. " bonus dice")

	-- If 1 bonus die, place to left of main die
	if numBonusDice == 1 then
		local bonusDice = DiceResult:Clone()
		bonusDice.Name = "BonusDice_1"
		bonusDice.Position = UDim2.new(mainDicePosition.X.Scale - spacing * mainDiceSize.X.Scale, 0, mainDicePosition.Y.Scale, 0)
		bonusDice.AnchorPoint = mainDiceAnchor
		bonusDice.TextColor3 = Color3.fromRGB(100, 255, 100) -- Light green
		bonusDice.Text = ""
		bonusDice.Parent = DiceWheel

		bonusDiceResults[1] = 0
	end

	-- If 2 bonus dice, place on both sides
	if numBonusDice == 2 then
		-- Left die
		local leftDice = DiceResult:Clone()
		leftDice.Name = "BonusDice_L"
		leftDice.Position = UDim2.new(mainDicePosition.X.Scale - spacing * mainDiceSize.X.Scale, 0, mainDicePosition.Y.Scale, 0)
		leftDice.AnchorPoint = mainDiceAnchor
		leftDice.TextColor3 = Color3.fromRGB(100, 255, 100) -- Light green
		leftDice.Text = ""
		leftDice.Parent = DiceWheel

		-- Right die
		local rightDice = DiceResult:Clone()
		rightDice.Name = "BonusDice_R"
		rightDice.Position = UDim2.new(mainDicePosition.X.Scale + spacing * mainDiceSize.X.Scale, 0, mainDicePosition.Y.Scale, 0)
		rightDice.AnchorPoint = mainDiceAnchor
		rightDice.TextColor3 = Color3.fromRGB(100, 255, 100) -- Light green
		rightDice.Text = ""
		rightDice.Parent = DiceWheel

		bonusDiceResults[1] = 0
		bonusDiceResults[2] = 0
	end

	-- Support for more than 2 bonus dice
	if numBonusDice > 2 then
		for i = 1, numBonusDice do
			local position
			if i % 2 == 1 then -- Odd dice to left
				local offset = math.ceil(i/2) * spacing
				position = UDim2.new(mainDicePosition.X.Scale - offset * mainDiceSize.X.Scale, 0, mainDicePosition.Y.Scale, 0)
			else -- Even dice to right
				local offset = (i/2) * spacing
				position = UDim2.new(mainDicePosition.X.Scale + offset * mainDiceSize.X.Scale, 0, mainDicePosition.Y.Scale, 0)
			end

			local bonusDice = DiceResult:Clone()
			bonusDice.Name = "BonusDice_" .. i
			bonusDice.Position = position
			bonusDice.AnchorPoint = mainDiceAnchor
			bonusDice.TextColor3 = Color3.fromRGB(100, 255, 100) -- Light green
			bonusDice.Text = ""
			bonusDice.Parent = DiceWheel

			bonusDiceResults[i] = 0
		end
	end

	return bonusDiceResults
end

-- Total result UI (unchanged)
local function createTotalResult(total)
	-- Remove old total
	local oldTotal = DiceWheel:FindFirstChild("TotalResult")
	if oldTotal then
		oldTotal:Destroy()
	end

	-- Get main dice position
	local mainDicePosition = DiceResult.Position
	local mainDiceAnchorPoint = DiceResult.AnchorPoint
	local mainDiceSize = DiceResult.Size

	-- Create total frame
	local totalFrame = Instance.new("Frame")
	totalFrame.Name = "TotalResult"
	totalFrame.Size = UDim2.new(0, 120, 0, 40) -- Larger size
	-- Position above main dice
	totalFrame.Position = UDim2.new(mainDicePosition.X.Scale, 0, mainDicePosition.Y.Scale - 0.35, 0)
	totalFrame.AnchorPoint = Vector2.new(0.5, 0.5) -- Center anchor
	totalFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 50)
	totalFrame.BackgroundTransparency = 0.2
	totalFrame.ZIndex = 5
	totalFrame.Parent = DiceWheel

	-- Add rounded corners
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = totalFrame

	-- Add shadow
	local shadow = Instance.new("UIStroke")
	shadow.Color = Color3.fromRGB(0, 0, 0)
	shadow.Transparency = 0.5
	shadow.Thickness = 2
	shadow.Parent = totalFrame

	-- Add total text
	local totalText = Instance.new("TextLabel")
	totalText.Name = "TotalText"
	totalText.Size = UDim2.new(1, 0, 1, 0)
	totalText.Position = UDim2.new(0.5, 0, 0.5, 0)
	totalText.AnchorPoint = Vector2.new(0.5, 0.5)
	totalText.BackgroundTransparency = 1
	totalText.TextColor3 = Color3.fromRGB(255, 255, 0) -- Yellow
	totalText.Font = Enum.Font.GothamBold
	totalText.TextSize = 22
	totalText.Text = "Total: " .. total
	totalText.ZIndex = 6
	totalText.Parent = totalFrame

	-- Animation
	totalFrame.Size = UDim2.new(0, 0, 0, 40)
	totalText.TextTransparency = 1

	-- Expand frame animation
	local frameTween = TweenService:Create(
		totalFrame,
		TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{Size = UDim2.new(0, 120, 0, 40)}
	)
	frameTween:Play()

	-- Show text after frame expands
	frameTween.Completed:Connect(function()
		local textTween = TweenService:Create(
			totalText,
			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{TextTransparency = 0}
		)
		textTween:Play()
	end)

	return totalFrame
end

-- Bonus notification (unchanged)
local function createBonusNotification(bonusAmount)
	-- Remove old notification
	local oldNotification = PlayerGui:FindFirstChild("DiceBonusNotification")
	if oldNotification then
		oldNotification:Destroy()
	end

	-- Create new notification
	local notification = Instance.new("Frame")
	notification.Name = "DiceBonusNotification"
	notification.Size = UDim2.new(0, 160, 0, 40)
	notification.Position = UDim2.new(1, -170, 0, 10) -- Top right
	notification.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	notification.BackgroundTransparency = 0.2
	notification.BorderSizePixel = 0
	notification.Parent = PlayerGui

	-- Add rounded corners
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = notification

	-- Notification text
	local text = Instance.new("TextLabel")
	text.Name = "NotificationText"
	text.Size = UDim2.new(1, -10, 1, 0)
	text.Position = UDim2.new(0.5, 0, 0.5, 0)
	text.AnchorPoint = Vector2.new(0.5, 0.5)
	text.BackgroundTransparency = 1
	text.Font = Enum.Font.GothamSemibold
	text.TextSize = 14
	text.TextColor3 = Color3.fromRGB(120, 255, 120)
	text.Text = "Dice Bonus: +" .. bonusAmount
	text.Parent = notification

	-- Add icon
	local icon = Instance.new("ImageLabel")
	icon.Name = "Icon"
	icon.Size = UDim2.new(0, 24, 0, 24)
	icon.Position = UDim2.new(0, 8, 0.5, 0)
	icon.AnchorPoint = Vector2.new(0, 0.5)
	icon.BackgroundTransparency = 1
	icon.Image = "rbxassetid://7228017567" -- Dice image
	icon.ImageColor3 = Color3.fromRGB(120, 255, 120)
	icon.Parent = notification

	-- Adjust text position to right of icon
	text.Position = UDim2.new(0.6, 0, 0.5, 0)

	-- Animation
	notification.Size = UDim2.new(0, 0, 0, 40)
	local sizeTween = TweenService:Create(
		notification,
		TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{Size = UDim2.new(0, 160, 0, 40)}
	)
	sizeTween:Play()

	return notification
end

-- NEW: Check item usage permission
local function checkItemUsagePermission()
	local itemPermEvent = inventoryRemotes:FindFirstChild("ItemPermissionUpdate")
	if itemPermEvent then
		-- Request permission status from server
		itemPermEvent:FireServer()
		debugLog("Requesting item usage permission from server")
	end
end

-- IMPROVED: Show dice roll UI (checks for crystal movement)
local function showDiceRollUI()
	-- Don't show if crystal movement is active
	if isCrystalMovementActive then
		debugLog("Not showing dice roll UI - crystal movement active")
		DiceRollUI.Visible = false
		return
	end

	DiceRollUI.Visible = true
	RollButton.Visible = true
	PathSelectionContainer.Visible = false

	-- Reset UI state
	DiceResult.Text = ""
	RemainingStepsText.Text = "Steps: 0"
	ForwardButton.Visible = false
	LeftButton.Visible = false
	RightButton.Visible = false

	isRolling = false
	currentDiceResult = nil
	currentPathChoices = nil
	remainingSteps = 0

	-- Show bonus notification if active
	if activeDiceBonus > 0 then
		createBonusNotification(activeDiceBonus)
		createBonusDice(activeDiceBonus)
	else
		-- Remove any bonus dice
		for _, dice in pairs(DiceWheel:GetChildren()) do
			if dice.Name:find("BonusDice") or dice.Name == "TotalResult" then
				dice:Destroy()
			end
		end
	end

	-- Check if we have permission to use items in this turn
	checkItemUsagePermission()
end

-- IMPROVED: Hide dice roll UI (ensures hidden during crystal movement)
local function hideDiceRollUI()
	DiceRollUI.Visible = false
	isRolling = false
	canRoll = false

	if isCrystalMovementActive then
		debugLog("Dice UI hidden during crystal movement")
	end
end

-- Animate dice roll (unchanged)
local function animateDiceRoll(finalResult)
	if isRolling then return end

	isRolling = true
	RollButton.Visible = false

	-- Create bonus dice based on count
	if activeDiceBonus > 0 then
		createBonusDice(activeDiceBonus)
	end

	-- Create animation sequence
	local startTime = tick()
	local endTime = startTime + DICE_ANIMATION_DURATION
	local frameRate = 0.1
	local lastUpdate = 0

	-- Animation loop
	while tick() < endTime do
		local currentTime = tick()
		if currentTime - lastUpdate >= frameRate then
			lastUpdate = currentTime

			-- Show random value for main die
			local randomValue = DICE_VALUES[math.random(1, #DICE_VALUES)]
			DiceResult.Text = tostring(randomValue)

			-- Random values for bonus dice
			if activeDiceBonus == 1 then
				local bonusDice = DiceWheel:FindFirstChild("BonusDice_1")
				if bonusDice then
					local bonusValue = DICE_VALUES[math.random(1, #DICE_VALUES)]
					bonusDice.Text = tostring(bonusValue)
				end
			elseif activeDiceBonus == 2 then
				local leftDice = DiceWheel:FindFirstChild("BonusDice_L")
				local rightDice = DiceWheel:FindFirstChild("BonusDice_R")

				if leftDice then
					leftDice.Text = tostring(DICE_VALUES[math.random(1, #DICE_VALUES)])
				end

				if rightDice then
					rightDice.Text = tostring(DICE_VALUES[math.random(1, #DICE_VALUES)])
				end
			else
				-- For more than 2 bonus dice
				for i = 1, activeDiceBonus do
					local bonusDice = DiceWheel:FindFirstChild("BonusDice_" .. i)
					if bonusDice then
						bonusDice.Text = tostring(DICE_VALUES[math.random(1, #DICE_VALUES)])
					end
				end
			end

			-- Slow down animation near end
			local timeLeft = endTime - currentTime
			if timeLeft < 1 then
				frameRate = 0.2
			end

			wait(frameRate)
		end
	end

	-- Generate final results
	local mainDiceResult = finalResult
	local totalResult = mainDiceResult

	-- Record all dice results for display
	local allDiceResults = {
		main = mainDiceResult,
		bonus = {}
	}

	-- Generate bonus dice results
	if activeDiceBonus == 1 then
		local bonusDice = DiceWheel:FindFirstChild("BonusDice_1")
		if bonusDice then
			local bonusValue = math.random(1, 6)
			table.insert(allDiceResults.bonus, bonusValue)
			bonusDice.Text = tostring(bonusValue)
			totalResult = totalResult + bonusValue
		end
	elseif activeDiceBonus == 2 then
		local leftDice = DiceWheel:FindFirstChild("BonusDice_L")
		local rightDice = DiceWheel:FindFirstChild("BonusDice_R")

		if leftDice then
			local leftValue = math.random(1, 6)
			table.insert(allDiceResults.bonus, leftValue)
			leftDice.Text = tostring(leftValue)
			totalResult = totalResult + leftValue
		end

		if rightDice then
			local rightValue = math.random(1, 6)
			table.insert(allDiceResults.bonus, rightValue)
			rightDice.Text = tostring(rightValue)
			totalResult = totalResult + rightValue
		end
	else
		-- For more than 2 bonus dice
		for i = 1, activeDiceBonus do
			local bonusDice = DiceWheel:FindFirstChild("BonusDice_" .. i)
			if bonusDice then
				local bonusValue = math.random(1, 6)
				table.insert(allDiceResults.bonus, bonusValue)
				bonusDice.Text = tostring(bonusValue)
				totalResult = totalResult + bonusValue
			end
		end
	end

	-- Show original result
	DiceResult.Text = tostring(mainDiceResult)

	-- Show total at top
	if activeDiceBonus > 0 then
		createTotalResult(totalResult)
	end

	-- Animate main dice
	local resultTween = TweenService:Create(
		DiceResult,
		TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
		{TextSize = 60}
	)
	resultTween:Play()

	-- Animate bonus dice
	if activeDiceBonus == 1 then
		local bonusDice = DiceWheel:FindFirstChild("BonusDice_1")
		if bonusDice then
			local bonusTween = TweenService:Create(
				bonusDice,
				TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
				{TextSize = 48}
			)
			bonusTween:Play()
		end
	elseif activeDiceBonus == 2 then
		local leftDice = DiceWheel:FindFirstChild("BonusDice_L")
		local rightDice = DiceWheel:FindFirstChild("BonusDice_R")

		if leftDice then
			local leftTween = TweenService:Create(
				leftDice,
				TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
				{TextSize = 48}
			)
			leftTween:Play()
		end

		if rightDice then
			local rightTween = TweenService:Create(
				rightDice,
				TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
				{TextSize = 48}
			)
			rightTween:Play()
		end
	else
		-- For more than 2 bonus dice
		for i = 1, activeDiceBonus do
			local bonusDice = DiceWheel:FindFirstChild("BonusDice_" .. i)
			if bonusDice then
				local bonusTween = TweenService:Create(
					bonusDice,
					TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
					{TextSize = 48}
				)
				bonusTween:Play()
			end
		end
	end

	wait(0.5)

	-- Scale down animation
	local resetTween = TweenService:Create(
		DiceResult,
		TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{TextSize = 36}
	)
	resetTween:Play()

	-- Scale down bonus dice
	if activeDiceBonus == 1 then
		local bonusDice = DiceWheel:FindFirstChild("BonusDice_1")
		if bonusDice then
			local resetBonusTween = TweenService:Create(
				bonusDice,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{TextSize = 32}
			)
			resetBonusTween:Play()
		end
	elseif activeDiceBonus == 2 then
		local leftDice = DiceWheel:FindFirstChild("BonusDice_L")
		local rightDice = DiceWheel:FindFirstChild("BonusDice_R")

		if leftDice then
			local resetLeftTween = TweenService:Create(
				leftDice,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{TextSize = 32}
			)
			resetLeftTween:Play()
		end

		if rightDice then
			local resetRightTween = TweenService:Create(
				rightDice,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{TextSize = 32}
			)
			resetRightTween:Play()
		end
	else
		-- For more than 2 bonus dice
		for i = 1, activeDiceBonus do
			local bonusDice = DiceWheel:FindFirstChild("BonusDice_" .. i)
			if bonusDice then
				local resetBonusTween = TweenService:Create(
					bonusDice,
					TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{TextSize = 32}
				)
				resetBonusTween:Play()
			end
		end
	end

	isRolling = false
	currentDiceResult = totalResult  -- Use total of all dice
	remainingSteps = totalResult     -- Steps to move equals total

	-- Debug log
	debugLog("=== DICE ROLL RESULT ===")
	debugLog("Main dice: " .. mainDiceResult)
	debugLog("Bonus dice: " .. table.concat(allDiceResults.bonus, ", "))
	debugLog("Total result: " .. totalResult)
	debugLog("======================")

	wait(0.3)

	-- Send result to server
	rollDiceEvent:FireServer(totalResult)

	-- Reset bonus after use
	activeDiceBonus = 0

	-- Remove bonus notification
	local notification = PlayerGui:FindFirstChild("DiceBonusNotification")
	if notification then
		local hideTween = TweenService:Create(
			notification,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{Size = UDim2.new(0, 0, 0, 40)}
		)
		hideTween:Play()
		hideTween.Completed:Connect(function()
			notification:Destroy()
		end)
	end

	return totalResult
end

-- Show path choices
local function showPathChoices(choices)
	PathSelectionContainer.Visible = true
	RemainingStepsText.Text = "Steps: " .. remainingSteps
	wait(0.5) -- Small delay for UI update

	-- Reset buttons
	ForwardButton.Visible = false
	LeftButton.Visible = false
	RightButton.Visible = false

	-- Show available direction buttons
	for _, choice in ipairs(choices) do
		if choice.direction == DIRECTIONS.FRONT then
			ForwardButton.Visible = true
		elseif choice.direction == DIRECTIONS.LEFT then
			LeftButton.Visible = true
		elseif choice.direction == DIRECTIONS.RIGHT then
			RightButton.Visible = true
		end
	end

	currentPathChoices = choices
end

-- Choose path direction
local function choosePath(direction)
	if not currentPathChoices then return end

	-- Hide buttons during movement
	ForwardButton.Visible = false
	LeftButton.Visible = false
	RightButton.Visible = false

	-- Send choice to server
	choosePathEvent:FireServer(direction)

	-- Update remaining steps
	remainingSteps = remainingSteps - 1
	RemainingStepsText.Text = "Steps: " .. remainingSteps

	if remainingSteps <= 0 then
		PathSelectionContainer.Visible = false
	end
end

-- Button event handlers
RollButton.Activated:Connect(function()
	-- Block rolling if crystal movement is active
	if isCrystalMovementActive then
		debugLog("Cannot roll dice during crystal movement")
		return
	end

	if not isRolling and canRoll then
		local diceResult = math.random(1, 6)
		animateDiceRoll(diceResult)
	end
end)

ForwardButton.Activated:Connect(function()
	choosePath(DIRECTIONS.FRONT)
end)

LeftButton.Activated:Connect(function()
	choosePath(DIRECTIONS.LEFT)
end)

RightButton.Activated:Connect(function()
	choosePath(DIRECTIONS.RIGHT)
end)

-- Remote event handlers
showPathSelectionEvent.OnClientEvent:Connect(showPathChoices)

-- IMPROVED: Turn update handler accounts for crystal movement
updateTurnEvent.OnClientEvent:Connect(function(currentPlayerId)
	local isMyTurn = currentPlayerId == player.UserId

	if isMyTurn then
		-- Only show dice UI if not in crystal movement
		if not isCrystalMovementActive then
			showDiceRollUI()
			canRoll = true

			-- Request item permission check
			checkItemUsagePermission()
		else
			debugLog("Not showing dice UI - crystal movement active")
			DiceRollUI.Visible = false
			canRoll = false
		end
	else
		hideDiceRollUI()
		canRoll = false

		-- Reset crystal state if turn ended
		if isCrystalMovementActive then
			isCrystalMovementActive = false
			crystalSteps = 0

			-- Remove crystal effect UI
			for _, child in pairs(PlayerGui:GetChildren()) do
				if child.Name == "CrystalEffect" then
					child:Destroy()
				end
			end
		end
	end
end)

-- NEW: Handle crystal move events
local crystalMoveEvent = boardRemotes:FindFirstChild("CrystalMove")
if crystalMoveEvent then
	crystalMoveEvent.OnClientEvent:Connect(function(steps)
		debugLog("Crystal movement started: " .. steps .. " steps")

		-- Set crystal movement state
		isCrystalMovementActive = true
		crystalSteps = steps

		-- Hide dice UI immediately
		hideDiceRollUI()
		canRoll = false

		-- Create crystal effect UI
		createCrystalEffectUI(steps)
	end)
end

-- NEW: Handle crystal move complete events
if crystalMoveCompleteEvent then
	crystalMoveCompleteEvent.OnClientEvent:Connect(function(playerId)
		-- Check if it's for this player
		if playerId == player.UserId or playerId == nil then
			debugLog("Crystal movement complete event received")

			-- Reset crystal state
			isCrystalMovementActive = false
			crystalSteps = 0

			-- Remove crystal effect UI
			for _, child in pairs(PlayerGui:GetChildren()) do
				if child.Name == "CrystalEffect" then
					child:Destroy()
				end
			end
		end
	end)
end

-- NEW: Handle crystal UI reset
if crystalUIResetEvent then
	crystalUIResetEvent.OnClientEvent:Connect(function()
		debugLog("Crystal UI reset event received")

		-- Reset crystal state
		isCrystalMovementActive = false
		crystalSteps = 0

		-- Remove crystal effect UI
		for _, child in pairs(PlayerGui:GetChildren()) do
			if child.Name == "CrystalEffect" then
				child:Destroy()
			end
		end

		-- Update dice UI based on turn
		local gameManager = _G.GameManager
		local turnSystem = gameManager and gameManager.turnSystem

		if turnSystem and turnSystem:GetCurrentPlayerTurn() == player.UserId then
			showDiceRollUI()
			canRoll = true
		end
	end)
end

-- Dice bonus handler
diceBonusEvent.OnClientEvent:Connect(function(bonusAmount)
	activeDiceBonus = bonusAmount
	debugLog("Received dice bonus: +" .. bonusAmount)

	-- Play notification sound
	local notificationSound = Instance.new("Sound")
	notificationSound.SoundId = "rbxassetid://6026984224"  -- Notification sound
	notificationSound.Volume = 0.5
	notificationSound.Parent = DiceRollUI
	notificationSound:Play()
	game:GetService("Debris"):AddItem(notificationSound, 2)

	-- Create top-right notification
	createBonusNotification(bonusAmount)

	-- Update UI if DiceRollUI is visible
	if DiceRollUI.Visible then
		showDiceRollUI()
	end
end)

-- NEW: Handle item permission updates
if itemPermissionEvent then
	itemPermissionEvent.OnClientEvent:Connect(function(currentTurnPlayerId)
		-- If we received this event with our ID, it's our turn
		if currentTurnPlayerId == player.UserId then
			debugLog("Received item permission update - this is our turn")

			-- If we receive this during our turn and not in crystal movement, show dice UI
			if not isCrystalMovementActive then
				showDiceRollUI()
				canRoll = true
			end
		else
			debugLog("Received item permission update - not our turn")
			hideDiceRollUI()
			canRoll = false
		end
	end)
end

-- Initial setup
DiceRollUI.Visible = false

-- Export the module for other scripts to use
local DiceRollHandler = {}
DiceRollHandler.ShowUI = showDiceRollUI
DiceRollHandler.HideUI = hideDiceRollUI
DiceRollHandler.SignalCrystalMoveComplete = signalCrystalMoveComplete

-- Make accessible to other scripts
_G.DiceRollHandler = DiceRollHandler

return DiceRollHandler
