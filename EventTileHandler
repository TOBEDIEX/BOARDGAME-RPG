-- EventTileHandler.client.lua
-- Manages special tile events on the client side
-- Version: 8.2.0 (แก้ไขให้แสดงการ์ดไอเทมหลังถึงช่องปลายทาง)

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Constants
local MONEY_COLOR = Color3.fromRGB(255, 215, 0)
local SHOP_COLOR = Color3.fromRGB(85, 170, 255)
local BATTLE_COLOR = Color3.fromRGB(255, 80, 80)
local CASINO_COLOR = Color3.fromRGB(220, 120, 255)
local ITEM_COLOR = Color3.fromRGB(100, 255, 100)
local MONEY_RANGE = {500, 2000}
local DELAY_BEFORE_UI = 0.5
local NOTIFY_DURATION = 3

-- Get local player
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- State variables
local state = {
	pendingMoneyTile = false,
	pendingItemTile = false, -- เพิ่มตัวแปรสถานะสำหรับช่องไอเทม
	moneyAmount = 0,
	lastTileId = nil,
	lastTileType = nil,
	isMakingPathChoice = false,
	isMoving = false,
	hasReachedEndTile = false,
	isProcessingEvent = false
}

-- Remote events (initialized in initRemotes function)
local remotes, eventTileRemotes, moneyEventRemote, itemEventRemote
local uiRemotes, statChangedEvent
local boardRemotes, tileTriggerEvent, playerArrivedAtTile, movementVisualizationComplete
local showPathSelection, startPlayerMovementPath, activityComplete

-- Helper functions
local function tweenUI(obj, duration, properties, style, direction, onComplete)
	style = style or Enum.EasingStyle.Quad
	direction = direction or Enum.EasingDirection.Out

	local tween = TweenService:Create(
		obj, 
		TweenInfo.new(duration, style, direction), 
		properties
	)

	if onComplete then tween.Completed:Connect(onComplete) end
	tween:Play()
	return tween
end

local function playSound(parent, soundId, volume)
	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	sound.Volume = volume or 0.5
	sound.Parent = parent
	sound:Play()
	return sound
end

-- Initialize all remote events
local function initRemotes()
	-- Event Tile Remotes
	remotes = ReplicatedStorage:WaitForChild("Remotes")
	eventTileRemotes = remotes:FindFirstChild("EventTileRemotes")
	if not eventTileRemotes then
		eventTileRemotes = Instance.new("Folder")
		eventTileRemotes.Name = "EventTileRemotes"
		eventTileRemotes.Parent = remotes
	end

	moneyEventRemote = eventTileRemotes:FindFirstChild("MoneyEvent")
	if not moneyEventRemote then
		moneyEventRemote = Instance.new("RemoteEvent")
		moneyEventRemote.Name = "MoneyEvent"
		moneyEventRemote.Parent = eventTileRemotes
	end

	itemEventRemote = eventTileRemotes:FindFirstChild("ItemEvent")
	if not itemEventRemote then
		itemEventRemote = Instance.new("RemoteEvent")
		itemEventRemote.Name = "ItemEvent"
		itemEventRemote.Parent = eventTileRemotes
	end

	-- UI Remotes
	uiRemotes = remotes:WaitForChild("UIRemotes")
	statChangedEvent = uiRemotes:FindFirstChild("StatChanged")

	-- Board Remotes
	boardRemotes = remotes:WaitForChild("BoardRemotes")
	tileTriggerEvent = boardRemotes:WaitForChild("TileTriggerEvent")
	playerArrivedAtTile = boardRemotes:WaitForChild("PlayerArrivedAtTile")
	movementVisualizationComplete = boardRemotes:FindFirstChild("MovementVisualizationComplete")
	showPathSelection = boardRemotes:FindFirstChild("ShowPathSelection")
	startPlayerMovementPath = boardRemotes:FindFirstChild("StartPlayerMovementPath")
	activityComplete = boardRemotes:FindFirstChild("ActivityComplete")
end

-- Create notification
local function createNotification(message, duration, color)
	duration = duration or NOTIFY_DURATION
	color = color or MONEY_COLOR

	local notification = Instance.new("Frame")
	notification.Name = "MoneyNotification"
	notification.Size = UDim2.new(0, 280, 0, 60)
	notification.Position = UDim2.new(0.5, 0, -0.2, 0)
	notification.AnchorPoint = Vector2.new(0.5, 0)
	notification.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	notification.BackgroundTransparency = 0.2
	notification.BorderSizePixel = 0

	-- Add UI Elements
	local corner = Instance.new("UICorner", notification)
	corner.CornerRadius = UDim.new(0, 8)

	local icon = Instance.new("ImageLabel", notification)
	icon.Name = "Icon"
	icon.Size = UDim2.new(0, 32, 0, 32)
	icon.Position = UDim2.new(0, 14, 0.5, 0)
	icon.AnchorPoint = Vector2.new(0, 0.5)
	icon.BackgroundTransparency = 1
	icon.Image = "rbxassetid://3354536235" -- Coin icon

	local textLabel = Instance.new("TextLabel", notification)
	textLabel.Name = "Message"
	textLabel.Size = UDim2.new(1, -60, 1, 0)
	textLabel.Position = UDim2.new(0, 56, 0, 0)
	textLabel.BackgroundTransparency = 1
	textLabel.Text = message
	textLabel.Font = Enum.Font.GothamSemibold
	textLabel.TextSize = 16
	textLabel.TextColor3 = color
	textLabel.TextXAlignment = Enum.TextXAlignment.Left
	textLabel.TextWrapped = true

	notification.Parent = PlayerGui

	-- Show and hide notification
	tweenUI(notification, 0.5, {Position = UDim2.new(0.5, 0, 0.05, 0)}, Enum.EasingStyle.Back, Enum.EasingDirection.Out)

	task.delay(duration, function()
		tweenUI(notification, 0.5, {Position = UDim2.new(0.5, 0, -0.2, 0)}, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 
		function() 
			notification:Destroy() 
		end)
	end)

	return notification
end

-- Find UI MedievalMoneyRandomizer
local function findMoneyRandomizerUI()
	-- Look directly in PlayerGui
	local moneyUI = PlayerGui:FindFirstChild("MedievalMoneyRandomizer")
	if moneyUI then return moneyUI end

	-- Look in all ScreenGuis
	for _, gui in pairs(PlayerGui:GetChildren()) do
		if gui:IsA("ScreenGui") then
			moneyUI = gui:FindFirstChild("MedievalMoneyRandomizer")
			if moneyUI then return moneyUI end

			-- Look in child frames
			for _, child in pairs(gui:GetDescendants()) do
				if child:IsA("Frame") and child.Name == "MedievalMoneyRandomizer" then
					return child
				end
			end
		end
	end
	return nil
end

-- Play card reveal animation
local function playCardRevealAnimation(frame, onComplete)
	if not frame then 
		if onComplete then onComplete() end
		return 
	end

	-- Store original values
	local originalRotation = frame.Rotation or 0
	local originalSize = frame.Size
	local originalPosition = frame.Position
	local originalTransparency = frame.BackgroundTransparency or 0

	-- Create card back
	local cardBack = Instance.new("Frame")
	cardBack.Name = "CardBack"
	cardBack.Size = originalSize
	cardBack.Position = originalPosition
	cardBack.AnchorPoint = frame.AnchorPoint
	cardBack.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
	cardBack.ZIndex = frame.ZIndex + 1
	cardBack.Parent = frame.Parent

	-- Add design elements
	local pattern = Instance.new("ImageLabel")
	pattern.Name = "CardPattern"
	pattern.Size = UDim2.fromScale(0.8, 0.8)
	pattern.Position = UDim2.fromScale(0.5, 0.5)
	pattern.AnchorPoint = Vector2.new(0.5, 0.5)
	pattern.BackgroundTransparency = 1
	pattern.Image = "rbxassetid://6127039592"
	pattern.ImageColor3 = Color3.fromRGB(255, 220, 220)
	pattern.ImageTransparency = 0.7
	pattern.ZIndex = cardBack.ZIndex + 1
	pattern.Parent = cardBack

	local border = Instance.new("UIStroke")
	border.Color = Color3.fromRGB(255, 215, 0)
	border.Thickness = 3
	border.Parent = cardBack

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = cardBack

	-- Hide main frame
	frame.Visible = false

	-- Set starting position
	cardBack.Rotation = 180
	cardBack.Size = UDim2.new(
		originalSize.X.Scale, originalSize.X.Offset * 0.8,
		originalSize.Y.Scale, originalSize.Y.Offset * 0.8
	)

	-- Play card flip sound
	playSound(cardBack, "rbxassetid://6732897163", 0.5)

	-- Card shuffle animation
	local numShuffle = 5
	local shuffleDelay = 0.1

	for i = 1, numShuffle do
		task.delay(i * shuffleDelay, function()
			local offsetX = math.random(-10, 10)
			local offsetY = math.random(-10, 10)

			tweenUI(cardBack, shuffleDelay, {
				Position = UDim2.new(
					originalPosition.X.Scale, originalPosition.X.Offset + offsetX,
					originalPosition.Y.Scale, originalPosition.Y.Offset + offsetY
				),
				Rotation = originalRotation + math.random(-15, 15)
			})
		end)
	end

	-- Flip card after shuffle
	task.delay(numShuffle * shuffleDelay + 0.2, function()
		-- Return to original position
		tweenUI(cardBack, 0.3, {
			Position = originalPosition,
			Rotation = 0
		}, Enum.EasingStyle.Back, Enum.EasingDirection.Out, function()
			-- Play card flip sound
			playSound(cardBack, "rbxassetid://5852130173", 0.7)

			-- Card disappear animation
			tweenUI(cardBack, 0.4, {
				Size = UDim2.new(
					originalSize.X.Scale, originalSize.X.Offset * 0.1,
					originalSize.Y.Scale, originalSize.Y.Offset
				),
				Rotation = 90
			}, Enum.EasingStyle.Back, Enum.EasingDirection.In, function()
				-- Remove card back
				cardBack:Destroy()

				-- Show front card
				frame.Visible = true
				frame.Rotation = 90
				frame.Size = UDim2.new(
					originalSize.X.Scale, originalSize.X.Offset * 0.1,
					originalSize.Y.Scale, originalSize.Y.Offset
				)

				-- Front card reveal animation
				tweenUI(frame, 0.4, {
					Rotation = 0,
					Size = originalSize,
					BackgroundTransparency = originalTransparency
				}, Enum.EasingStyle.Back, Enum.EasingDirection.Out, function()
					-- Play sparkle sound
					playSound(frame, "rbxassetid://5852296378", 0.5)

					-- Create sparkle effects
					for i = 1, 8 do
						task.delay(i * 0.05, function()
							local sparkle = Instance.new("Frame")
							sparkle.Name = "Sparkle" .. i
							sparkle.Size = UDim2.fromOffset(5, 5)
							sparkle.Position = UDim2.fromScale(math.random(), math.random())
							sparkle.AnchorPoint = Vector2.new(0.5, 0.5)
							sparkle.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
							sparkle.BackgroundTransparency = 0
							sparkle.ZIndex = frame.ZIndex + 5

							local corner = Instance.new("UICorner")
							corner.CornerRadius = UDim.new(1, 0)
							corner.Parent = sparkle

							sparkle.Parent = frame

							tweenUI(sparkle, 0.5, {
								Size = UDim2.fromOffset(20, 20),
								Position = UDim2.fromScale(0.5, 0.5),
								BackgroundTransparency = 1
							}, nil, nil, function()
								sparkle:Destroy()
								if i == 8 and onComplete then onComplete() end
							end)
						end)
					end
				end)
			end)
		end)
	end)
end

-- Get random money amount
local function getRandomMoneyAmount()
	return math.random(MONEY_RANGE[1], MONEY_RANGE[2])
end

-- Show money animation with existing UI
local function showMoneyAnimation(amount)
	-- Find UI
	local moneyUI = findMoneyRandomizerUI()
	if not moneyUI then
		createNotification("You received " .. amount .. " coins!", NOTIFY_DURATION, MONEY_COLOR)
		moneyEventRemote:FireServer("updateMoney", amount)
		return
	end

	-- Find MainFrame
	local mainFrame
	if moneyUI:IsA("Frame") then
		mainFrame = moneyUI
	else
		mainFrame = moneyUI:FindFirstChild("MainFrame")
		if not mainFrame then
			for _, child in pairs(moneyUI:GetDescendants()) do
				if child:IsA("Frame") and (child.Name == "MainFrame" or child.Name:find("Main")) then
					mainFrame = child
					break
				end
			end
		end
	end

	if not mainFrame then
		createNotification("You received " .. amount .. " coins!", NOTIFY_DURATION, MONEY_COLOR)
		moneyEventRemote:FireServer("updateMoney", amount)
		return
	end

	-- Find CoinAmount
	local coinAmount
	local coinDisplay = mainFrame:FindFirstChild("CoinDisplay")

	if coinDisplay then
		coinAmount = coinDisplay:FindFirstChild("CoinAmount")
	else
		for _, child in pairs(mainFrame:GetDescendants()) do
			if child:IsA("TextLabel") and (
				child.Name == "CoinAmount" or 
					child.Name:find("Amount") or 
					child.Name:find("Money") or
					child.Name:find("Coin")
				) then
				coinAmount = child
				break
			end
		end
	end

	if not coinAmount then
		createNotification("You received " .. amount .. " coins!", NOTIFY_DURATION, MONEY_COLOR)
		moneyEventRemote:FireServer("updateMoney", amount)
		return
	end

	-- Find close button
	local closeButton
	for _, child in pairs(mainFrame:GetDescendants()) do
		if child:IsA("TextButton") and (
			child.Name:find("Close") or 
				child.Name:find("Accept") or 
				child.Name:find("OK") or
				child.Name:find("Button") or
				child.Name:find("Confirm")
			) then
			closeButton = child
			break
		end
	end

	-- Show UI and start animation
	moneyUI.Enabled = true

	local originalTextSize = coinAmount.TextSize
	coinAmount.Text = "0"

	playCardRevealAnimation(mainFrame, function()
		-- Coin sound
		playSound(mainFrame, "rbxassetid://131323304", 0.5)

		-- Animate coin counting
		local countDuration = 2
		local startTime = tick()

		local function easeOutQuart(t)
			return 1 - (1 - t)^4
		end

		local countConnection
		countConnection = RunService.RenderStepped:Connect(function()
			local elapsed = tick() - startTime
			local progress = math.min(elapsed / countDuration, 1)

			local easedProgress = easeOutQuart(progress)
			local currentValue = math.floor(easedProgress * amount)

			coinAmount.Text = tostring(currentValue)

			if progress >= 1 then
				countConnection:Disconnect()

				-- Play coin sound again
				playSound(mainFrame, "rbxassetid://131323304", 0.7)

				-- Show completion effect
				tweenUI(coinAmount, 0.3, {TextSize = originalTextSize * 1.3}, Enum.EasingStyle.Back, Enum.EasingDirection.Out)

				task.delay(0.3, function()
					tweenUI(coinAmount, 0.2, {TextSize = originalTextSize})
				end)

				-- Update money
				moneyEventRemote:FireServer("updateMoney", amount)

				-- Auto close if no close button
				if not closeButton then
					task.delay(5, function()
						mainFrame.Visible = false
					end)
				end
			end
		end)
	end)

	-- Close UI when button clicked
	if closeButton and not closeButton:GetAttribute("Connected") then
		closeButton.MouseButton1Click:Connect(function()
			mainFrame.Visible = false
		end)
		closeButton:SetAttribute("Connected", true)
	end
end

-- Check if reached end tile
local function checkEndTile()
	-- Prevent processing overlap
	if state.isProcessingEvent then 
		return 
	end

	-- Check conditions
	if state.isMoving then
		return
	end

	if not state.hasReachedEndTile then
		return
	end

	-- Process pending money tile
	if state.pendingMoneyTile then
		state.isProcessingEvent = true
		state.pendingMoneyTile = false

		-- Get random money
		state.moneyAmount = getRandomMoneyAmount()

		-- Show notification and UI
		createNotification("Reached end tile! Received " .. state.moneyAmount .. " coins", NOTIFY_DURATION)

		task.delay(DELAY_BEFORE_UI, function()
			showMoneyAnimation(state.moneyAmount)
			state.isProcessingEvent = false
		end)
	elseif state.pendingItemTile then  -- ตรวจสอบสถานะช่องไอเทม
		state.isProcessingEvent = true
		state.pendingItemTile = false

		-- Show notification
		createNotification("Reached end tile! Getting random item...", NOTIFY_DURATION, ITEM_COLOR)

		task.delay(DELAY_BEFORE_UI, function()
			-- ขอไอเทมจากเซิร์ฟเวอร์
			itemEventRemote:FireServer("giveRandomItem")
			state.isProcessingEvent = false
		end)
	end

	state.hasReachedEndTile = false
end

-- Set up event connections
local function setupConnections()
	-- Money event
	moneyEventRemote.OnClientEvent:Connect(function(amount)
		if amount and amount > 0 then
			createNotification("Received " .. amount .. " coins", NOTIFY_DURATION, MONEY_COLOR)
			showMoneyAnimation(amount)
		end
	end)

	-- Start movement
	startPlayerMovementPath.OnClientEvent:Connect(function(playerId, movementData)
		if playerId ~= player.UserId then return end

		state.isMoving = true
		state.hasReachedEndTile = false
	end)

	-- Arrived at tile
	playerArrivedAtTile.OnClientEvent:Connect(function(playerId, finalTileId)
		if playerId ~= player.UserId then return end

		state.lastTileId = finalTileId
		state.isMakingPathChoice = false
	end)

	-- Path selection
	if showPathSelection then
		showPathSelection.OnClientEvent:Connect(function()
			state.isMakingPathChoice = true
		end)
	end

	-- Movement complete
	if movementVisualizationComplete then
		movementVisualizationComplete.OnClientEvent:Connect(function(finalTileId)
			state.lastTileId = finalTileId
			state.isMoving = false
			state.hasReachedEndTile = true
			state.isMakingPathChoice = false

			task.delay(DELAY_BEFORE_UI, checkEndTile)
		end)
	end

	-- Activity complete
	if activityComplete then
		activityComplete.OnClientEvent:Connect(function(activityType)
			if activityType == "movement" or activityType == "turn" then
				state.isMoving = false
				state.hasReachedEndTile = true
				checkEndTile()
			end
		end)
	end

	-- Tile trigger
	tileTriggerEvent.OnClientEvent:Connect(function(playerId, tileId, tileType)
		if playerId ~= player.UserId then return end

		state.lastTileId = tileId
		state.lastTileType = tileType

		if state.isMakingPathChoice then
			return
		end

		-- Show notifications based on tile type
		if tileType == "money" then
			createNotification("You landed on a money tile! Coins will be awarded when you reach the end tile", 2, MONEY_COLOR)
			state.pendingMoneyTile = true
		elseif tileType == "shop" then
			createNotification("You landed on a shop tile", 2, SHOP_COLOR)
		elseif tileType == "battle" then
			createNotification("You landed on a battle tile! Prepare to fight", 2, BATTLE_COLOR)
		elseif tileType == "casino" then
			createNotification("You landed on a casino tile! Try your luck?", 2, CASINO_COLOR)
		elseif tileType == "item" then
			createNotification("You landed on an item tile! Item will be given when you reach the end tile", 2, ITEM_COLOR)
			state.pendingItemTile = true  -- ตั้งค่าสถานะรอรับไอเทม
		end
	end)

	-- Detect path selection
	task.spawn(function()
		local PlayerGui = player:WaitForChild("PlayerGui")
		local PopupUI = PlayerGui:WaitForChild("PopupUI", 10)
		if PopupUI then
			local DiceRollUI = PopupUI:WaitForChild("DiceRollUI", 10)
			if DiceRollUI then
				local PathSelectionContainer = DiceRollUI:WaitForChild("PathSelectionContainer", 10)
				if PathSelectionContainer then
					PathSelectionContainer:GetPropertyChangedSignal("Visible"):Connect(function()
						state.isMakingPathChoice = PathSelectionContainer.Visible
					end)
				end
			end
		end
	end)

	-- Detect actual character movement
	task.spawn(function()
		while true do
			task.wait(0.5) -- Check every 0.5 seconds

			local character = player.Character
			if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") then
				local humanoid = character:FindFirstChild("Humanoid")

				-- Check movement state
				if humanoid.MoveDirection.Magnitude > 0 then
					if not state.isMoving then
						state.isMoving = true
						state.hasReachedEndTile = false
					end
				else
					if state.isMoving then
						state.isMoving = false

						task.delay(DELAY_BEFORE_UI, function()
							if (state.pendingMoneyTile or state.pendingItemTile) and not state.isMoving then
								state.hasReachedEndTile = true
								checkEndTile()
							end
						end)
					end
				end
			end
		end
	end)
end

-- เพิ่มฟังก์ชันสำหรับเรียกใช้งานจากภายนอก (เปลี่ยนจากการใช้ HandleItemTile โดยตรง)
local function notifyItemTile()
	-- เพิ่มเข้าคิวรอ
	state.pendingItemTile = true
	createNotification("You landed on an item tile! Item will be given when you reach the end tile", 2, ITEM_COLOR)

	-- ถ้าไม่กำลังเคลื่อนที่และถึงช่องปลายทางแล้ว ให้แสดงทันที (กรณีมีการเรียกโดยตรงจากคำสั่งในเซิร์ฟเวอร์)
	if not state.isMoving then
		state.hasReachedEndTile = true
		checkEndTile()
	end
end

-- สร้างฟังก์ชันเดิมเพื่อความเข้ากันได้กับโค้ดเดิม
_G.HandleItemTile = notifyItemTile

-- Initialize system
local function initialize()
	initRemotes()
	setupConnections()
end

-- Start system
initialize()
