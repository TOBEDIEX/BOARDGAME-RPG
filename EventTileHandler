-- EventTileHandler.client.lua
-- Handles special tile events on the client-side with animations.
-- Version: 6.1.0 - Concise

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Constants
local NOTIFICATION_DURATION = 3
local MONEY_COLOR = Color3.fromRGB(255, 215, 0)
local SHOP_COLOR = Color3.fromRGB(85, 170, 255)
local BATTLE_COLOR = Color3.fromRGB(255, 80, 80)
local CASINO_COLOR = Color3.fromRGB(220, 120, 255)
local ITEM_COLOR = Color3.fromRGB(100, 255, 100)
local MIN_MONEY_AMOUNT = 500
local MAX_MONEY_AMOUNT = 2000
local DELAY_BEFORE_UI = 0.5
local MOVEMENT_CHECK_INTERVAL = 0.5

-- Get local player
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- State variables
local pendingMoneyTile = false
local moneyAmount = 0
local lastTileId = nil
local lastTileType = nil
local isMakingPathChoice = false
local isMoving = false
local hasReachedEndTile = false
local isProcessingEvent = false

-- Remote events
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local eventTileRemotes = remotes:WaitForChild("EventTileRemotes")
local moneyEventRemote = eventTileRemotes:WaitForChild("MoneyEvent")
local uiRemotes = remotes:WaitForChild("UIRemotes")
local statChangedEvent = uiRemotes:FindFirstChild("StatChanged") -- Assuming this might be needed later
local boardRemotes = remotes:WaitForChild("BoardRemotes")
local tileTriggerEvent = boardRemotes:WaitForChild("TileTriggerEvent")
local playerArrivedAtTile = boardRemotes:WaitForChild("PlayerArrivedAtTile")
local movementVisualizationComplete = boardRemotes:FindFirstChild("MovementVisualizationComplete")
local showPathSelection = boardRemotes:FindFirstChild("ShowPathSelection")
local startPlayerMovementPath = boardRemotes:WaitForChild("StartPlayerMovementPath")
local activityComplete = boardRemotes:FindFirstChild("ActivityComplete")

-- Forward declaration of functions
local createNotification, findMoneyRandomizerUI, showMoneyAnimationWithExistingUI
local playCardRevealAnimation, getRandomMoneyAmount, checkEndTile

-- Creates a temporary on-screen notification.
function createNotification(message, duration, color)
	duration = duration or NOTIFICATION_DURATION
	color = color or MONEY_COLOR

	local notification = Instance.new("Frame")
	notification.Name = "EventNotification"
	notification.Size = UDim2.new(0, 280, 0, 60)
	notification.Position = UDim2.new(0.5, 0, 0.1, 0)
	notification.AnchorPoint = Vector2.new(0.5, 0)
	notification.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	notification.BackgroundTransparency = 0.2
	notification.BorderSizePixel = 0
	notification.ZIndex = 10 -- Ensure it's visible

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = notification

	local icon = Instance.new("ImageLabel")
	icon.Name = "Icon"
	icon.Size = UDim2.new(0, 32, 0, 32)
	icon.Position = UDim2.new(0, 14, 0.5, 0)
	icon.AnchorPoint = Vector2.new(0, 0.5)
	icon.BackgroundTransparency = 1
	icon.Image = "rbxassetid://3354536235" -- Coin icon
	icon.Parent = notification

	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "Message"
	textLabel.Size = UDim2.new(1, -60, 1, 0)
	textLabel.Position = UDim2.new(0, 56, 0, 0)
	textLabel.BackgroundTransparency = 1
	textLabel.Text = message
	textLabel.Font = Enum.Font.GothamSemibold
	textLabel.TextSize = 16
	textLabel.TextColor3 = color
	textLabel.TextXAlignment = Enum.TextXAlignment.Left
	textLabel.TextWrapped = true
	textLabel.Parent = notification

	notification.Parent = PlayerGui

	-- Animate in
	notification.Position = UDim2.new(0.5, 0, -0.2, 0)
	TweenService:Create(
		notification,
		TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{Position = UDim2.new(0.5, 0, 0.05, 0)}
	):Play()

	-- Animate out and destroy
	task.delay(duration, function()
		if not notification or not notification.Parent then return end
		TweenService:Create(
			notification,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{Position = UDim2.new(0.5, 0, -0.2, 0)}
		):Play()
		task.delay(0.5, function()
			if notification and notification.Parent then
				notification:Destroy()
			end
		end)
	end)
end

-- Plays a card shuffling and revealing animation on a given frame.
function playCardRevealAnimation(frame, onComplete)
	if not frame then
		if onComplete then task.spawn(onComplete) end
		return
	end

	local originalRotation = frame.Rotation or 0
	local originalSize = frame.Size
	local originalPosition = frame.Position
	local originalTransparency = frame.BackgroundTransparency or 0

	-- Create card back visual
	local cardBack = Instance.new("Frame")
	cardBack.Name = "CardBack"
	cardBack.Size = originalSize
	cardBack.Position = originalPosition
	cardBack.AnchorPoint = frame.AnchorPoint
	cardBack.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
	cardBack.ZIndex = frame.ZIndex + 1
	cardBack.Parent = frame.Parent

	local pattern = Instance.new("ImageLabel")
	pattern.Name = "CardPattern"
	pattern.Size = UDim2.fromScale(0.8, 0.8)
	pattern.Position = UDim2.fromScale(0.5, 0.5)
	pattern.AnchorPoint = Vector2.new(0.5, 0.5)
	pattern.BackgroundTransparency = 1
	pattern.Image = "rbxassetid://6127039592"
	pattern.ImageColor3 = Color3.fromRGB(255, 220, 220)
	pattern.ImageTransparency = 0.7
	pattern.ZIndex = cardBack.ZIndex + 1
	pattern.Parent = cardBack

	local border = Instance.new("UIStroke")
	border.Color = Color3.fromRGB(255, 215, 0)
	border.Thickness = 3
	border.Parent = cardBack

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = cardBack

	frame.Visible = false
	cardBack.Rotation = 180
	cardBack.Size = UDim2.new(
		originalSize.X.Scale, originalSize.X.Offset * 0.8,
		originalSize.Y.Scale, originalSize.Y.Offset * 0.8
	)

	local cardSound = Instance.new("Sound", cardBack)
	cardSound.SoundId = "rbxassetid://6732897163"
	cardSound.Volume = 0.5
	cardSound:Play()

	-- Shuffle animation
	local numShuffle = 5
	local shuffleDelay = 0.1
	for i = 1, numShuffle do
		task.delay(i * shuffleDelay, function()
			if not cardBack or not cardBack.Parent then return end
			local offsetX = math.random(-10, 10)
			local offsetY = math.random(-10, 10)
			TweenService:Create(
				cardBack,
				TweenInfo.new(shuffleDelay, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{
					Position = UDim2.new(
						originalPosition.X.Scale, originalPosition.X.Offset + offsetX,
						originalPosition.Y.Scale, originalPosition.Y.Offset + offsetY
					),
					Rotation = originalRotation + math.random(-15, 15)
				}
			):Play()
		end)
	end

	-- Flip animation sequence
	task.delay(numShuffle * shuffleDelay + 0.2, function()
		if not cardBack or not cardBack.Parent then return end
		local resetTween = TweenService:Create(
			cardBack,
			TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
			{ Position = originalPosition, Rotation = 0 }
		)
		resetTween:Play()

		resetTween.Completed:Connect(function()
			if not cardBack or not cardBack.Parent then return end
			local flipSound = Instance.new("Sound", cardBack)
			flipSound.SoundId = "rbxassetid://5852130173"
			flipSound.Volume = 0.7
			flipSound:Play()

			local flipTween = TweenService:Create(
				cardBack,
				TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In),
				{
					Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset * 0.1, originalSize.Y.Scale, originalSize.Y.Offset),
					Rotation = 90
				}
			)
			flipTween:Play()

			flipTween.Completed:Connect(function()
				cardBack:Destroy()
				if not frame or not frame.Parent then return end -- Check if frame still exists

				frame.Visible = true
				frame.Rotation = 90
				frame.Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset * 0.1, originalSize.Y.Scale, originalSize.Y.Offset)

				local revealTween = TweenService:Create(
					frame,
					TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
					{ Rotation = 0, Size = originalSize, BackgroundTransparency = originalTransparency }
				)
				revealTween:Play()

				revealTween.Completed:Connect(function()
					if not frame or not frame.Parent then return end
					local sparkleSound = Instance.new("Sound", frame)
					sparkleSound.SoundId = "rbxassetid://5852296378"
					sparkleSound.Volume = 0.5
					sparkleSound:Play()

					-- Sparkle effect
					for i = 1, 8 do
						task.delay(i * 0.05, function()
							if not frame or not frame.Parent then return end
							local sparkle = Instance.new("Frame")
							sparkle.Name = "Sparkle" .. i
							sparkle.Size = UDim2.fromOffset(5, 5)
							sparkle.Position = UDim2.fromScale(math.random(), math.random())
							sparkle.AnchorPoint = Vector2.new(0.5, 0.5)
							sparkle.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
							sparkle.BackgroundTransparency = 0
							sparkle.ZIndex = frame.ZIndex + 5
							sparkle.Parent = frame

							local corner = Instance.new("UICorner", sparkle)
							corner.CornerRadius = UDim.new(1, 0)

							local sparkTween = TweenService:Create(
								sparkle,
								TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
								{ Size = UDim2.fromOffset(20, 20), Position = UDim2.fromScale(0.5, 0.5), BackgroundTransparency = 1 }
							)
							sparkTween:Play()
							sparkTween.Completed:Connect(function()
								sparkle:Destroy()
								if i == 8 and onComplete then
									task.spawn(onComplete) -- Use task.spawn for safety
								end
							end)
						end)
					end
				end)
			end)
		end)
	end)
end

-- Finds the existing money randomizer UI.
function findMoneyRandomizerUI()
	local moneyUI = PlayerGui:FindFirstChild("MedievalMoneyRandomizer")
	if moneyUI then return moneyUI end

	for _, gui in pairs(PlayerGui:GetChildren()) do
		if gui:IsA("ScreenGui") then
			moneyUI = gui:FindFirstChild("MedievalMoneyRandomizer")
			if moneyUI then return moneyUI end
			for _, child in pairs(gui:GetDescendants()) do
				if child:IsA("Frame") and child.Name == "MedievalMoneyRandomizer" then
					return child
				end
			end
		end
	end
	return nil
end

-- Generates a random amount of money within the defined range.
function getRandomMoneyAmount()
	return math.random(MIN_MONEY_AMOUNT, MAX_MONEY_AMOUNT)
end

-- Shows the money gain animation using an existing UI element.
function showMoneyAnimationWithExistingUI(amount)
	local moneyUI = findMoneyRandomizerUI()

	if not moneyUI then
		createNotification("You received " .. amount .. " coins!", 3, MONEY_COLOR)
		moneyEventRemote:FireServer("updateMoney", amount)
		return
	end

	local mainFrame = moneyUI:IsA("Frame") and moneyUI or moneyUI:FindFirstChildWhichIsA("Frame", true) -- Find first frame descendant recursively

	if not mainFrame then
		createNotification("You received " .. amount .. " coins!", 3, MONEY_COLOR)
		moneyEventRemote:FireServer("updateMoney", amount)
		return
	end

	local coinAmount
	for _, child in pairs(mainFrame:GetDescendants()) do
		if child:IsA("TextLabel") and (child.Name:find("Amount") or child.Name:find("Money") or child.Name:find("Coin")) then
			coinAmount = child
			break
		end
	end

	if not coinAmount then
		createNotification("You received " .. amount .. " coins!", 3, MONEY_COLOR)
		moneyEventRemote:FireServer("updateMoney", amount)
		return
	end

	local closeButton
	for _, child in pairs(mainFrame:GetDescendants()) do
		if child:IsA("TextButton") and (child.Name:find("Close") or child.Name:find("Accept") or child.Name:find("OK") or child.Name:find("Confirm") or child.Name:find("Button")) then
			closeButton = child
			break
		end
	end

	moneyUI.Enabled = true
	mainFrame.Visible = true -- Ensure frame is visible

	local originalTextSize = coinAmount.TextSize
	coinAmount.Text = "0"

	playCardRevealAnimation(mainFrame, function()
		if not mainFrame or not mainFrame.Parent or not coinAmount or not coinAmount.Parent then return end

		local coinSound = Instance.new("Sound", mainFrame)
		coinSound.SoundId = "rbxassetid://131323304"
		coinSound.Volume = 0.5
		coinSound:Play()

		local countDuration = 2
		local startTime = tick()
		local startValue = 0
		local targetValue = amount
		local function easeOutQuart(t) return 1 - (1 - t)^4 end

		local countConnection
		countConnection = RunService.RenderStepped:Connect(function()
			if not coinAmount or not coinAmount.Parent then
				if countConnection then countConnection:Disconnect() end
				return
			end

			local elapsed = tick() - startTime
			local progress = math.min(elapsed / countDuration, 1)
			local easedProgress = easeOutQuart(progress)
			local currentValue = math.floor(startValue + easedProgress * (targetValue - startValue))
			coinAmount.Text = tostring(currentValue)

			if progress >= 1 then
				countConnection:Disconnect()
				coinAmount.Text = tostring(targetValue) -- Ensure final value is exact

				if mainFrame and mainFrame.Parent then
					local finalCoinSound = Instance.new("Sound", mainFrame)
					finalCoinSound.SoundId = "rbxassetid://131323304"
					finalCoinSound.Volume = 0.7
					finalCoinSound:Play()
				end

				TweenService:Create(coinAmount, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {TextSize = originalTextSize * 1.3}):Play()
				task.delay(0.3, function()
					if coinAmount and coinAmount.Parent then
						TweenService:Create(coinAmount, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {TextSize = originalTextSize}):Play()
					end
				end)

				moneyEventRemote:FireServer("updateMoney", amount)

				if not closeButton then
					task.delay(5, function()
						if mainFrame and mainFrame.Parent then mainFrame.Visible = false end
					end)
				end
			end
		end)
	end)

	if closeButton and not closeButton:GetAttribute("Connected") then
		closeButton.MouseButton1Click:Connect(function()
			if mainFrame and mainFrame.Parent then mainFrame.Visible = false end
		end)
		closeButton:SetAttribute("Connected", true)
	end
end

-- Checks if the player has reached the destination tile and handles pending events.
function checkEndTile()
	if isProcessingEvent or isMoving or not hasReachedEndTile then
		return
	end

	if pendingMoneyTile then
		isProcessingEvent = true
		pendingMoneyTile = false
		moneyAmount = getRandomMoneyAmount()
		createNotification("Reached the end tile! Received " .. moneyAmount .. " coins", 3)

		task.delay(DELAY_BEFORE_UI, function()
			showMoneyAnimationWithExistingUI(moneyAmount)
			isProcessingEvent = false
		end)
	end

	hasReachedEndTile = false -- Reset after processing
end

-- Sets up connections to remote events and other signals.
local function setupConnections()
	-- Listen for money events (primarily as a fallback or for specific server pushes)
	moneyEventRemote.OnClientEvent:Connect(function(amount)
		if amount and amount > 0 then
			createNotification("Received " .. amount .. " coins!", 3, MONEY_COLOR)
			showMoneyAnimationWithExistingUI(amount)
		end
	end)

	-- Track movement start
	startPlayerMovementPath.OnClientEvent:Connect(function(playerId)
		if playerId == player.UserId then
			isMoving = true
			hasReachedEndTile = false
		end
	end)

	-- Track arrival confirmation from server
	playerArrivedAtTile.OnClientEvent:Connect(function(playerId, finalTileId)
		if playerId == player.UserId then
			lastTileId = finalTileId
			isMakingPathChoice = false
			-- Don't set hasReachedEndTile here, wait for visualization complete
		end
	end)

	-- Track path selection UI visibility
	if showPathSelection then
		showPathSelection.OnClientEvent:Connect(function()
			isMakingPathChoice = true
		end)
	end

	-- Track movement visualization completion
	if movementVisualizationComplete then
		movementVisualizationComplete.OnClientEvent:Connect(function(finalTileId)
			if lastTileId == finalTileId then -- Ensure it matches the expected final tile
				isMoving = false
				hasReachedEndTile = true
				isMakingPathChoice = false
				task.delay(DELAY_BEFORE_UI, checkEndTile)
			end
		end)
	end

	-- Track general activity completion (alternative trigger for end of movement)
	if activityComplete then
		activityComplete.OnClientEvent:Connect(function(activityType)
			if activityType == "movement" or activityType == "turn" then
				isMoving = false
				hasReachedEndTile = true
				isMakingPathChoice = false
				task.delay(DELAY_BEFORE_UI, checkEndTile)
			end
		end)
	end

	-- Handle landing on different tile types
	tileTriggerEvent.OnClientEvent:Connect(function(playerId, tileId, tileType)
		if playerId ~= player.UserId then return end

		lastTileId = tileId
		lastTileType = tileType

		if isMakingPathChoice then return end -- Skip if choosing path

		if tileType == "money" then
			createNotification("Landed on a money tile! Coins awarded at destination.", 2, MONEY_COLOR)
			pendingMoneyTile = true
		elseif tileType == "shop" then
			createNotification("Landed on a shop tile.", 2, SHOP_COLOR)
		elseif tileType == "battle" then
			createNotification("Landed on a battle tile! Prepare yourself.", 2, BATTLE_COLOR)
		elseif tileType == "casino" then
			createNotification("Landed on a casino tile! Feeling lucky?", 2, CASINO_COLOR)
		elseif tileType == "item" then
			createNotification("Landed on an item tile! Receiving item...", 2, ITEM_COLOR)
		end
	end)

	-- Fallback: Monitor character movement state directly
	task.spawn(function()
		while task.wait(MOVEMENT_CHECK_INTERVAL) do
			local character = player.Character
			local humanoid = character and character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				local isActivelyMoving = humanoid.MoveDirection.Magnitude > 0.1 or humanoid:GetState() == Enum.HumanoidStateType.Running

				if isActivelyMoving then
					if not isMoving then
						isMoving = true
						hasReachedEndTile = false
					end
				else -- Not actively moving
					if isMoving then
						-- Character stopped moving based on Humanoid state
						isMoving = false
						-- Use a small delay before checking end tile, allowing other events to potentially fire first
						task.delay(DELAY_BEFORE_UI * 1.5, function()
							-- Only trigger checkEndTile if no other event has already set hasReachedEndTile
							if not hasReachedEndTile and pendingMoneyTile and not isMoving then
								hasReachedEndTile = true
								checkEndTile()
							end
						end)
					end
				end
			end
		end
	end)

    -- Track PathSelectionContainer visibility as another way to detect path choice state
    task.spawn(function()
        local pathSelectionContainer = PlayerGui:WaitForChild("PopupUI", 10):WaitForChild("DiceRollUI", 10):WaitForChild("PathSelectionContainer", 10)
        if pathSelectionContainer then
            pathSelectionContainer:GetPropertyChangedSignal("Visible"):Connect(function()
                isMakingPathChoice = pathSelectionContainer.Visible
            end)
        end
    end)
end

-- Main initialization function
local function initialize()
	setupConnections()
	print("[EventTileHandler] Concise version initialized.")
end

-- Start the system
initialize()
