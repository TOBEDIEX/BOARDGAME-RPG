-- BoardService.server.lua
-- บริการฝั่งเซิร์ฟเวอร์สำหรับจัดการระบบกระดาน
-- Version: 2.0.0 (Optimized)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- โหลดโมดูลที่จำเป็น
local Modules = ServerStorage:WaitForChild("Modules")
local BoardSystem = require(Modules:WaitForChild("BoardSystem"))
local MapData = require(ServerStorage.GameData.MapData)

-- ตรวจสอบและสร้าง Remote Events ที่จำเป็น
local function ensureRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	local requiredEvents = {
		"RollDice",
		"PlayerArrivedAtTile",
		"ChoosePath",
		"TileTriggerEvent",
		"ActivityComplete",
		"StartPlayerMovementPath"
	}

	for _, eventName in ipairs(requiredEvents) do
		if not boardRemotes:FindFirstChild(eventName) then
			Instance.new("RemoteEvent", boardRemotes).Name = eventName
		end
	end

	-- สร้าง ShowPathSelection เผื่อ Client ยังใช้
	if not boardRemotes:FindFirstChild("ShowPathSelection") then
		Instance.new("RemoteEvent", boardRemotes).Name = "ShowPathSelection"
	end

	return remotes
end

-- Constants
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }

-- รับ GameManager จาก global variable
local function getGameManager()
	local startTime = tick()
	while not _G.GameManager and tick() - startTime < 10 do
		task.wait(0.1)
	end
	return _G.GameManager
end

-- ฟังก์ชันหลักสำหรับเริ่มต้นบริการ
local function initializeBoardService()
	ensureRemoteEvents()
	local boardSystem = BoardSystem.new()

	-- โหลด Map
	if not MapData then 
		boardSystem:LoadMap({tiles={[1]={type="start", position=Vector3.new(0,0,0)}}, connections={}})
	else 
		boardSystem:LoadMap(MapData)
	end

	local gameManager = getGameManager()
	if not gameManager then return end
	gameManager.boardSystem = boardSystem

	-- ตั้งค่า callbacks
	boardSystem:SetupCallbacks(
		-- onPlayerMoved
		function(playerId, fromTileId, toTileId)
			-- เมื่อผู้เล่นเคลื่อนที่จากช่องหนึ่งไปอีกช่องหนึ่ง (Logic)
		end,

		-- onPlayerPathComplete
		function(playerId, finalTileId)
			-- เมื่อผู้เล่นเดินทางครบทุกก้าว
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("PlayerArrivedAtTile"):FireAllClients(playerId, finalTileId)

			task.spawn(function()
				task.wait(0.5)
				if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
					gameManager.turnSystem:EndPlayerTurn(playerId, "move_complete")
				end
			end)
		end,

		-- onTileEffect
		function(playerId, tileId, tileInfo)
			-- เมื่อควรเริ่มเอฟเฟคของช่อง
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("TileTriggerEvent"):FireAllClients(playerId, tileId, tileInfo.type)

			-- ประมวลผลเอฟเฟคของช่อง (จะเพิ่มเติมภายหลัง)
		end
	)

	-- จัดการการทอยลูกเต๋า
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	boardRemotes.RollDice.OnServerEvent:Connect(function(player, diceResult)
		local playerId = player.UserId

		-- ตรวจสอบว่าเป็นเทิร์นของผู้เล่นหรือไม่
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			return 
		end

		-- ประมวลผลการเคลื่อนที่
		local moveInfo = boardSystem:ProcessPlayerMove(playerId, diceResult)

		if moveInfo and moveInfo.autoPath and #moveInfo.autoPath > 0 then
			-- ส่งข้อมูลการเคลื่อนที่ให้ Client
			local movementData = {
				path = moveInfo.autoPath,
				directions = moveInfo.requiresChoice and moveInfo.availableDirections or nil
			}
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- จบเทิร์นถ้าไม่มีการเคลื่อนไหว
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				gameManager.turnSystem:EndPlayerTurn(playerId, "no_move")
			end
		end
	end)

	-- จัดการการเลือกเส้นทาง
	boardRemotes.ChoosePath.OnServerEvent:Connect(function(player, direction)
		local playerId = player.UserId

		-- ตรวจสอบว่าเป็นเทิร์นของผู้เล่นหรือไม่
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			return 
		end

		-- ประมวลผลการเลือก
		local moveResult = boardSystem:ProcessDirectionChoice(playerId, direction)

		if moveResult and moveResult.autoPath and #moveResult.autoPath > 0 then
			-- ส่งข้อมูลการเคลื่อนที่ (หลังเลือก) ให้ Client
			local movementData = {
				path = moveResult.autoPath,
				directions = moveResult.requiresChoice and moveResult.availableDirections or nil
			}
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- จบเทิร์นถ้าการเลือกไม่ถูกต้อง
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				gameManager.turnSystem:EndPlayerTurn(playerId, "invalid_choice")
			end
		end
	end)

	return boardSystem
end

-- เริ่มต้นบริการ
local boardSystemInstance = initializeBoardService()
_G.BoardSystem = boardSystemInstance
return boardSystemInstance
