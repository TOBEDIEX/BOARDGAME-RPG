-- BoardService.server.lua
-- บริการฝั่งเซิร์ฟเวอร์สำหรับจัดการระบบกระดาน
-- Version: 2.1.0 (Fixed Turn Coordination)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- โหลดโมดูลที่จำเป็น
local Modules = ServerStorage:WaitForChild("Modules")
local BoardSystem = require(Modules:WaitForChild("BoardSystem"))
local MapData = require(ServerStorage.GameData.MapData)

-- ตรวจสอบและสร้าง Remote Events ที่จำเป็น
local function ensureRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	local requiredEvents = {
		"RollDice",
		"PlayerArrivedAtTile",
		"ChoosePath",
		"TileTriggerEvent",
		"ActivityComplete",
		"StartPlayerMovementPath",
		"MovementVisualizationComplete" -- เพิ่ม event ใหม่สำหรับยืนยันการเคลื่อนที่
	}

	for _, eventName in ipairs(requiredEvents) do
		if not boardRemotes:FindFirstChild(eventName) then
			Instance.new("RemoteEvent", boardRemotes).Name = eventName
		end
	end

	-- สร้าง ShowPathSelection เผื่อ Client ยังใช้
	if not boardRemotes:FindFirstChild("ShowPathSelection") then
		Instance.new("RemoteEvent", boardRemotes).Name = "ShowPathSelection"
	end

	return remotes
end

-- Constants
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }

-- รับ GameManager จาก global variable
local function getGameManager()
	local startTime = tick()
	while not _G.GameManager and tick() - startTime < 10 do
		task.wait(0.1)
	end
	return _G.GameManager
end

-- เก็บสถานะของการรอให้การเคลื่อนที่เสร็จสิ้น
local pendingMovementCompletions = {}

-- ฟังก์ชันหลักสำหรับเริ่มต้นบริการ
local function initializeBoardService()
	local remotes = ensureRemoteEvents()
	local boardSystem = BoardSystem.new()

	-- โหลด Map
	if not MapData then 
		boardSystem:LoadMap({tiles={[1]={type="start", position=Vector3.new(0,0,0)}}, connections={}})
	else 
		boardSystem:LoadMap(MapData)
	end

	local gameManager = getGameManager()
	if not gameManager then return end
	gameManager.boardSystem = boardSystem

	-- ตั้งค่า callbacks
	boardSystem:SetupCallbacks(
		-- onPlayerMoved
		function(playerId, fromTileId, toTileId)
			-- เมื่อผู้เล่นเคลื่อนที่จากช่องหนึ่งไปอีกช่องหนึ่ง (Logic)
		end,

		-- onPlayerPathComplete
		function(playerId, finalTileId)
			-- เมื่อผู้เล่นเดินทางครบทุกก้าว (Server-side Logic)
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("PlayerArrivedAtTile"):FireAllClients(playerId, finalTileId)

			-- เก็บสถานะว่ากำลังรอการยืนยันการเคลื่อนที่จาก Client
			local player = Players:GetPlayerByUserId(playerId)
			if player then
				pendingMovementCompletions[playerId] = {
					finalTileId = finalTileId,
					timestamp = os.time(),
					confirmed = false
				}

				-- ตั้งเวลาสำรองในกรณีที่ Client ไม่ตอบกลับ (30 วินาที)
				task.spawn(function()
					task.wait(30)
					if pendingMovementCompletions[playerId] and not pendingMovementCompletions[playerId].confirmed then
						-- ถ้ายังไม่ได้รับการยืนยันหลังจาก timeout ให้ถือว่าเสร็จสิ้นแล้ว
						pendingMovementCompletions[playerId].confirmed = true

						-- จบเทิร์นถ้ายังคงเป็นผู้เล่นคนเดิม
						if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
							gameManager.turnSystem:EndPlayerTurn(playerId, "move_timeout")
						end
					end
				end)
			else
				-- ถ้าไม่พบผู้เล่น (ออกจากเกมไปแล้ว) ให้จบเทิร์นเลย
				if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
					task.wait(0.5) -- รอเล็กน้อยก่อนจบเทิร์น
					gameManager.turnSystem:EndPlayerTurn(playerId, "player_left")
				end
			end
		end,

		-- onTileEffect
		function(playerId, tileId, tileInfo)
			-- เมื่อควรเริ่มเอฟเฟคของช่อง
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("TileTriggerEvent"):FireAllClients(playerId, tileId, tileInfo.type)

			-- ประมวลผลเอฟเฟคของช่อง (จะเพิ่มเติมภายหลัง)
		end
	)

	-- จัดการการทอยลูกเต๋า
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	boardRemotes.RollDice.OnServerEvent:Connect(function(player, diceResult)
		local playerId = player.UserId

		-- ตรวจสอบว่าเป็นเทิร์นของผู้เล่นหรือไม่
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			return 
		end

		-- ประมวลผลการเคลื่อนที่
		local moveInfo = boardSystem:ProcessPlayerMove(playerId, diceResult)

		if moveInfo and moveInfo.autoPath and #moveInfo.autoPath > 0 then
			-- ส่งข้อมูลการเคลื่อนที่ให้ Client
			local movementData = {
				path = moveInfo.autoPath,
				directions = moveInfo.requiresChoice and moveInfo.availableDirections or nil,
				requiresConfirmation = true -- บอก Client ว่าต้องยืนยันเมื่อการเคลื่อนที่เสร็จสิ้น
			}
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- จบเทิร์นถ้าไม่มีการเคลื่อนไหว
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				gameManager.turnSystem:EndPlayerTurn(playerId, "no_move")
			end
		end
	end)

	-- จัดการการเลือกเส้นทาง
	boardRemotes.ChoosePath.OnServerEvent:Connect(function(player, direction)
		local playerId = player.UserId

		-- ตรวจสอบว่าเป็นเทิร์นของผู้เล่นหรือไม่
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			return 
		end

		-- ตรวจสอบว่าการเคลื่อนที่ก่อนหน้าได้รับการยืนยันแล้วหรือไม่
		if pendingMovementCompletions[playerId] and not pendingMovementCompletions[playerId].confirmed then
			pendingMovementCompletions[playerId].confirmed = true
		end

		-- ประมวลผลการเลือก
		local moveResult = boardSystem:ProcessDirectionChoice(playerId, direction)

		if moveResult and moveResult.autoPath and #moveResult.autoPath > 0 then
			-- ส่งข้อมูลการเคลื่อนที่ (หลังเลือก) ให้ Client
			local movementData = {
				path = moveResult.autoPath,
				directions = moveResult.requiresChoice and moveResult.availableDirections or nil,
				requiresConfirmation = true -- บอก Client ว่าต้องยืนยันเมื่อการเคลื่อนที่เสร็จสิ้น
			}
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- จบเทิร์นถ้าการเลือกไม่ถูกต้อง
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				gameManager.turnSystem:EndPlayerTurn(playerId, "invalid_choice")
			end
		end
	end)

	-- จัดการการยืนยันการเคลื่อนที่เสร็จสิ้นจาก Client
	boardRemotes.MovementVisualizationComplete.OnServerEvent:Connect(function(player, finalTileId)
		local playerId = player.UserId

		-- ตรวจสอบว่าการเคลื่อนที่นี้อยู่ในการรอยืนยันหรือไม่
		if not pendingMovementCompletions[playerId] then return end

		-- ตั้งค่าว่าได้รับการยืนยันแล้ว
		pendingMovementCompletions[playerId].confirmed = true

		-- จบเทิร์นถ้ายังคงเป็นผู้เล่นคนเดิม
		if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
			-- ตรวจสอบว่าการเคลื่อนที่เป็นการจบแล้วหรือไม่ (ไม่มีทางเลือกต่อ)
			local hasChoices = boardSystem.playerMovementState[playerId] == "need_choice"

			if not hasChoices then
				-- รอสักครู่เพื่อให้อนิเมชันเสร็จสมบูรณ์ก่อนจบเทิร์น
				task.wait(0.5) 
				-- จบเทิร์น
				gameManager.turnSystem:EndPlayerTurn(playerId, "move_complete")
			end
		end

		-- ลบข้อมูลการรอยืนยัน
		pendingMovementCompletions[playerId] = nil
	end)

	return boardSystem
end

-- เริ่มต้นบริการ
local boardSystemInstance = initializeBoardService()
_G.BoardSystem = boardSystemInstance
return boardSystemInstance
