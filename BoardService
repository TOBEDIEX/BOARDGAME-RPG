-- BoardService.server.lua
-- Server-side service for board system management
-- Version: 3.2.0 (Supports unlimited steps from dice bonus)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Load required modules
local Modules = ServerStorage:WaitForChild("Modules")
local BoardSystem = require(Modules:WaitForChild("BoardSystem"))
local MapData = require(ServerStorage.GameData.MapData)

-- Create required RemoteEvents
local function ensureRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	local requiredEvents = {
		"RollDice",
		"PlayerArrivedAtTile",
		"ChoosePath",
		"TileTriggerEvent",
		"ActivityComplete",
		"StartPlayerMovementPath",
		"MovementVisualizationComplete"
	}

	for _, eventName in ipairs(requiredEvents) do
		if not boardRemotes:FindFirstChild(eventName) then
			Instance.new("RemoteEvent", boardRemotes).Name = eventName
		end
	end

	-- Create ShowPathSelection for backwards compatibility
	if not boardRemotes:FindFirstChild("ShowPathSelection") then
		Instance.new("RemoteEvent", boardRemotes).Name = "ShowPathSelection"
	end

	return remotes
end

-- Constants
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }

-- Get GameManager from global variable
local function getGameManager()
	local startTime = tick()
	while not _G.GameManager and tick() - startTime < 10 do
		task.wait(0.1)
	end
	return _G.GameManager
end

-- ฟังก์ชันใหม่: ดึง DiceBonusService
local function getDiceBonusService()
	if _G.DiceBonusService then
		return _G.DiceBonusService
	end

	local gameManager = getGameManager()
	if gameManager and gameManager.diceBonusService then
		return gameManager.diceBonusService
	end

	return nil
end

-- Store movement completion state
local pendingMovementCompletions = {}

-- Main service initialization function
local function initializeBoardService()
	local remotes = ensureRemoteEvents()
	local boardSystem = BoardSystem.new()

	-- Load Map
	if not MapData then 
		boardSystem:LoadMap({tiles={[1]={type="start", position=Vector3.new(0,0,0)}}, connections={}})
	else 
		boardSystem:LoadMap(MapData)
	end

	local gameManager = getGameManager()
	if not gameManager then return end
	gameManager.boardSystem = boardSystem

	-- Set up callbacks
	boardSystem:SetupCallbacks(
		-- onPlayerMoved
		function(playerId, fromTileId, toTileId)
			-- Logic for when player moves from one tile to another
		end,

		-- onPlayerPathComplete
		function(playerId, finalTileId)
			-- Logic for when player completes their path (all steps used)
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("PlayerArrivedAtTile"):FireAllClients(playerId, finalTileId)

			-- Store pending movement completion state
			local player = Players:GetPlayerByUserId(playerId)
			if player then
				pendingMovementCompletions[playerId] = {
					finalTileId = finalTileId,
					timestamp = os.time(),
					confirmed = false
				}

				-- Set up backup timer in case client doesn't respond (30 seconds)
				task.spawn(function()
					task.wait(30)
					if pendingMovementCompletions[playerId] and not pendingMovementCompletions[playerId].confirmed then
						-- If not confirmed after timeout, consider completed
						pendingMovementCompletions[playerId].confirmed = true

						-- End turn if still same player
						if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
							gameManager.turnSystem:EndPlayerTurn(playerId, "move_timeout")
						end
					end
				end)
			else
				-- If player not found (left game), end turn immediately
				if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
					task.wait(0.5) -- Short delay before ending turn
					gameManager.turnSystem:EndPlayerTurn(playerId, "player_left")
				end
			end
		end,

		-- onTileEffect
		function(playerId, tileId, tileInfo)
			-- Logic for when tile effect should start
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("TileTriggerEvent"):FireAllClients(playerId, tileId, tileInfo.type)
		end
	)

	-- Handle dice rolling
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	boardRemotes.RollDice.OnServerEvent:Connect(function(player, diceResult)
		local playerId = player.UserId

		-- Check if it's player's turn
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			return 
		end

		-- ตรวจสอบว่าค่า diceResult อยู่ในช่วงที่เป็นไปได้หรือไม่
		local diceBonusService = getDiceBonusService()
		local diceBonus = diceBonusService and diceBonusService.GetPlayerDiceBonus(playerId) or 0

		-- เมื่อมีการใช้ลูกเต๋าพร้อมโบนัส จำนวนลูกเต๋าคือ 1 + diceBonus
		-- ค่าต่ำสุดที่เป็นไปได้คือ จำนวนลูกเต๋า × 1
		-- ค่าสูงสุดที่เป็นไปได้คือ จำนวนลูกเต๋า × 6
		local minPossibleResult = 1 + diceBonus -- ต่ำสุดคือลูกละ 1
		local maxPossibleResult = (1 + diceBonus) * 6 -- สูงสุดคือลูกละ 6

		print("[BoardService] Player " .. player.Name .. " rolled " .. diceResult .. 
			" (Bonus: " .. diceBonus .. ", Valid range: " .. minPossibleResult .. "-" .. maxPossibleResult .. ")")

		if diceResult < minPossibleResult or diceResult > maxPossibleResult then
			warn("[BoardService] Invalid dice result from player " .. player.Name .. ": " .. diceResult .. 
				" (Expected range: " .. minPossibleResult .. "-" .. maxPossibleResult .. ")")

			-- แทนค่าด้วยค่าที่สุ่มใหม่ในกรณีที่ค่าไม่ถูกต้อง
			local baseDiceRoll = math.random(1, 6)
			local bonusDiceRolls = {}

			for i = 1, diceBonus do
				table.insert(bonusDiceRolls, math.random(1, 6))
			end

			-- คำนวณผลรวม
			local totalResult = baseDiceRoll
			for _, bonusRoll in ipairs(bonusDiceRolls) do
				totalResult = totalResult + bonusRoll
			end

			diceResult = totalResult
			print("[BoardService] Using server-generated dice result instead: " .. diceResult)
		end

		-- Process movement with unlimited steps
		local moveInfo = boardSystem:ProcessPlayerMove(playerId, diceResult)

		if moveInfo and moveInfo.autoPath and #moveInfo.autoPath > 0 then
			-- Send movement data to client
			local movementData = {
				path = moveInfo.autoPath,
				directions = moveInfo.requiresChoice and moveInfo.availableDirections or nil,
				requiresConfirmation = true
			}
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- End turn if no movement
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				gameManager.turnSystem:EndPlayerTurn(playerId, "no_move")
			end
		end

		-- ล้าง Dice Bonus หลังจากใช้ไปแล้ว
		if diceBonus > 0 and diceBonusService then
			diceBonusService.ClearPlayerDiceBonus(playerId)
			print("[BoardService] Cleared dice bonus for player " .. player.Name .. " after use")
		end
	end)

	-- Handle path selection
	boardRemotes.ChoosePath.OnServerEvent:Connect(function(player, direction)
		local playerId = player.UserId

		-- Check if it's player's turn
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			return 
		end

		-- Check if previous movement was confirmed
		if pendingMovementCompletions[playerId] and not pendingMovementCompletions[playerId].confirmed then
			pendingMovementCompletions[playerId].confirmed = true
		end

		-- Process direction choice
		local moveResult = boardSystem:ProcessDirectionChoice(playerId, direction)

		if moveResult and moveResult.autoPath and #moveResult.autoPath > 0 then
			-- Send movement data to client
			local movementData = {
				path = moveResult.autoPath,
				directions = moveResult.requiresChoice and moveResult.availableDirections or nil,
				requiresConfirmation = true
			}
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- End turn if choice invalid
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				gameManager.turnSystem:EndPlayerTurn(playerId, "invalid_choice")
			end
		end
	end)

	-- Handle movement completion confirmation from client
	boardRemotes.MovementVisualizationComplete.OnServerEvent:Connect(function(player, finalTileId)
		local playerId = player.UserId

		-- Check if this movement is pending confirmation
		if not pendingMovementCompletions[playerId] then return end

		-- Set as confirmed
		pendingMovementCompletions[playerId].confirmed = true

		-- End turn if still same player
		if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
			-- Check if movement is complete (no more choices)
			local hasChoices = boardSystem.playerMovementState[playerId] == "need_choice"

			if not hasChoices then
				-- Short delay to allow animations to complete
				task.wait(0.5) 
				gameManager.turnSystem:EndPlayerTurn(playerId, "move_complete")
			end
		end

		-- Clear pending confirmation
		pendingMovementCompletions[playerId] = nil
	end)

	return boardSystem
end

-- Initialize service
local boardSystemInstance = initializeBoardService()
_G.BoardSystem = boardSystemInstance
return boardSystemInstance
