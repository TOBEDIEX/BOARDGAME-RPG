-- BoardService.server.lua
-- Server-side service for board system management
-- Version: 3.6.0 (Fixed Crystal Movement & Turn Management)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Load required modules
local Modules = ServerStorage:WaitForChild("Modules")
local BoardSystem = require(Modules:WaitForChild("BoardSystem"))
local MapData = require(ServerStorage.GameData.MapData)

-- Enable debug mode
local DEBUG_MOVEMENT = true
local TRUST_CLIENT_DICE = true -- Trust dice roll values from client

-- Create required RemoteEvents
local function ensureRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	local requiredEvents = {
		"RollDice",
		"PlayerArrivedAtTile",
		"ChoosePath",
		"TileTriggerEvent",
		"ActivityComplete",
		"StartPlayerMovementPath",
		"MovementVisualizationComplete",
		"CrystalMove", -- For crystal movement
		"CrystalMoveComplete" -- NEW: For explicit crystal movement completion
	}

	for _, eventName in ipairs(requiredEvents) do
		if not boardRemotes:FindFirstChild(eventName) then
			Instance.new("RemoteEvent", boardRemotes).Name = eventName
		end
	end

	-- Create ShowPathSelection for backwards compatibility
	if not boardRemotes:FindFirstChild("ShowPathSelection") then
		Instance.new("RemoteEvent", boardRemotes).Name = "ShowPathSelection"
	end

	return remotes
end

-- Constants
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }

-- Get GameManager from global variable
local function getGameManager()
	local startTime = tick()
	while not _G.GameManager and tick() - startTime < 10 do
		task.wait(0.1)
	end
	return _G.GameManager
end

-- Function to get DiceBonusService
local function getDiceBonusService()
	if _G.DiceBonusService then
		return _G.DiceBonusService
	end

	local gameManager = getGameManager()
	if gameManager and gameManager.diceBonusService then
		return gameManager.diceBonusService
	end

	return nil
end

-- Store movement completion state
local pendingMovementCompletions = {}

-- Track active crystal movements
local activeCrystalMovements = {}

-- Storage for player dice bonuses (redundant to prevent usage errors)
local playerDiceBonus = {}

-- Main service initialization function
local function initializeBoardService()
	local remotes = ensureRemoteEvents()
	local boardSystem = BoardSystem.new()

	-- Load Map
	if not MapData then 
		boardSystem:LoadMap({tiles={[1]={type="start", position=Vector3.new(0,0,0)}}, connections={}})
	else 
		boardSystem:LoadMap(MapData)
	end

	local gameManager = getGameManager()
	if not gameManager then return end
	gameManager.boardSystem = boardSystem

	-- Add variable to store latest movement data
	boardSystem.lastMovementData = {}

	-- Set up callbacks
	boardSystem:SetupCallbacks(
		-- onPlayerMoved
		function(playerId, fromTileId, toTileId)
			-- Logic for when player moves from one tile to another
			if DEBUG_MOVEMENT then
				print("[BoardService] Player " .. playerId .. " moved from tile " .. 
					(fromTileId or "nil") .. " to tile " .. toTileId)
			end
		end,

		-- onPlayerPathComplete
		function(playerId, finalTileId)
			-- Logic for when player completes their path (all steps used)
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("PlayerArrivedAtTile"):FireAllClients(playerId, finalTileId)

			if DEBUG_MOVEMENT then
				print("[BoardService] Player " .. playerId .. " completed path at tile " .. finalTileId)
			end

			-- Store pending movement completion state
			local player = Players:GetPlayerByUserId(playerId)
			if player then
				pendingMovementCompletions[playerId] = {
					finalTileId = finalTileId,
					timestamp = os.time(),
					confirmed = false,
					isCrystalMove = activeCrystalMovements[playerId] ~= nil
				}

				-- Set up backup timer in case client doesn't respond (reduced to 15 seconds)
				task.spawn(function()
					task.wait(15)
					if pendingMovementCompletions[playerId] and not pendingMovementCompletions[playerId].confirmed then
						-- If not confirmed after timeout, consider completed
						pendingMovementCompletions[playerId].confirmed = true

						if DEBUG_MOVEMENT then
							print("[BoardService] Movement confirmation timed out for player " .. playerId)
						end

						-- End turn if still same player
						if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
							-- Check if it was crystal movement
							local isCrystalMove = activeCrystalMovements[playerId] ~= nil

							-- Clear crystal movement state
							activeCrystalMovements[playerId] = nil

							-- End turn with appropriate reason
							if isCrystalMove then
								gameManager.turnSystem:EndPlayerTurn(playerId, "crystal_move_timeout")
							else
								gameManager.turnSystem:EndPlayerTurn(playerId, "move_timeout")
							end
						end
					end
				end)
			else
				-- If player not found (left game), end turn immediately
				if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
					task.wait(0.5) -- Short delay before ending turn
					gameManager.turnSystem:EndPlayerTurn(playerId, "player_left")
				end
			end
		end,

		-- onTileEffect
		function(playerId, tileId, tileInfo)
			-- Logic for when tile effect should start
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes:WaitForChild("TileTriggerEvent"):FireAllClients(playerId, tileId, tileInfo.type)

			if DEBUG_MOVEMENT then
				print("[BoardService] Tile effect triggered for player " .. playerId .. 
					" at tile " .. tileId .. " (type: " .. tileInfo.type .. ")")
			end
		end
	)

	-- IMPROVED: Function for processing crystal movement
	function boardSystem:ProcessCrystalMove(player, steps)
		local playerId = player.UserId

		-- Check if it's player's turn
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then
			print("[BoardService] Rejected crystal move from player " .. playerId .. " - not their turn")
			return false
		end

		-- Check if player is already moving
		if self.playerMovementState and self.playerMovementState[playerId] and 
			(self.playerMovementState[playerId] == "auto_complete" or 
				self.playerMovementState[playerId] == "need_choice") then
			print("[BoardService] Rejected crystal move from player " .. playerId .. " - already moving")
			return false
		end

		-- Get player's current position
		local currentTileId = self:GetPlayerTile(playerId)
		if not currentTileId then
			print("[BoardService] Player " .. playerId .. " has no current position")
			return false
		end

		local prevTileId = self.playerLastTile[playerId]

		if DEBUG_MOVEMENT then
			print("[BoardService] Processing crystal move for player " .. playerId .. 
				" with " .. steps .. " steps from tile " .. currentTileId)
		end

		-- Track this as an active crystal movement
		activeCrystalMovements[playerId] = {
			steps = steps,
			startTime = os.time(),
			startTile = currentTileId,
			completed = false
		}

		-- Use ProcessPlayerMove like dice roll but with crystal steps
		local moveInfo = self:ProcessPlayerMove(playerId, steps)

		if moveInfo and moveInfo.autoPath and #moveInfo.autoPath > 0 then
			-- Send movement data to client
			local movementData = {
				path = moveInfo.autoPath,
				directions = moveInfo.requiresChoice and moveInfo.availableDirections or nil,
				requiresConfirmation = true,
				isCrystalMove = true -- Add flag to identify as crystal movement
			}

			if DEBUG_MOVEMENT then
				print("[BoardService] Sending crystal movement path to player " .. playerId)
				print("  Path length: " .. #moveInfo.autoPath)
				print("  Requires choice: " .. tostring(moveInfo.requiresChoice))
				print("  Auto-complete: " .. tostring(moveInfo.autoComplete))
			end

			-- Store movement data
			self.lastMovementData = self.lastMovementData or {}
			self.lastMovementData[playerId] = movementData

			-- Send movement data to client
			local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)

			-- Notify client to show crystal effect
			local crystalMoveEvent = boardRemotes:FindFirstChild("CrystalMove")
			if crystalMoveEvent then
				crystalMoveEvent:FireClient(player, steps)
			end

			-- IMPROVED: If there are choices (fork in path), handle it more robustly
			if moveInfo.requiresChoice and moveInfo.availableDirections and #moveInfo.availableDirections > 0 then
				-- Auto-path selection for crystals
				task.delay(1.5, function()
					-- Make sure it's still a crystal movement and still active
					if not activeCrystalMovements[playerId] or activeCrystalMovements[playerId].completed then
						return -- Movement was already completed or canceled
					end

					-- Make sure player hasn't already made a choice
					if not self.playerMovementState or self.playerMovementState[playerId] ~= "need_choice" then
						return -- Player already made a choice or completed movement
					end

					-- Automatically select first direction
					local direction = moveInfo.availableDirections[1].direction

					if DEBUG_MOVEMENT then
						print("[BoardService] Auto-selecting direction " .. direction .. " for crystal move")
					end

					-- Process direction choice as if player chose it
					local moveResult = self:ProcessDirectionChoice(playerId, direction)

					-- If process was successful
					if moveResult and moveResult.autoPath and #moveResult.autoPath > 0 then
						-- Update movement data
						local newMovementData = {
							path = moveResult.autoPath,
							directions = moveResult.requiresChoice and moveResult.availableDirections or nil,
							requiresConfirmation = true,
							isCrystalMove = true
						}

						-- Store updated movement data
						self.lastMovementData[playerId] = newMovementData

						-- Send updated movement data to client
						boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, newMovementData)

						-- If there are more choices (this can happen with complex paths)
						if moveResult.requiresChoice and moveResult.availableDirections and #moveResult.availableDirections > 0 then
							-- We need to wait again and select another direction (recursive handling)
							task.delay(1.5, function()
								-- Check if still active crystal movement
								if not activeCrystalMovements[playerId] or activeCrystalMovements[playerId].completed then
									return -- Movement was already completed or canceled
								end

								-- Auto-select first direction again
								if self.playerMovementState and self.playerMovementState[playerId] == "need_choice" then
									local nextDirection = moveResult.availableDirections[1].direction
									-- Process this next fork
									self:ProcessDirectionChoice(playerId, nextDirection)
								end
							end)
						end
					end
				end)
			end

			return true
		else
			-- If no movement path generated
			if DEBUG_MOVEMENT then
				print("[BoardService] No movement path generated for crystal move from player " .. playerId)
			end

			-- Clear crystal movement state
			activeCrystalMovements[playerId] = nil

			return false
		end
	end

	-- Function to record dice bonus
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local inventoryRemotes = remotes:WaitForChild("InventoryRemotes")

	if inventoryRemotes:FindFirstChild("DiceBonus") then
		inventoryRemotes.DiceBonus.OnServerEvent:Connect(function(player, bonusAmount)
			if player then
				playerDiceBonus[player.UserId] = bonusAmount
				print("[BoardService] Saved dice bonus " .. bonusAmount .. " for player " .. player.Name)
			end
		end)
	end

	-- Handle dice rolling
	local boardRemotes = remotes:WaitForChild("BoardRemotes")
	boardRemotes.RollDice.OnServerEvent:Connect(function(player, diceResult)
		local playerId = player.UserId

		-- Check if it's player's turn
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			if DEBUG_MOVEMENT then
				print("[BoardService] Rejected dice roll from player " .. playerId .. 
					" - not their turn")
			end
			return 
		end

		-- IMPROVED: Check if player is already in crystal movement
		if activeCrystalMovements[playerId] then
			print("[BoardService] Rejected dice roll from player " .. playerId .. " - crystal movement active")
			return
		end

		-- Get dice bonus
		local diceBonusService = getDiceBonusService()

		-- Use internal storage value first
		local diceBonus = playerDiceBonus[playerId] or 0

		-- If not in internal system, try to get from service
		if diceBonus == 0 and diceBonusService then
			diceBonus = diceBonusService.GetPlayerDiceBonus(playerId) or 0

			-- Store value for later use
			if diceBonus > 0 then
				playerDiceBonus[playerId] = diceBonus
			end
		end

		-- Check dice roll value
		print("[BoardService] Player " .. player.Name .. " rolled " .. diceResult .. 
			" (Bonus dice: " .. diceBonus .. ")")

		-- Use value from client directly if configured to trust clients
		if TRUST_CLIENT_DICE then
			-- Add minimum safety checks (value must not be negative and not exceed maximum possible)
			local maxReasonableDiceResult = 100 -- Shouldn't reasonably exceed this in normal cases

			if diceResult < 1 then
				diceResult = 1
				print("[BoardService] WARNING: Player sent negative dice result, using 1 instead")
			elseif diceResult > maxReasonableDiceResult then
				diceResult = 6 + (diceBonus * 6) -- Maximum possible real value
				print("[BoardService] WARNING: Player sent unreasonably high dice result, using " .. diceResult .. " instead")
			end
		else
			-- If not trusting client, use previous validation
			local minPossibleResult = 1 
			local maxPossibleResult = 6

			-- Calculate possible range based on bonus
			if diceBonus > 0 then
				minPossibleResult = 1 + diceBonus -- Minimum is main die 1 + bonus of 1 per die
				maxPossibleResult = 6 + (diceBonus * 6) -- Maximum is main die 6 + bonus of 6 per die
			end

			-- Check if value is within possible range
			if diceResult < minPossibleResult or diceResult > maxPossibleResult then
				warn("[BoardService] Invalid dice result from player " .. player.Name .. ": " .. diceResult .. 
					" (Expected range: " .. minPossibleResult .. "-" .. maxPossibleResult .. ")")

				-- Generate new random value for main die + bonus
				local baseDiceRoll = math.random(1, 6)
				local totalResult = baseDiceRoll

				for i = 1, diceBonus do
					local bonusRoll = math.random(1, 6)
					totalResult = totalResult + bonusRoll
				end

				diceResult = totalResult
				print("[BoardService] Using server-generated dice result instead: " .. diceResult)
			end
		end

		-- Process movement
		local moveInfo = boardSystem:ProcessPlayerMove(playerId, diceResult)

		if moveInfo and moveInfo.autoPath and #moveInfo.autoPath > 0 then
			-- Send movement data to client
			local movementData = {
				path = moveInfo.autoPath,
				directions = moveInfo.requiresChoice and moveInfo.availableDirections or nil,
				requiresConfirmation = true
			}

			if DEBUG_MOVEMENT then
				print("[BoardService] Sending movement path to player " .. playerId)
				print("  Path length: " .. #moveInfo.autoPath)
				print("  Requires choice: " .. tostring(moveInfo.requiresChoice))
				print("  Auto-complete: " .. tostring(moveInfo.autoComplete))
				if moveInfo.requiresChoice then
					print("  Available directions: " .. #moveInfo.availableDirections)
				end
			end

			-- Store latest movement data
			boardSystem.lastMovementData[playerId] = movementData

			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- End turn if no movement
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				if DEBUG_MOVEMENT then
					print("[BoardService] No movement for player " .. playerId .. ", ending turn")
				end
				gameManager.turnSystem:EndPlayerTurn(playerId, "no_move")
			end
		end

		-- Reset dice bonus
		playerDiceBonus[playerId] = nil

		-- Clear Dice Bonus after use
		if diceBonus > 0 and diceBonusService then
			diceBonusService.ClearPlayerDiceBonus(playerId)
			print("[BoardService] Cleared dice bonus for player " .. player.Name .. " after use")
		end

		-- Clear Dice Bonus in InventoryService (if exists)
		if gameManager.inventoryService and gameManager.inventoryService.ResetDiceBonusUse then
			gameManager.inventoryService.ResetDiceBonusUse(playerId)
		end
	end)

	-- Handle path selection
	boardRemotes.ChoosePath.OnServerEvent:Connect(function(player, direction)
		local playerId = player.UserId

		-- Check if it's player's turn
		if gameManager.turnSystem and gameManager.turnSystem:GetCurrentPlayerTurn() ~= playerId then 
			if DEBUG_MOVEMENT then
				print("[BoardService] Rejected path choice from player " .. playerId .. 
					" - not their turn")
			end
			return 
		end

		if DEBUG_MOVEMENT then
			print("[BoardService] Player " .. playerId .. " chose direction: " .. direction)
		end

		-- Check if previous movement was confirmed
		if pendingMovementCompletions[playerId] and not pendingMovementCompletions[playerId].confirmed then
			pendingMovementCompletions[playerId].confirmed = true

			if DEBUG_MOVEMENT then
				print("[BoardService] Confirmed previous movement for player " .. playerId)
			end
		end

		-- Process direction choice
		local moveResult = boardSystem:ProcessDirectionChoice(playerId, direction)

		if moveResult and moveResult.autoPath and #moveResult.autoPath > 0 then
			-- Send movement data to client
			local movementData = {
				path = moveResult.autoPath,
				directions = moveResult.requiresChoice and moveResult.availableDirections or nil,
				requiresConfirmation = true,
				isCrystalMove = activeCrystalMovements[playerId] ~= nil
			}

			-- Store latest movement data
			boardSystem.lastMovementData[playerId] = movementData

			if DEBUG_MOVEMENT then
				print("[BoardService] Sending movement path after direction choice")
				print("  Path length: " .. #moveResult.autoPath)
				print("  Requires choice: " .. tostring(moveResult.requiresChoice))
				print("  Move complete: " .. tostring(moveResult.moveComplete or false))
				if moveResult.requiresChoice then
					print("  Available directions: " .. #moveResult.availableDirections)
				end
			end

			boardRemotes.StartPlayerMovementPath:FireClient(player, playerId, movementData)
		else
			-- End turn if choice invalid
			if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
				if DEBUG_MOVEMENT then
					print("[BoardService] Invalid direction choice from player " .. playerId .. 
						", ending turn")
				end
				gameManager.turnSystem:EndPlayerTurn(playerId, "invalid_choice")
			end
		end
	end)

	-- IMPROVED: Handle movement completion confirmation from client
	boardRemotes.MovementVisualizationComplete.OnServerEvent:Connect(function(player, finalTileId)
		local playerId = player.UserId

		-- Check if this movement is pending confirmation
		if not pendingMovementCompletions[playerId] then 
			if DEBUG_MOVEMENT then
				print("[BoardService] Received movement completion from player " .. playerId .. 
					" but no pending confirmation found")
			end
			return 
		end

		if DEBUG_MOVEMENT then
			print("[BoardService] Player " .. playerId .. " confirmed movement to tile " .. finalTileId)
		end

		-- Set as confirmed
		pendingMovementCompletions[playerId].confirmed = true

		-- End turn if still same player
		if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
			-- Check if this was a crystal movement
			local isCrystalMove = activeCrystalMovements[playerId] ~= nil

			-- If it was crystal movement, mark as completed
			if isCrystalMove then
				if DEBUG_MOVEMENT then
					print("[BoardService] Crystal movement complete, ending turn for player " .. playerId)
				end

				-- Mark crystal movement as completed
				if activeCrystalMovements[playerId] then
					activeCrystalMovements[playerId].completed = true
				end

				-- Notify clients that crystal movement is complete
				local crystalMoveCompleteEvent = boardRemotes:FindFirstChild("CrystalMoveComplete")
				if crystalMoveCompleteEvent then
					crystalMoveCompleteEvent:FireAllClients(playerId)
				end

				-- End turn with crystal-specific reason
				task.wait(0.5) -- Short delay for animations
				gameManager.turnSystem:EndPlayerTurn(playerId, "crystal_move_complete")

				-- Clear crystal movement state
				activeCrystalMovements[playerId] = nil
				return
			end

			-- Check if movement is complete (no more choices)
			local hasChoices = boardSystem.playerMovementState[playerId] == "need_choice"

			if DEBUG_MOVEMENT then
				print("[BoardService] Player " .. playerId .. " movement state: " .. 
					(boardSystem.playerMovementState[playerId] or "nil"))
				print("  Has more choices: " .. tostring(hasChoices))
				print("  Steps remaining: " .. (boardSystem.playerRemainingSteps[playerId] or 0))
			end

			if not hasChoices then
				-- Short delay to allow animations to complete
				task.wait(0.5) 

				if DEBUG_MOVEMENT then
					print("[BoardService] Ending turn for player " .. playerId .. 
						" after complete movement")
				end

				gameManager.turnSystem:EndPlayerTurn(playerId, "move_complete")
			end
		end

		-- Clear pending confirmation
		pendingMovementCompletions[playerId] = nil
	end)

	-- NEW: Add explicit crystal move complete handler
	local crystalMoveCompleteEvent = boardRemotes:FindFirstChild("CrystalMoveComplete")
	if not crystalMoveCompleteEvent then
		crystalMoveCompleteEvent = Instance.new("RemoteEvent")
		crystalMoveCompleteEvent.Name = "CrystalMoveComplete"
		crystalMoveCompleteEvent.Parent = boardRemotes
	end

	-- Handle explicit crystal move completion
	crystalMoveCompleteEvent.OnServerEvent:Connect(function(player)
		local playerId = player.UserId

		-- Check if there's an active crystal movement
		if not activeCrystalMovements[playerId] then
			return
		end

		if DEBUG_MOVEMENT then
			print("[BoardService] Received explicit crystal move completion from player " .. playerId)
		end

		-- Mark crystal movement as completed
		activeCrystalMovements[playerId].completed = true

		-- End turn if still same player
		if gameManager.turnSystem and playerId == gameManager.turnSystem:GetCurrentPlayerTurn() then
			task.wait(0.5) -- Short delay for animations
			gameManager.turnSystem:EndPlayerTurn(playerId, "crystal_move_complete")
		end

		-- Clear crystal movement state
		activeCrystalMovements[playerId] = nil

		-- Clear any pending movement completions
		if pendingMovementCompletions[playerId] then
			pendingMovementCompletions[playerId].confirmed = true
			pendingMovementCompletions[playerId] = nil
		end
	end)

	-- Add Handler for CrystalMove Remote
	local crystalMoveEvent = boardRemotes:FindFirstChild("CrystalMove")
	if not crystalMoveEvent then
		crystalMoveEvent = Instance.new("RemoteEvent")
		crystalMoveEvent.Name = "CrystalMove"
		crystalMoveEvent.Parent = boardRemotes
	end

	-- Listen for CrystalMove events from client
	crystalMoveEvent.OnServerEvent:Connect(function(player, steps)
		-- Safety check if player is already in a crystal movement
		local playerId = player.UserId
		if activeCrystalMovements[playerId] then
			if DEBUG_MOVEMENT then
				print("[BoardService] Ignored duplicate crystal move request from player " .. playerId)
			end
			return
		end

		-- Process the crystal movement
		boardSystem:ProcessCrystalMove(player, steps)
	end)

	-- Create ItemPermissionUpdate event if needed
	local ItemPermissionEvent = inventoryRemotes:FindFirstChild("ItemPermissionUpdate")
	if not ItemPermissionEvent then
		ItemPermissionEvent = Instance.new("RemoteEvent")
		ItemPermissionEvent.Name = "ItemPermissionUpdate"
		ItemPermissionEvent.Parent = inventoryRemotes
	end

	-- Connect to turn system to broadcast permission updates
	local gameRemotes = remotes:WaitForChild("GameRemotes", 10)
	if gameRemotes then
		local updateTurnEvent = gameRemotes:WaitForChild("UpdateTurn", 10)
		if updateTurnEvent then
			updateTurnEvent.OnServerEvent:Connect(function(_, playerId)
				-- IMPROVED: Create an explicit turn item permission event
				-- Let all clients know about turn change for permissions update
				print("[BoardService] Broadcasting turn item permissions update for player " .. playerId)

				-- Tell all clients about the turn change, so they can update permissions
				ItemPermissionEvent:FireAllClients(playerId)
			end)
		end
	end

	return boardSystem
end

-- Initialize service
local boardSystemInstance = initializeBoardService()
_G.BoardSystem = boardSystemInstance
return boardSystemInstance
