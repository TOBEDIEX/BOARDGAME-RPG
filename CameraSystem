-- SimpleCameraSystem.lua
-- ระบบกล้องอย่างง่าย: ล็อคผู้เล่นและเปลี่ยนเป็น FreeCam ได้
-- วางใน StarterPlayerScripts

local CameraSystem = {}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Local variables
local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local currentMode = "LockPlayer" -- LockPlayer or FreeCam
local connections = {}
local currentTurnPlayerId = nil
local freeCamPosition = Vector3.new(0, 0, 0)
local freeCamHeight = 40
local moveSpeed = 1 -- ปรับค่านี้เพื่อเปลี่ยนความเร็วพื้นฐาน
local freeCamMoveSpeedMultiplier = 2.5 -- เพิ่มตัวคูณความเร็วเล็กน้อย
local cameraOffset = Vector3.new(0, 8, 16)
local freeCamDirection = Vector3.new(0, -0.8, -1).Unit -- มุมเอียงแบบ MOBA มองลงมาจากด้านบน
local cameraAngle = math.rad(45) -- มุมกล้องเอียง 45 องศา (แบบ MOBA)
local cameraDistance = 30 -- ระยะห่างของกล้องจากตำแหน่งเป้าหมาย

-- Debug function
local function debug(message)
	print("[CameraSystem] " .. message)
end




-- Find current turn player (โค้ดเดิม ไม่เปลี่ยนแปลง)
local function findCurrentTurnPlayer()
	if not currentTurnPlayerId then return nil end
	local targetPlayer = Players:GetPlayerByUserId(currentTurnPlayerId)
	if not targetPlayer then return nil end
	local character = targetPlayer.Character
	if not character then return nil end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	return {player = targetPlayer, character = character, rootPart = humanoidRootPart, position = humanoidRootPart.Position, lookVector = humanoidRootPart.CFrame.LookVector}
end

-- Find center of board
local function findBoardCenter()
	local tilesFolder = Workspace:FindFirstChild("BoardTiles")
	if not tilesFolder then return Vector3.new(0, 0, 0) end
	local totalPos = Vector3.new(0, 0, 0)
	local count = 0
	for _, tile in ipairs(tilesFolder:GetChildren()) do
		if tile:IsA("BasePart") then totalPos = totalPos + tile.Position; count = count + 1 end
	end
	return if count > 0 then totalPos / count else Vector3.new(0, 0, 0)
end

-- Update in lock player mode (โค้ดเดิม ไม่เปลี่ยนแปลง)
local function updateLockPlayerCamera()
	local playerInfo = findCurrentTurnPlayer()
	local targetCFrame
	if playerInfo then
		local targetPos = playerInfo.position
		local lookVector = playerInfo.lookVector
		local cameraPos = targetPos - (lookVector * cameraOffset.Z) + Vector3.new(0, cameraOffset.Y, 0)
		local lookAtPos = targetPos + Vector3.new(0, 2, 0)
		targetCFrame = CFrame.lookAt(cameraPos, lookAtPos)
	else
		local boardCenter = findBoardCenter()
		local cameraPos = boardCenter + Vector3.new(0, freeCamHeight, 20)
		targetCFrame = CFrame.lookAt(cameraPos, boardCenter)
	end
	local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local tween = TweenService:Create(camera, tweenInfo, {CFrame = targetCFrame})
	tween:Play()
end

-- *** Update free cam (แก้ไขใหม่สำหรับมุมมอง MOBA) ***
local function updateFreeCam(deltaTime)
	-- รับข้อมูลเมาส์สำหรับหมุนกล้อง
	local mouseMovement = UserInputService:GetMouseDelta()
	
	-- ตั้งค่าความเร็วหมุนกล้อง
	local rotationSpeed = 0.005
	
	-- หมุนกล้องตามการเคลื่อนไหวของเมาส์ (ถ้าผู้ใช้กดปุ่มเมาส์ขวา)
	if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
		-- หมุนรอบแกน Y (หมุนซ้าย-ขวา) เท่านั้น เพื่อรักษามุมเอียงแบบ MOBA
		local rotationY = -mouseMovement.X * rotationSpeed
		
		-- สร้าง CFrame สำหรับหมุน
		local rotationCF = CFrame.Angles(0, rotationY, 0)
		
		-- เวกเตอร์ทิศทางหลักในแนวระนาบ XZ
		local horizontalDir = Vector3.new(freeCamDirection.X, 0, freeCamDirection.Z).Unit
		
		-- หมุนเฉพาะส่วนแนวระนาบ
		local newHorizontalDir = (rotationCF * horizontalDir)
		
		-- ประกอบกลับเป็นทิศทางใหม่ โดยคงมุมในแนวดิ่ง (เอียงลงมา)
		freeCamDirection = Vector3.new(newHorizontalDir.X, -math.sin(cameraAngle), newHorizontalDir.Z).Unit
	end
	
	-- เก็บค่า Input การเคลื่อนที่
	local moveInput = Vector3.new(0, 0, 0)
	
	-- รับ Input WASD
	if UserInputService:IsKeyDown(Enum.KeyCode.W) then
		moveInput = moveInput + Vector3.new(0, 0, -1) -- Forward
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then
		moveInput = moveInput + Vector3.new(0, 0, 1) -- Backward
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then
		moveInput = moveInput + Vector3.new(-1, 0, 0) -- Left
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then
		moveInput = moveInput + Vector3.new(1, 0, 0) -- Right
	end
	
	-- ปรับความสูงด้วย Q/E (จะปรับความสูงของพื้นที่มอง)
	local heightChange = 0
	if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
		heightChange = -1 -- ลง
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.E) then
		heightChange = 1 -- ขึ้น
	end
	
	-- ปรับระยะซูมด้วยล้อเมาส์ (สำหรับปรับระยะห่างของกล้อง)
	local zoomChange = 0
	if UserInputService:IsKeyDown(Enum.KeyCode.Z) then
		zoomChange = -1 -- ซูมเข้า
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.X) then
		zoomChange = 1 -- ซูมออก
	end
	
	-- คำนวณความเร็วในการเคลื่อนที่และความสูง
	local currentMoveSpeed = moveSpeed * freeCamMoveSpeedMultiplier * deltaTime * 60
	local currentHeightSpeed = moveSpeed * freeCamMoveSpeedMultiplier * deltaTime * 60
	local currentZoomSpeed = moveSpeed * freeCamMoveSpeedMultiplier * deltaTime * 60 * 2
	
	-- ปรับความสูงและระยะซูม
	freeCamHeight = math.clamp(freeCamHeight + heightChange * currentHeightSpeed, 10, 150)
	cameraDistance = math.clamp(cameraDistance + zoomChange * currentZoomSpeed, 10, 100)
	
	-- คำนวณทิศทางการเคลื่อนที่
	if moveInput.Magnitude > 0.01 then
		-- สร้าง CFrame จากทิศทางกล้องปัจจุบัน แต่ปรับให้อยู่ในแนวระนาบ
		local horizontalDir = Vector3.new(freeCamDirection.X, 0, freeCamDirection.Z).Unit
		local cameraCFrame = CFrame.lookAt(Vector3.new(0, 0, 0), horizontalDir)
		
		-- แปลง Input Vector เป็น World Space
		local moveDirection = cameraCFrame:VectorToWorldSpace(moveInput)
		
		-- เราต้องการให้เคลื่อนที่บนระนาบ XZ เท่านั้น
		moveDirection = Vector3.new(moveDirection.X, 0, moveDirection.Z)
		
		-- ทำให้เป็นหนึ่งหน่วย เพื่อให้ความเร็วคงที่
		if moveDirection.Magnitude > 0.01 then
			moveDirection = moveDirection.Unit
			
			-- อัพเดทตำแหน่งกล้อง
			freeCamPosition = freeCamPosition + moveDirection * currentMoveSpeed
		end
	end
	
	-- คำนวณตำแหน่งเป้าหมายที่กล้องมอง (พื้นที่เล่น)
	local targetPosition = Vector3.new(freeCamPosition.X, 0, freeCamPosition.Z)
	
	-- คำนวณเวกเตอร์ทิศทางในแนวระนาบ XZ
	local horizontalDirection = Vector3.new(freeCamDirection.X, 0, freeCamDirection.Z).Unit
	
	-- คำนวณตำแหน่งกล้องด้วยระยะห่างและมุมเอียง
	local offsetX = -horizontalDirection.X * cameraDistance * math.cos(cameraAngle)
	local offsetY = cameraDistance * math.sin(cameraAngle)
	local offsetZ = -horizontalDirection.Z * cameraDistance * math.cos(cameraAngle)
	
	local cameraOffset = Vector3.new(offsetX, offsetY, offsetZ)
	local cameraPosition = targetPosition + cameraOffset
	
	-- อัพเดทกล้อง
	camera.CFrame = CFrame.lookAt(cameraPosition, targetPosition)
end

-- Toggle camera mode
local function toggleCameraMode()
	if currentMode == "LockPlayer" then
		currentMode = "FreeCam"
		local playerInfo = findCurrentTurnPlayer()
		if playerInfo then
			freeCamPosition = Vector3.new(playerInfo.position.X, 0, playerInfo.position.Z)
			freeCamHeight = 30 -- ความสูงเริ่มต้นที่เหมาะสมสำหรับมุมมอง MOBA
			
			-- เก็บทิศทางกล้องเริ่มต้นจากผู้เล่น แต่ปรับให้เป็นมุมเอียงแบบ MOBA
			local horizontalDir = Vector3.new(playerInfo.lookVector.X, 0, playerInfo.lookVector.Z).Unit
			freeCamDirection = Vector3.new(horizontalDir.X, -math.sin(cameraAngle), horizontalDir.Z).Unit
		else
			freeCamPosition = findBoardCenter()
			freeCamHeight = 40
			-- ทิศทางเริ่มต้นแบบ MOBA มองจากด้านบนในมุมเอียง
			freeCamDirection = Vector3.new(0, -math.sin(cameraAngle), -math.cos(cameraAngle)).Unit
		end
		
		-- ตั้งค่าระยะกล้องและความสูงให้อยู่ในช่วงที่เหมาะสม
		cameraDistance = 30 -- ระยะห่างเริ่มต้นที่เหมาะสม
		freeCamHeight = math.clamp(freeCamHeight, 10, 150)
		
		camera.CameraType = Enum.CameraType.Scriptable
		camera.CameraSubject = nil
	else
		currentMode = "LockPlayer"
		camera.CameraType = Enum.CameraType.Scriptable
		updateLockPlayerCamera()
	end
end

-- Connect to turn system
local function connectToTurnSystem()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	if not remotes then return end
	local gameRemotes = remotes:FindFirstChild("GameRemotes")
	if not gameRemotes then return end
	local updateTurnEvent = gameRemotes:FindFirstChild("UpdateTurn")
	if not updateTurnEvent then return end
	connections.turnUpdate = updateTurnEvent.OnClientEvent:Connect(function(playerId)
		currentTurnPlayerId = playerId
		if currentMode == "LockPlayer" then
			updateLockPlayerCamera()
		end
	end)
end

-- Clean up connections
local function cleanup()
	for name, connection in pairs(connections) do
		if connection then connection:Disconnect(); connections[name] = nil end
	end
end

-- Initialize camera system
local function initCameraSystem()
	if not player.Character then player.CharacterAdded:Wait() end
	player.Character:WaitForChild("HumanoidRootPart")
	connectToTurnSystem()
	camera.CameraType = Enum.CameraType.Scriptable
	connections.inputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.V then toggleCameraMode() end
	end)
	connections.renderStepped = RunService.RenderStepped:Connect(function(deltaTime)
		if currentMode == "LockPlayer" then
			updateLockPlayerCamera()
		elseif currentMode == "FreeCam" then
			updateFreeCam(deltaTime)
		end
	end)
	player.CharacterRemoving:Connect(cleanup)
	script.Destroying:Connect(cleanup)
end

-- Start
initCameraSystem()

return CameraSystem
