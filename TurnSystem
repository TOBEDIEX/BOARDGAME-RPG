-- TurnSystem.lua
-- โมดูลจัดการระบบเทิร์นและลำดับเล่นของผู้เล่น
-- Version: 2.3.0 (Fixed Movement Coordination)

local TurnSystem = {}
TurnSystem.__index = TurnSystem

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Constants
local TURN_TIME_LIMIT = 60
local INACTIVITY_WARNING_TIME = 15
local MOVEMENT_SAFETY_DELAY = 0.8 -- เวลารอเพื่อให้แน่ใจว่าการเคลื่อนที่เสร็จสมบูรณ์

function TurnSystem.new()
	local self = setmetatable({}, TurnSystem)

	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimer = nil
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}
	self.pendingEndTurn = {}
	self.onTurnStart = nil
	self.onTurnEnd = nil
	self.onTurnTimerUpdate = nil
	self.remotes = nil
	self.debugMode = false

	return self
end

function TurnSystem:InitializeRemotes(gameRemotes)
	if not gameRemotes then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		gameRemotes = remotes:WaitForChild("GameRemotes")
	end

	self.remotes = {
		updateTurn = gameRemotes:WaitForChild("UpdateTurn"),
		updateTurnTimer = gameRemotes:FindFirstChild("UpdateTurnTimer") or Instance.new("RemoteEvent", gameRemotes),
		turnAction = gameRemotes:FindFirstChild("TurnAction") or Instance.new("RemoteEvent", gameRemotes),
		turnState = gameRemotes:FindFirstChild("TurnState") or Instance.new("RemoteEvent", gameRemotes)
	}

	-- Name events if newly created
	for name, event in pairs(self.remotes) do
		if event.Name ~= "UpdateTurn" and event.Name ~= name:sub(1,1):upper() .. name:sub(2) then
			event.Name = name:sub(1,1):upper() .. name:sub(2)
		end
	end

	-- Connect to turn action event
	self.remotes.turnAction.OnServerEvent:Connect(function(player, actionType, actionData)
		self:HandleTurnAction(player, actionType, actionData)
	end)

	return self.remotes
end

function TurnSystem:SetTurnOrder(players)
	if type(players) ~= "table" then return false end

	self.turnOrder = players
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false

	return true
end

function TurnSystem:CreateTurnOrderFromActivePlayers(playerManager)
	local playerOrder = {}

	if playerManager then
		local sortedPlayers = playerManager:GetPlayersSortedByJoinTime()
		for _, playerData in ipairs(sortedPlayers) do
			table.insert(playerOrder, playerData.player.UserId)
		end
	else
		for _, player in pairs(Players:GetPlayers()) do
			table.insert(playerOrder, player.UserId)
		end
	end

	-- Shuffle order for fairness
	self:ShuffleTurnOrder(playerOrder)

	-- Debug turn order
	if self.debugMode then
		print("[TurnSystem] Created turn order:", table.concat(playerOrder, ", "))
	end

	return self:SetTurnOrder(playerOrder)
end

function TurnSystem:ShuffleTurnOrder(order)
	local playerCount = #order
	for i = playerCount, 2, -1 do
		local j = math.random(i)
		order[i], order[j] = order[j], order[i]
	end
	return order
end

function TurnSystem:StartTurnSystem()
	if #self.turnOrder == 0 then return false end
	if self.debugMode then
		print("[TurnSystem] Starting turn system with " .. #self.turnOrder .. " players")
	end
	self:NextTurn()
	return true
end

function TurnSystem:StartPlayerTurn(playerID)
	if not playerID then return false end

	-- Check if player is still in game
	local player = Players:GetPlayerByUserId(playerID)
	if not player then
		self:NextTurn()
		return false
	end

	-- Check if player should skip turn
	if self.skipTurnPlayers[playerID] then
		self.skipTurnPlayers[playerID] = self.skipTurnPlayers[playerID] - 1
		if self.skipTurnPlayers[playerID] <= 0 then
			self.skipTurnPlayers[playerID] = nil
		end
		self:NextTurn()
		return false
	end

	-- Set current turn data
	self.currentPlayerTurn = playerID
	self.isTurnActive = true
	self.turnTimeRemaining = TURN_TIME_LIMIT

	-- Clear pending end turn state
	self.pendingEndTurn[playerID] = nil

	-- Notify clients - IMPORTANT to fire UpdateTurn to trigger DiceRollUI
	if self.debugMode then
		print("[TurnSystem] Starting turn for player " .. playerID)
	end

	self.remotes.updateTurn:FireAllClients(playerID)

	-- Send additional turn state to the player
	self.remotes.turnState:FireClient(player, {
		timeLimit = TURN_TIME_LIMIT,
		isYourTurn = true
	})

	-- Start turn timer
	self:StartTurnTimer()

	-- Call turn start callback
	if self.onTurnStart then
		self.onTurnStart(playerID)
	end

	return true
end

function TurnSystem:StartTurnTimer()
	-- Clear previous timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Start new timer
	local startTime = os.time()

	self.turnTimer = game:GetService("RunService").Heartbeat:Connect(function()
		if not self.isTurnActive then return end

		-- Calculate remaining time
		local elapsedTime = os.time() - startTime
		self.turnTimeRemaining = math.max(0, TURN_TIME_LIMIT - elapsedTime)

		-- Update every second
		if elapsedTime % 1 == 0 then
			-- Send time to all clients
			self.remotes.updateTurnTimer:FireAllClients(self.turnTimeRemaining)

			-- Call timer update callback
			if self.onTurnTimerUpdate then
				self.onTurnTimerUpdate(self.turnTimeRemaining)
			end

			-- Warn player when time is running out
			if self.turnTimeRemaining == INACTIVITY_WARNING_TIME then
				local player = Players:GetPlayerByUserId(self.currentPlayerTurn)
				if player then
					self.remotes.turnState:FireClient(player, {
						warning = "Turn time is running out!",
						timeLeft = self.turnTimeRemaining
					})
				end
			end

			-- End turn when time runs out
			if self.turnTimeRemaining <= 0 then
				self:EndPlayerTurn(self.currentPlayerTurn, "timeout")
			end
		end
	end)
end

function TurnSystem:EndPlayerTurn(playerID, reason)
	reason = reason or "normal"

	-- Check for pending end turn to avoid multiple calls
	if self.pendingEndTurn[playerID] then
		if self.debugMode then
			print("[TurnSystem] Turn end already pending for player", playerID)
		end
		return false
	end

	-- Check if it's the correct player's turn
	if playerID ~= self.currentPlayerTurn then 
		if self.debugMode then
			print("[TurnSystem] Attempting to end turn for wrong player. Expected:", 
				self.currentPlayerTurn, "Got:", playerID)
		end
		return false 
	end

	-- For movement-related reasons, add a delay for animation completion
	if reason == "move_complete" or reason == "move_timeout" then
		-- Track the pending end
		self.pendingEndTurn[playerID] = {
			reason = reason,
			timestamp = os.time()
		}

		-- Delay turn end to ensure animations are complete
		task.spawn(function()
			task.wait(MOVEMENT_SAFETY_DELAY)

			-- Verify it's still the current turn
			if self.currentPlayerTurn == playerID and self.pendingEndTurn[playerID] then
				-- Get ending reason and clear pending data
				local endingReason = self.pendingEndTurn[playerID].reason
				self.pendingEndTurn[playerID] = nil

				-- Execute actual turn end
				self:ExecuteEndTurn(playerID, endingReason)
			end
		end)

		return true
	else
		-- For non-movement reasons, end turn immediately
		return self:ExecuteEndTurn(playerID, reason)
	end
end

function TurnSystem:ExecuteEndTurn(playerID, reason)
	-- Double-check it's the correct player's turn
	if playerID ~= self.currentPlayerTurn then 
		if self.debugMode then
			print("[TurnSystem] ExecuteEndTurn called for wrong player:", playerID, "current turn:", self.currentPlayerTurn)
		end
		return false 
	end

	-- Store current player for callbacks
	local endingPlayerID = self.currentPlayerTurn

	-- Update turn state
	self.isTurnActive = false

	-- Stop timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Call turn end callback
	if self.onTurnEnd then
		self.onTurnEnd(endingPlayerID, reason)
	end

	-- Notify player
	local player = Players:GetPlayerByUserId(endingPlayerID)
	if player then
		self.remotes.turnState:FireClient(player, {
			isYourTurn = false,
			turnEnded = true,
			reason = reason
		})
	end

	if self.debugMode then
		print("[TurnSystem] Turn ended for player", endingPlayerID, "reason:", reason)
	end

	-- Brief pause before next turn
	task.wait(0.1)

	-- Move to next turn
	self:NextTurn()

	return true
end

function TurnSystem:NextTurn()
	if #self.turnOrder == 0 then 
		if self.debugMode then
			print("[TurnSystem] No players in turn order")
		end
		return false 
	end

	-- Increment turn index to next player
	self.currentTurnIndex = (self.currentTurnIndex % #self.turnOrder) + 1
	local nextPlayerID = self.turnOrder[self.currentTurnIndex]

	if self.debugMode then
		print("[TurnSystem] Moving to next turn. Current index:", self.currentTurnIndex, 
			"Next player:", nextPlayerID)
	end

	-- Start next player's turn
	self:StartPlayerTurn(nextPlayerID)

	return true
end

function TurnSystem:SetPlayerSkipTurns(playerID, turns)
	if not playerID then return false end

	if turns and turns > 0 then
		self.skipTurnPlayers[playerID] = turns
	else
		self.skipTurnPlayers[playerID] = nil
	end

	return true
end

function TurnSystem:GetCurrentPlayerTurn()
	return self.currentPlayerTurn
end

function TurnSystem:IsPlayerTurn(playerID)
	return playerID == self.currentPlayerTurn
end

function TurnSystem:HandleTurnAction(player, actionType, actionData)
	local playerID = player.UserId

	-- Check if it's player's turn
	if not self:IsPlayerTurn(playerID) then 
		if self.debugMode then
			print("[TurnSystem] Player", playerID, "attempted action", actionType, "but it's not their turn")
		end
		return false 
	end

	-- Handle different action types
	if actionType == "endTurn" then
		return self:EndPlayerTurn(playerID, "player_choice")
	elseif actionType == "rollDice" then
		return true -- Handled by other systems
	elseif actionType == "useItem" then
		return true -- Handled by other systems
	end

	return false
end

function TurnSystem:HandlePlayerLeaving(playerID)
	-- Remove player from turn order
	for i = #self.turnOrder, 1, -1 do
		if self.turnOrder[i] == playerID then
			table.remove(self.turnOrder, i)
			break
		end
	end

	-- If it was this player's turn, move to next turn
	if playerID == self.currentPlayerTurn then
		self:NextTurn()
	elseif self.currentTurnIndex > #self.turnOrder then
		self.currentTurnIndex = 1
	end

	-- Clear player data
	self.skipTurnPlayers[playerID] = nil
	self.turnStates[playerID] = nil
	self.pendingEndTurn[playerID] = nil

	return true
end

function TurnSystem:Reset()
	-- Stop timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Clear all data
	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}
	self.pendingEndTurn = {}

	return true
end

function TurnSystem:EnableDebugMode(enabled)
	self.debugMode = enabled or false
	print("[TurnSystem] Debug mode " .. (self.debugMode and "enabled" or "disabled"))
	return self.debugMode
end

return TurnSystem
