-- TurnSystem.lua
-- โมดูลจัดการระบบเทิร์นและลำดับเล่นของผู้เล่น
-- Version: 2.0.0
-- ตำแหน่งที่ถูกต้อง: ServerStorage/Modules/Systems/TurnSystem.lua

local TurnSystem = {}
TurnSystem.__index = TurnSystem

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Constants
local TURN_TIME_LIMIT = 120 -- จำนวนวินาทีสูงสุดต่อเทิร์น
local INACTIVITY_WARNING_TIME = 90 -- เวลาที่จะเตือนผู้เล่นว่าใกล้หมดเวลา

function TurnSystem.new()
	local self = setmetatable({}, TurnSystem)

	-- ข้อมูลเทิร์นและลำดับเล่น
	self.turnOrder = {}           -- ลำดับของผู้เล่น (array of playerIDs)
	self.currentTurnIndex = 0     -- ดัชนีปัจจุบันในลำดับเทิร์น
	self.currentPlayerTurn = nil  -- playerID ที่กำลังเล่นอยู่
	self.isTurnActive = false     -- สถานะว่ากำลังอยู่ในเทิร์นหรือไม่

	-- ตัวจับเวลาสำหรับแต่ละเทิร์น
	self.turnTimer = nil          -- ตัวจับเวลาสำหรับจำกัดเวลาในเทิร์น
	self.turnTimeRemaining = 0    -- เวลาที่เหลือในเทิร์นปัจจุบัน

	-- สถานะพิเศษ
	self.turnStates = {}          -- สถานะพิเศษต่างๆ ของเทิร์น (combat, shop, etc.)
	self.skipTurnPlayers = {}     -- ผู้เล่นที่ต้องข้ามเทิร์น

	-- Event callbacks
	self.onTurnStart = nil        -- เมื่อเริ่มเทิร์นใหม่
	self.onTurnEnd = nil          -- เมื่อจบเทิร์น
	self.onTurnTimerUpdate = nil  -- เมื่ออัปเดตเวลาเทิร์น

	-- Remote Events
	self.remotes = nil            -- จะถูกกำหนดค่าใน InitializeRemotes

	return self
end

-- ฟังก์ชันตั้งค่าการสื่อสารกับ Remote Events
function TurnSystem:InitializeRemotes(gameRemotes)
	if not gameRemotes then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		gameRemotes = remotes:WaitForChild("GameRemotes")
	end

	self.remotes = {
		updateTurn = gameRemotes:WaitForChild("UpdateTurn"),
		updateTurnTimer = gameRemotes:FindFirstChild("UpdateTurnTimer") or Instance.new("RemoteEvent", gameRemotes),
		turnAction = gameRemotes:FindFirstChild("TurnAction") or Instance.new("RemoteEvent", gameRemotes),
		turnState = gameRemotes:FindFirstChild("TurnState") or Instance.new("RemoteEvent", gameRemotes)
	}

	-- ตั้งชื่อ RemoteEvents ที่สร้างขึ้นใหม่
	if self.remotes.updateTurnTimer.Name ~= "UpdateTurnTimer" then
		self.remotes.updateTurnTimer.Name = "UpdateTurnTimer"
	end
	if self.remotes.turnAction.Name ~= "TurnAction" then
		self.remotes.turnAction.Name = "TurnAction"
	end
	if self.remotes.turnState.Name ~= "TurnState" then
		self.remotes.turnState.Name = "TurnState"
	end

	-- เชื่อมต่อกับ Remote Events
	self.remotes.turnAction.OnServerEvent:Connect(function(player, actionType, actionData)
		self:HandleTurnAction(player, actionType, actionData)
	end)

	return self.remotes
end

-- ฟังก์ชันกำหนดลำดับเทิร์นของผู้เล่น
function TurnSystem:SetTurnOrder(players)
	if type(players) == "table" then
		self.turnOrder = players
	else
		warn("Invalid players table provided to SetTurnOrder")
		return false
	end

	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false

	print("Turn order set with " .. #self.turnOrder .. " players")
	return true
end

-- ฟังก์ชันสร้างลำดับเทิร์นจากผู้เล่นที่เข้าร่วมเกม
function TurnSystem:CreateTurnOrderFromActivePlayers(playerManager)
	local playerOrder = {}

	if playerManager then
		-- ใช้ PlayerManager เพื่อรับข้อมูลผู้เล่นเรียงตามเวลาเข้าร่วม
		local sortedPlayers = playerManager:GetPlayersSortedByJoinTime()

		for _, playerData in ipairs(sortedPlayers) do
			table.insert(playerOrder, playerData.player.UserId)
		end
	else
		-- หากไม่มี PlayerManager ให้ใช้รายการผู้เล่นปัจจุบัน
		for _, player in pairs(Players:GetPlayers()) do
			table.insert(playerOrder, player.UserId)
		end
	end

	-- สับเปลี่ยนลำดับเพื่อความยุติธรรม
	self:ShuffleTurnOrder(playerOrder)

	-- ตั้งค่าลำดับเทิร์น
	return self:SetTurnOrder(playerOrder)
end

-- ฟังก์ชันสับเปลี่ยนลำดับเทิร์น
function TurnSystem:ShuffleTurnOrder(order)
	local playerCount = #order
	for i = playerCount, 2, -1 do
		local j = math.random(i)
		order[i], order[j] = order[j], order[i]
	end
	return order
end

-- ฟังก์ชันเริ่มระบบเทิร์น
function TurnSystem:StartTurnSystem()
	if #self.turnOrder == 0 then
		warn("Cannot start turn system with empty turn order")
		return false
	end

	print("Starting turn system with " .. #self.turnOrder .. " players")

	-- เริ่มต้นเทิร์นแรก
	self:NextTurn()

	return true
end

-- ฟังก์ชันเริ่มเทิร์นของผู้เล่น
function TurnSystem:StartPlayerTurn(playerID)
	if not playerID then
		warn("Invalid playerID provided to StartPlayerTurn")
		return false
	end

	-- ตรวจสอบว่าผู้เล่นยังอยู่ในเกม
	local player = Players:GetPlayerByUserId(playerID)
	if not player then
		print("Player " .. playerID .. " not found, skipping turn")
		self:NextTurn()
		return false
	end

	-- ตรวจสอบว่าเป็นผู้เล่นที่ต้องข้ามเทิร์นหรือไม่
	if self.skipTurnPlayers[playerID] then
		print("Player " .. player.Name .. " is set to skip turn")
		self.skipTurnPlayers[playerID] = self.skipTurnPlayers[playerID] - 1

		if self.skipTurnPlayers[playerID] <= 0 then
			self.skipTurnPlayers[playerID] = nil
		end

		self:NextTurn()
		return false
	end

	-- ตั้งค่าข้อมูลเทิร์นปัจจุบัน
	self.currentPlayerTurn = playerID
	self.isTurnActive = true
	self.turnTimeRemaining = TURN_TIME_LIMIT

	-- แจ้งไปยังทุกคลเอนต์ว่าเป็นเทิร์นของใคร
	self.remotes.updateTurn:FireAllClients(playerID)

	-- ส่งข้อมูลสถานะเทิร์นไปยังผู้เล่นปัจจุบัน
	self.remotes.turnState:FireClient(player, {
		timeLimit = TURN_TIME_LIMIT,
		isYourTurn = true
	})

	-- เริ่มตัวจับเวลาเทิร์น
	self:StartTurnTimer()

	-- เรียกใช้ callback เมื่อเริ่มเทิร์น
	if self.onTurnStart then
		self.onTurnStart(playerID)
	end

	print("Started turn for player " .. player.Name)
	return true
end

-- ฟังก์ชันเริ่มตัวจับเวลาเทิร์น
function TurnSystem:StartTurnTimer()
	-- เคลียร์ตัวจับเวลาเดิม
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- เริ่มตัวจับเวลาใหม่
	local startTime = os.time()

	self.turnTimer = game:GetService("RunService").Heartbeat:Connect(function()
		if not self.isTurnActive then return end

		-- คำนวณเวลาที่เหลือ
		local elapsedTime = os.time() - startTime
		self.turnTimeRemaining = math.max(0, TURN_TIME_LIMIT - elapsedTime)

		-- อัปเดตเวลาทุก 1 วินาที
		if elapsedTime % 1 == 0 then
			-- ส่งข้อมูลเวลาไปยังทุกคลเอนต์
			self.remotes.updateTurnTimer:FireAllClients(self.turnTimeRemaining)

			-- เรียกใช้ callback เมื่ออัปเดตเวลา
			if self.onTurnTimerUpdate then
				self.onTurnTimerUpdate(self.turnTimeRemaining)
			end

			-- ตรวจสอบว่าใกล้หมดเวลาหรือไม่
			if self.turnTimeRemaining == INACTIVITY_WARNING_TIME then
				-- ส่งคำเตือนไปยังผู้เล่นปัจจุบัน
				local player = Players:GetPlayerByUserId(self.currentPlayerTurn)
				if player then
					self.remotes.turnState:FireClient(player, {
						warning = "Turn time is running out!",
						timeLeft = self.turnTimeRemaining
					})
				end
			end

			-- ตรวจสอบว่าหมดเวลาหรือไม่
			if self.turnTimeRemaining <= 0 then
				self:EndPlayerTurn(self.currentPlayerTurn, "timeout")
			end
		end
	end)
end

-- ฟังก์ชันจบเทิร์นของผู้เล่น
function TurnSystem:EndPlayerTurn(playerID, reason)
	reason = reason or "normal"

	-- ตรวจสอบว่าเป็นเทิร์นของผู้เล่นที่ระบุหรือไม่
	if playerID ~= self.currentPlayerTurn then
		warn("Attempted to end turn for player " .. playerID .. " but current turn is for " .. (self.currentPlayerTurn or "none"))
		return false
	end

	-- ล้างตัวแปรเทิร์นปัจจุบัน
	local endingPlayerID = self.currentPlayerTurn
	self.isTurnActive = false

	-- หยุดตัวจับเวลา
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- เรียกใช้ callback เมื่อจบเทิร์น
	if self.onTurnEnd then
		self.onTurnEnd(endingPlayerID, reason)
	end

	-- แจ้งผู้เล่นว่าเทิร์นจบแล้ว
	local player = Players:GetPlayerByUserId(endingPlayerID)
	if player then
		self.remotes.turnState:FireClient(player, {
			isYourTurn = false,
			turnEnded = true,
			reason = reason
		})
	end

	print("Ended turn for player " .. (player and player.Name or endingPlayerID) .. " (Reason: " .. reason .. ")")

	-- ไปยังเทิร์นถัดไป
	self:NextTurn()

	return true
end

-- ฟังก์ชันข้ามไปยังเทิร์นถัดไป
function TurnSystem:NextTurn()
	if #self.turnOrder == 0 then
		warn("Cannot proceed to next turn with empty turn order")
		return false
	end

	-- เพิ่มดัชนีเทิร์นไปยังผู้เล่นถัดไป
	self.currentTurnIndex = (self.currentTurnIndex % #self.turnOrder) + 1
	local nextPlayerID = self.turnOrder[self.currentTurnIndex]

	-- เริ่มเทิร์นของผู้เล่นถัดไป
	self:StartPlayerTurn(nextPlayerID)

	return true
end

-- ฟังก์ชันตั้งค่าการข้ามเทิร์นสำหรับผู้เล่น
function TurnSystem:SetPlayerSkipTurns(playerID, turns)
	if not playerID then return false end

	if turns and turns > 0 then
		self.skipTurnPlayers[playerID] = turns
		print("Player " .. playerID .. " set to skip " .. turns .. " turns")
	else
		self.skipTurnPlayers[playerID] = nil
		print("Removed turn skip for player " .. playerID)
	end

	return true
end

-- ฟังก์ชันตั้งค่าสถานะพิเศษของเทิร์น (เช่น กำลังต่อสู้, กำลังซื้อของ)
function TurnSystem:SetTurnState(playerID, stateName, stateValue)
	if not playerID or not stateName then return false end

	if not self.turnStates[playerID] then
		self.turnStates[playerID] = {}
	end

	self.turnStates[playerID][stateName] = stateValue

	-- แจ้งผู้เล่นเกี่ยวกับการเปลี่ยนแปลงสถานะ
	local player = Players:GetPlayerByUserId(playerID)
	if player then
		self.remotes.turnState:FireClient(player, {
			state = stateName,
			value = stateValue
		})
	end

	return true
end

-- ฟังก์ชันรับค่าสถานะพิเศษของเทิร์น
function TurnSystem:GetTurnState(playerID, stateName)
	if not playerID or not self.turnStates[playerID] then return nil end

	return stateName and self.turnStates[playerID][stateName] or self.turnStates[playerID]
end

-- ฟังก์ชันรับค่า playerID ที่กำลังเล่นอยู่
function TurnSystem:GetCurrentPlayerTurn()
	return self.currentPlayerTurn
end

-- ฟังก์ชันตรวจสอบว่าเป็นเทิร์นของผู้เล่นหรือไม่
function TurnSystem:IsPlayerTurn(playerID)
	return playerID == self.currentPlayerTurn
end

-- ฟังก์ชันจัดการกับการกระทำในเทิร์น
function TurnSystem:HandleTurnAction(player, actionType, actionData)
	local playerID = player.UserId

	-- ตรวจสอบว่าเป็นเทิร์นของผู้เล่นหรือไม่
	if not self:IsPlayerTurn(playerID) then
		warn("Player " .. player.Name .. " attempted action during another player's turn")
		return false
	end

	-- จัดการกับแต่ละประเภทของการกระทำ
	if actionType == "endTurn" then
		-- ผู้เล่นเลือกจบเทิร์น
		return self:EndPlayerTurn(playerID, "player_choice")
	elseif actionType == "rollDice" then
		-- ผู้เล่นทอยลูกเต๋า (ไม่ต้องทำอะไรเพิ่ม เพราะจะมีการจัดการในระบบอื่น)
		return true
	elseif actionType == "useItem" then
		-- ผู้เล่นใช้ไอเทม (ต้องมีการจัดการในระบบอื่น)
		return true
	end

	return false
end

-- ฟังก์ชันอัปเดตลำดับเทิร์นเมื่อผู้เล่นออกจากเกม
function TurnSystem:HandlePlayerLeaving(playerID)
	-- ลบผู้เล่นออกจากลำดับเทิร์น
	for i = #self.turnOrder, 1, -1 do
		if self.turnOrder[i] == playerID then
			table.remove(self.turnOrder, i)
			break
		end
	end

	-- ถ้าเป็นเทิร์นของผู้เล่นที่ออกไป ให้ข้ามไปยังเทิร์นถัดไป
	if playerID == self.currentPlayerTurn then
		print("Current turn player left the game, moving to next turn")
		self:NextTurn()
	elseif self.currentTurnIndex > #self.turnOrder then
		-- ปรับดัชนีเทิร์นหากผู้เล่นที่ออกไปทำให้ดัชนีเกินขอบเขต
		self.currentTurnIndex = 1
	end

	-- ล้างข้อมูลการข้ามเทิร์น
	self.skipTurnPlayers[playerID] = nil

	-- ล้างข้อมูลสถานะพิเศษ
	self.turnStates[playerID] = nil

	return true
end

-- ฟังก์ชันรีเซ็ตระบบเทิร์น
function TurnSystem:Reset()
	-- หยุดตัวจับเวลา
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- ล้างข้อมูลเทิร์น
	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}

	print("Turn system reset")
	return true
end

return TurnSystem
