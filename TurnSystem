-- TurnSystem.lua
-- Module for managing turn system and player order
-- Version: 3.1.0 (Fixed Crystal Management)

local TurnSystem = {}
TurnSystem.__index = TurnSystem

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Constants
local TURN_TIME_LIMIT = 60
local INACTIVITY_WARNING_TIME = 15
local MOVEMENT_SAFETY_DELAY = 0.8
local CRYSTAL_MOVEMENT_MAX_TIME = 20 -- Maximum time to complete crystal movement

function TurnSystem.new()
	local self = setmetatable({}, TurnSystem)

	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimer = nil
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}
	self.pendingEndTurn = {}
	self.activeCrystalMovements = {} -- NEW: Track crystal movements
	self.onTurnStart = nil
	self.onTurnEnd = nil
	self.onTurnTimerUpdate = nil
	self.remotes = nil

	return self
end

function TurnSystem:InitializeRemotes(gameRemotes)
	if not gameRemotes then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		gameRemotes = remotes:WaitForChild("GameRemotes")
	end

	self.remotes = {
		updateTurn = gameRemotes:WaitForChild("UpdateTurn"),
		updateTurnTimer = gameRemotes:FindFirstChild("UpdateTurnTimer") or Instance.new("RemoteEvent", gameRemotes),
		turnAction = gameRemotes:FindFirstChild("TurnAction") or Instance.new("RemoteEvent", gameRemotes),
		turnState = gameRemotes:FindFirstChild("TurnState") or Instance.new("RemoteEvent", gameRemotes)
	}

	-- Name events if newly created
	for name, event in pairs(self.remotes) do
		if event.Name ~= "UpdateTurn" and event.Name ~= name:sub(1,1):upper() .. name:sub(2) then
			event.Name = name:sub(1,1):upper() .. name:sub(2)
		end
	end

	-- Connect to turn action event
	self.remotes.turnAction.OnServerEvent:Connect(function(player, actionType, actionData)
		self:HandleTurnAction(player, actionType, actionData)
	end)

	-- Create Crystal Movement event if needed
	local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
	local crystalMoveCompleteEvent = boardRemotes:FindFirstChild("CrystalMoveComplete")
	if not crystalMoveCompleteEvent then
		crystalMoveCompleteEvent = Instance.new("RemoteEvent")
		crystalMoveCompleteEvent.Name = "CrystalMoveComplete"
		crystalMoveCompleteEvent.Parent = boardRemotes
	end

	-- Connect to crystal move complete event
	crystalMoveCompleteEvent.OnServerEvent:Connect(function(player)
		self:HandleCrystalMoveComplete(player)
	end)

	-- Create ItemPermissionUpdate event for turn changes
	local inventoryRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("InventoryRemotes")
	local itemPermissionEvent = inventoryRemotes:FindFirstChild("ItemPermissionUpdate")
	if not itemPermissionEvent then
		itemPermissionEvent = Instance.new("RemoteEvent")
		itemPermissionEvent.Name = "ItemPermissionUpdate"
		itemPermissionEvent.Parent = inventoryRemotes
	end

	return self.remotes
end

function TurnSystem:SetTurnOrder(players)
	if type(players) ~= "table" then return false end

	self.turnOrder = players
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false

	return true
end

function TurnSystem:CreateTurnOrderFromActivePlayers(playerManager)
	local playerOrder = {}

	if playerManager then
		local sortedPlayers = playerManager:GetPlayersSortedByJoinTime()
		for _, playerData in ipairs(sortedPlayers) do
			table.insert(playerOrder, playerData.player.UserId)
		end
	else
		for _, player in pairs(Players:GetPlayers()) do
			table.insert(playerOrder, player.UserId)
		end
	end

	-- Shuffle order for fairness
	self:ShuffleTurnOrder(playerOrder)

	return self:SetTurnOrder(playerOrder)
end

function TurnSystem:ShuffleTurnOrder(order)
	local playerCount = #order
	for i = playerCount, 2, -1 do
		local j = math.random(i)
		order[i], order[j] = order[j], order[i]
	end
	return order
end

function TurnSystem:StartTurnSystem()
	if #self.turnOrder == 0 then return false end
	self:NextTurn()
	return true
end

-- NEW: Check if player is using a crystal
function TurnSystem:IsPlayerUsingCrystal(playerID)
	return self.activeCrystalMovements[playerID] ~= nil
end

-- NEW: Register crystal movement
function TurnSystem:RegisterCrystalMovement(playerID, steps)
	if not playerID then return false end

	-- Check if it's player's turn
	if playerID ~= self.currentPlayerTurn then
		return false
	end

	self.activeCrystalMovements[playerID] = {
		steps = steps,
		startTime = os.time(),
		completed = false
	}

	print("[TurnSystem] Registered crystal movement for player " .. playerID .. " with " .. steps .. " steps")
	return true
end

-- NEW: Handle crystal movement completion
function TurnSystem:HandleCrystalMoveComplete(player)
	local playerID = player.UserId

	-- Check if there's an active crystal movement
	if not self.activeCrystalMovements[playerID] then
		return false
	end

	print("[TurnSystem] Processing crystal movement completion for player " .. playerID)

	-- Mark as completed
	self.activeCrystalMovements[playerID].completed = true

	-- Check if it's player's turn
	if playerID == self.currentPlayerTurn then
		-- End turn with special reason
		task.wait(0.5) -- Short delay for animations
		self:EndPlayerTurn(playerID, "crystal_move_complete")
	end

	-- Clear crystal movement state
	self.activeCrystalMovements[playerID] = nil

	return true
end

function TurnSystem:StartPlayerTurn(playerID)
	if not playerID then return false end

	-- Check if player is still in game
	local player = Players:GetPlayerByUserId(playerID)
	if not player then
		self:NextTurn()
		return false
	end

	-- Check if player should skip turn
	if self.skipTurnPlayers[playerID] then
		self.skipTurnPlayers[playerID] = self.skipTurnPlayers[playerID] - 1
		if self.skipTurnPlayers[playerID] <= 0 then
			self.skipTurnPlayers[playerID] = nil
		end
		self:NextTurn()
		return false
	end

	-- Set current turn data
	self.currentPlayerTurn = playerID
	self.isTurnActive = true
	self.turnTimeRemaining = TURN_TIME_LIMIT

	-- Add debug log for turn start
	print("[TurnSystem] Starting turn for playerID: " .. playerID)

	-- Clear pending end turn state
	self.pendingEndTurn[playerID] = nil

	-- IMPROVED: Clear any other states that might block item usage
	if not self.turnStates[playerID] then
		self.turnStates[playerID] = {}
	end

	if self.turnStates[playerID].blockItemUsage then
		self.turnStates[playerID].blockItemUsage = nil
		print("[TurnSystem] Cleared blockItemUsage flag for player " .. playerID)
	end

	-- Initialize turn state with explicit item usage permission
	self.turnStates[playerID].canUseItems = true

	-- Clear player dice bonus uses (should be done at turn start too)
	if _G.GameManager and _G.GameManager.inventoryService and 
		_G.GameManager.inventoryService.ResetDiceBonusUse then
		print("[TurnSystem] Resetting dice bonus usage at turn start")
		_G.GameManager.inventoryService.ResetDiceBonusUse(playerID)
	end

	-- Notify clients
	self.remotes.updateTurn:FireAllClients(playerID)

	-- Send additional turn state to the player
	self.remotes.turnState:FireClient(player, {
		timeLimit = TURN_TIME_LIMIT,
		isYourTurn = true,
		canUseItems = true  -- Explicitly tell client it can use items
	})

	-- Broadcast item permission update
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local inventoryRemotes = remotes:WaitForChild("InventoryRemotes")
	local itemPermissionEvent = inventoryRemotes:FindFirstChild("ItemPermissionUpdate")
	if itemPermissionEvent then
		itemPermissionEvent:FireAllClients(playerID)
	end

	-- Start turn timer
	self:StartTurnTimer()

	-- Call turn start callback
	if self.onTurnStart then
		self.onTurnStart(playerID)
	end

	return true
end

function TurnSystem:StartTurnTimer()
	-- Clear previous timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Start new timer
	local startTime = os.time()

	self.turnTimer = game:GetService("RunService").Heartbeat:Connect(function()
		if not self.isTurnActive then return end

		-- Calculate remaining time
		local elapsedTime = os.time() - startTime
		self.turnTimeRemaining = math.max(0, TURN_TIME_LIMIT - elapsedTime)

		-- Update every second
		if elapsedTime % 1 == 0 then
			-- Send time to all clients
			self.remotes.updateTurnTimer:FireAllClients(self.turnTimeRemaining)

			-- Call timer update callback
			if self.onTurnTimerUpdate then
				self.onTurnTimerUpdate(self.turnTimeRemaining)
			end

			-- Warn player when time is running out
			if self.turnTimeRemaining == INACTIVITY_WARNING_TIME then
				local player = Players:GetPlayerByUserId(self.currentPlayerTurn)
				if player then
					self.remotes.turnState:FireClient(player, {
						warning = "Turn time is running out!",
						timeLeft = self.turnTimeRemaining
					})
				end
			end

			-- End turn when time runs out
			if self.turnTimeRemaining <= 0 then
				self:EndPlayerTurn(self.currentPlayerTurn, "timeout")
			end

			-- IMPROVED: Check for stalled crystal movements
			for playerID, crystalData in pairs(self.activeCrystalMovements) do
				if playerID == self.currentPlayerTurn and not crystalData.completed then
					local crystalElapsedTime = os.time() - crystalData.startTime

					-- If crystal movement has taken too long, force completion
					if crystalElapsedTime > CRYSTAL_MOVEMENT_MAX_TIME then
						print("[TurnSystem] Crystal movement timeout for player " .. playerID)

						-- Mark as completed
						self.activeCrystalMovements[playerID].completed = true

						-- End turn
						self:EndPlayerTurn(playerID, "crystal_move_timeout")

						-- Clear crystal movement state
						self.activeCrystalMovements[playerID] = nil

						-- Notify all clients
						local boardRemotes = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes")
						local crystalMoveCompleteEvent = boardRemotes:FindFirstChild("CrystalMoveComplete")
						if crystalMoveCompleteEvent then
							crystalMoveCompleteEvent:FireAllClients(playerID)
						end

						-- Also update inventory
						local gameManager = _G.GameManager
						if gameManager and gameManager.inventoryService and gameManager.inventoryService.ResetCrystalMovement then
							gameManager.inventoryService.ResetCrystalMovement(playerID)
						end
					end
				end
			end
		end
	end)
end

function TurnSystem:EndPlayerTurn(playerID, reason)
	reason = reason or "normal"

	-- Check for pending end turn to avoid multiple calls
	if self.pendingEndTurn[playerID] then
		return false
	end

	-- Check if it's the correct player's turn
	if playerID ~= self.currentPlayerTurn then 
		return false 
	end

	-- IMPROVED: Handle crystal movements specially
	if reason == "crystal_move_complete" or reason == "crystal_move_timeout" then
		-- End turn immediately for crystal movements
		return self:ExecuteEndTurn(playerID, reason)
	end

	-- For movement-related reasons, add a delay for animation completion
	if reason == "move_complete" or reason == "move_timeout" then
		-- Track the pending end
		self.pendingEndTurn[playerID] = {
			reason = reason,
			timestamp = os.time()
		}

		-- Delay turn end to ensure animations are complete
		task.spawn(function()
			task.wait(MOVEMENT_SAFETY_DELAY)

			-- Verify it's still the current turn
			if self.currentPlayerTurn == playerID and self.pendingEndTurn[playerID] then
				-- Get ending reason and clear pending data
				local endingReason = self.pendingEndTurn[playerID].reason
				self.pendingEndTurn[playerID] = nil

				-- Execute actual turn end
				self:ExecuteEndTurn(playerID, endingReason)
			end
		end)

		return true
	else
		-- For non-movement reasons, end turn immediately
		return self:ExecuteEndTurn(playerID, reason)
	end
end

function TurnSystem:ExecuteEndTurn(playerID, reason)
	-- Double-check it's the correct player's turn
	if playerID ~= self.currentPlayerTurn then 
		return false 
	end

	-- Store current player for callbacks
	local endingPlayerID = self.currentPlayerTurn

	-- Update turn state
	self.isTurnActive = false

	-- Stop timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Call turn end callback
	if self.onTurnEnd then
		self.onTurnEnd(endingPlayerID, reason)
	end

	-- Notify player
	local player = Players:GetPlayerByUserId(endingPlayerID)
	if player then
		self.remotes.turnState:FireClient(player, {
			isYourTurn = false,
			turnEnded = true,
			reason = reason,
			canUseItems = false  -- Explicitly tell client it cannot use items
		})
	end

	-- Clear any active crystal movements for this player
	if self.activeCrystalMovements[endingPlayerID] then
		self.activeCrystalMovements[endingPlayerID] = nil

		-- Also update inventory
		local gameManager = _G.GameManager
		if gameManager and gameManager.inventoryService and gameManager.inventoryService.ResetCrystalMovement then
			gameManager.inventoryService.ResetCrystalMovement(endingPlayerID)
		end
	end

	-- Brief pause before next turn
	task.wait(0.1)

	-- Move to next turn
	self:NextTurn()

	return true
end

function TurnSystem:NextTurn()
	if #self.turnOrder == 0 then 
		return false 
	end

	-- Increment turn index to next player
	self.currentTurnIndex = (self.currentTurnIndex % #self.turnOrder) + 1
	local nextPlayerID = self.turnOrder[self.currentTurnIndex]

	-- Start next player's turn
	self:StartPlayerTurn(nextPlayerID)

	return true
end

function TurnSystem:SetPlayerSkipTurns(playerID, turns)
	if not playerID then return false end

	if turns and turns > 0 then
		self.skipTurnPlayers[playerID] = turns
	else
		self.skipTurnPlayers[playerID] = nil
	end

	return true
end

function TurnSystem:GetCurrentPlayerTurn()
	return self.currentPlayerTurn
end

function TurnSystem:IsPlayerTurn(playerID)
	local result = playerID == self.currentPlayerTurn

	-- Add debug logging
	print("[TurnSystem] IsPlayerTurn check for player " .. tostring(playerID) .. 
		": " .. tostring(result) .. " (current turn: " .. tostring(self.currentPlayerTurn) .. ")")

	return result
end

function TurnSystem:HandleTurnAction(player, actionType, actionData)
	local playerID = player.UserId

	-- Add debug logging for all turn actions
	print("[TurnSystem] Handling action " .. actionType .. " from player " .. playerID)
	print("[TurnSystem] Current turn player: " .. tostring(self.currentPlayerTurn))

	-- Check if it's player's turn
	local isPlayerTurn = self:IsPlayerTurn(playerID)
	if not isPlayerTurn then 
		print("[TurnSystem] Blocked action - not player's turn")
		return false 
	end

	-- IMPROVED: Block normal turn actions during crystal movement
	if self:IsPlayerUsingCrystal(playerID) and actionType ~= "completeCrystalMove" then
		print("[TurnSystem] Blocked action " .. actionType .. " during crystal movement")
		return false
	end

	-- For item usage, make sure we ALWAYS allow it if it's the player's turn
	if actionType == "useItem" then
		print("[TurnSystem] Allowing item usage for player " .. playerID)

		-- Explicitly clear any potential item usage blockers
		if not self.turnStates[playerID] then
			self.turnStates[playerID] = {}
		end

		self.turnStates[playerID].blockItemUsage = nil
		self.turnStates[playerID].canUseItems = true

		return true -- Explicitly allow item usage
	end

	-- Handle different action types
	if actionType == "endTurn" then
		return self:EndPlayerTurn(playerID, "player_choice")
	elseif actionType == "rollDice" then
		return true -- Handled by other systems
	elseif actionType == "completeCrystalMove" then
		-- NEW: Handle explicit crystal movement completion
		return self:HandleCrystalMoveComplete(player)
	end

	return false
end

function TurnSystem:HandlePlayerLeaving(playerID)
	-- Remove player from turn order
	for i = #self.turnOrder, 1, -1 do
		if self.turnOrder[i] == playerID then
			table.remove(self.turnOrder, i)
			break
		end
	end

	-- If it was this player's turn, move to next turn
	if playerID == self.currentPlayerTurn then
		self:NextTurn()
	elseif self.currentTurnIndex > #self.turnOrder then
		self.currentTurnIndex = 1
	end

	-- Clear player data
	self.skipTurnPlayers[playerID] = nil
	self.turnStates[playerID] = nil
	self.pendingEndTurn[playerID] = nil
	self.activeCrystalMovements[playerID] = nil

	return true
end

function TurnSystem:Reset()
	-- Stop timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Clear all data
	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}
	self.pendingEndTurn = {}
	self.activeCrystalMovements = {}

	return true
end

return TurnSystem
