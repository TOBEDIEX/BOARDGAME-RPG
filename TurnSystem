-- TurnSystem.lua
-- โมดูลจัดการระบบเทิร์นและลำดับเล่นของผู้เล่น
-- Version: 2.1.0 (Optimized)

local TurnSystem = {}
TurnSystem.__index = TurnSystem

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Constants
local TURN_TIME_LIMIT = 120
local INACTIVITY_WARNING_TIME = 90

function TurnSystem.new()
	local self = setmetatable({}, TurnSystem)

	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimer = nil
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}
	self.onTurnStart = nil
	self.onTurnEnd = nil
	self.onTurnTimerUpdate = nil
	self.remotes = nil

	return self
end

function TurnSystem:InitializeRemotes(gameRemotes)
	if not gameRemotes then
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		gameRemotes = remotes:WaitForChild("GameRemotes")
	end

	self.remotes = {
		updateTurn = gameRemotes:WaitForChild("UpdateTurn"),
		updateTurnTimer = gameRemotes:FindFirstChild("UpdateTurnTimer") or Instance.new("RemoteEvent", gameRemotes),
		turnAction = gameRemotes:FindFirstChild("TurnAction") or Instance.new("RemoteEvent", gameRemotes),
		turnState = gameRemotes:FindFirstChild("TurnState") or Instance.new("RemoteEvent", gameRemotes)
	}

	-- Name events if newly created
	for name, event in pairs(self.remotes) do
		if event.Name ~= "UpdateTurn" and event.Name ~= name:sub(1,1):upper() .. name:sub(2) then
			event.Name = name:sub(1,1):upper() .. name:sub(2)
		end
	end

	-- Connect to turn action event
	self.remotes.turnAction.OnServerEvent:Connect(function(player, actionType, actionData)
		self:HandleTurnAction(player, actionType, actionData)
	end)

	return self.remotes
end

function TurnSystem:SetTurnOrder(players)
	if type(players) ~= "table" then return false end

	self.turnOrder = players
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false

	return true
end

function TurnSystem:CreateTurnOrderFromActivePlayers(playerManager)
	local playerOrder = {}

	if playerManager then
		local sortedPlayers = playerManager:GetPlayersSortedByJoinTime()
		for _, playerData in ipairs(sortedPlayers) do
			table.insert(playerOrder, playerData.player.UserId)
		end
	else
		for _, player in pairs(Players:GetPlayers()) do
			table.insert(playerOrder, player.UserId)
		end
	end

	-- Shuffle order for fairness
	self:ShuffleTurnOrder(playerOrder)

	return self:SetTurnOrder(playerOrder)
end

function TurnSystem:ShuffleTurnOrder(order)
	local playerCount = #order
	for i = playerCount, 2, -1 do
		local j = math.random(i)
		order[i], order[j] = order[j], order[i]
	end
	return order
end

function TurnSystem:StartTurnSystem()
	if #self.turnOrder == 0 then return false end
	self:NextTurn()
	return true
end

function TurnSystem:StartPlayerTurn(playerID)
	if not playerID then return false end

	-- Check if player is still in game
	local player = Players:GetPlayerByUserId(playerID)
	if not player then
		self:NextTurn()
		return false
	end

	-- Check if player should skip turn
	if self.skipTurnPlayers[playerID] then
		self.skipTurnPlayers[playerID] = self.skipTurnPlayers[playerID] - 1
		if self.skipTurnPlayers[playerID] <= 0 then
			self.skipTurnPlayers[playerID] = nil
		end
		self:NextTurn()
		return false
	end

	-- Set current turn data
	self.currentPlayerTurn = playerID
	self.isTurnActive = true
	self.turnTimeRemaining = TURN_TIME_LIMIT

	-- Notify clients
	self.remotes.updateTurn:FireAllClients(playerID)
	self.remotes.turnState:FireClient(player, {
		timeLimit = TURN_TIME_LIMIT,
		isYourTurn = true
	})

	-- Start turn timer
	self:StartTurnTimer()

	-- Call turn start callback
	if self.onTurnStart then
		self.onTurnStart(playerID)
	end

	return true
end

function TurnSystem:StartTurnTimer()
	-- Clear previous timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Start new timer
	local startTime = os.time()

	self.turnTimer = game:GetService("RunService").Heartbeat:Connect(function()
		if not self.isTurnActive then return end

		-- Calculate remaining time
		local elapsedTime = os.time() - startTime
		self.turnTimeRemaining = math.max(0, TURN_TIME_LIMIT - elapsedTime)

		-- Update every second
		if elapsedTime % 1 == 0 then
			-- Send time to all clients
			self.remotes.updateTurnTimer:FireAllClients(self.turnTimeRemaining)

			-- Call timer update callback
			if self.onTurnTimerUpdate then
				self.onTurnTimerUpdate(self.turnTimeRemaining)
			end

			-- Warn player when time is running out
			if self.turnTimeRemaining == INACTIVITY_WARNING_TIME then
				local player = Players:GetPlayerByUserId(self.currentPlayerTurn)
				if player then
					self.remotes.turnState:FireClient(player, {
						warning = "Turn time is running out!",
						timeLeft = self.turnTimeRemaining
					})
				end
			end

			-- End turn when time runs out
			if self.turnTimeRemaining <= 0 then
				self:EndPlayerTurn(self.currentPlayerTurn, "timeout")
			end
		end
	end)
end

function TurnSystem:EndPlayerTurn(playerID, reason)
	reason = reason or "normal"

	-- Check if it's the correct player's turn
	if playerID ~= self.currentPlayerTurn then return false end

	-- Clear current turn variables
	local endingPlayerID = self.currentPlayerTurn
	self.isTurnActive = false

	-- Stop timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Call turn end callback
	if self.onTurnEnd then
		self.onTurnEnd(endingPlayerID, reason)
	end

	-- Notify player
	local player = Players:GetPlayerByUserId(endingPlayerID)
	if player then
		self.remotes.turnState:FireClient(player, {
			isYourTurn = false,
			turnEnded = true,
			reason = reason
		})
	end

	-- Move to next turn
	self:NextTurn()

	return true
end

function TurnSystem:NextTurn()
	if #self.turnOrder == 0 then return false end

	-- Increment turn index to next player
	self.currentTurnIndex = (self.currentTurnIndex % #self.turnOrder) + 1
	local nextPlayerID = self.turnOrder[self.currentTurnIndex]

	-- Start next player's turn
	self:StartPlayerTurn(nextPlayerID)

	return true
end

function TurnSystem:SetPlayerSkipTurns(playerID, turns)
	if not playerID then return false end

	if turns and turns > 0 then
		self.skipTurnPlayers[playerID] = turns
	else
		self.skipTurnPlayers[playerID] = nil
	end

	return true
end

function TurnSystem:SetTurnState(playerID, stateName, stateValue)
	if not playerID or not stateName then return false end

	if not self.turnStates[playerID] then
		self.turnStates[playerID] = {}
	end

	self.turnStates[playerID][stateName] = stateValue

	-- Notify player
	local player = Players:GetPlayerByUserId(playerID)
	if player then
		self.remotes.turnState:FireClient(player, {
			state = stateName,
			value = stateValue
		})
	end

	return true
end

function TurnSystem:GetTurnState(playerID, stateName)
	if not playerID or not self.turnStates[playerID] then return nil end
	return stateName and self.turnStates[playerID][stateName] or self.turnStates[playerID]
end

function TurnSystem:GetCurrentPlayerTurn()
	return self.currentPlayerTurn
end

function TurnSystem:IsPlayerTurn(playerID)
	return playerID == self.currentPlayerTurn
end

function TurnSystem:HandleTurnAction(player, actionType, actionData)
	local playerID = player.UserId

	-- Check if it's player's turn
	if not self:IsPlayerTurn(playerID) then return false end

	-- Handle different action types
	if actionType == "endTurn" then
		return self:EndPlayerTurn(playerID, "player_choice")
	elseif actionType == "rollDice" then
		return true -- Handled by other systems
	elseif actionType == "useItem" then
		return true -- Handled by other systems
	end

	return false
end

function TurnSystem:HandlePlayerLeaving(playerID)
	-- Remove player from turn order
	for i = #self.turnOrder, 1, -1 do
		if self.turnOrder[i] == playerID then
			table.remove(self.turnOrder, i)
			break
		end
	end

	-- If it was this player's turn, move to next turn
	if playerID == self.currentPlayerTurn then
		self:NextTurn()
	elseif self.currentTurnIndex > #self.turnOrder then
		self.currentTurnIndex = 1
	end

	-- Clear player data
	self.skipTurnPlayers[playerID] = nil
	self.turnStates[playerID] = nil

	return true
end

function TurnSystem:Reset()
	-- Stop timer
	if self.turnTimer then
		self.turnTimer:Disconnect()
		self.turnTimer = nil
	end

	-- Clear all data
	self.turnOrder = {}
	self.currentTurnIndex = 0
	self.currentPlayerTurn = nil
	self.isTurnActive = false
	self.turnTimeRemaining = 0
	self.turnStates = {}
	self.skipTurnPlayers = {}

	return true
end

return TurnSystem
