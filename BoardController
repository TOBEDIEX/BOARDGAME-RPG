-- BoardController.lua (Client-Side)
-- จัดการการเคลื่อนที่ของตัวละครบนกระดานและแสดง UI เลือกเส้นทาง
-- Version: 2.2.0 (Optimized)

local BoardController = {}
BoardController.__index = BoardController

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

-- Local variables
local player = Players.LocalPlayer
local PlayerModule = require(player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
local Controls = PlayerModule:GetControls()

-- Constants
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }
local STEP_TIMEOUT = 5.0
local DELAY_BETWEEN_STEPS = 0.1
local EFFECT_DURATION = 1.5
local SOUND_VOLUME = 0.6

-- UI References
local DiceRollUI, PathSelectionContainer, RemainingStepsText
local ForwardButton, LeftButton, RightButton

function BoardController.new()
	local self = setmetatable({}, BoardController)

	self.tilePositions = {}
	self.controlsDisabled = false
	self.remotes = self:GetRemoteEvents()
	self.uiConnections = {}
	self.activeMovementCoroutines = {}

	self:InitializeUIReferences()
	self:ConnectEvents()

	return self
end

function BoardController:InitializeUIReferences()
	local PlayerGui = player:WaitForChild("PlayerGui")
	local PopupUI = PlayerGui:WaitForChild("PopupUI")
	DiceRollUI = PopupUI:WaitForChild("DiceRollUI")

	if not DiceRollUI then return end

	PathSelectionContainer = DiceRollUI:FindFirstChild("PathSelectionContainer")
	if not PathSelectionContainer then return end

	RemainingStepsText = PathSelectionContainer:FindFirstChild("RemainingStepsText")
	ForwardButton = PathSelectionContainer:FindFirstChild("ForwardButton")
	LeftButton = PathSelectionContainer:FindFirstChild("LeftButton")
	RightButton = PathSelectionContainer:FindFirstChild("RightButton")
end

function BoardController:GetRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	return {
		playerArrivedAtTile = boardRemotes:WaitForChild("PlayerArrivedAtTile"),
		choosePath = boardRemotes:WaitForChild("ChoosePath"),
		startPlayerMovementPath = boardRemotes:WaitForChild("StartPlayerMovementPath"),
		tileTriggerEvent = boardRemotes:WaitForChild("TileTriggerEvent"),
		activityComplete = boardRemotes:WaitForChild("ActivityComplete")
	}
end

function BoardController:ConnectEvents()
	-- Movement path event
	self.remotes.startPlayerMovementPath.OnClientEvent:Connect(function(playerId, movementData)
		if type(movementData) ~= "table" or not movementData.path then return end
		self:StartMoveAlongPath(playerId, movementData.path, movementData.directions)
	end)

	-- Tile effect event
	self.remotes.tileTriggerEvent.OnClientEvent:Connect(function(playerId, tileId, tileType)
		self:ShowTileEffect(playerId, tileId, tileType)
	end)
end

function BoardController:StartMoveAlongPath(playerId, path, availableDirections)
	-- Cancel previous movement coroutine if exists
	if self.activeMovementCoroutines[playerId] then
		coroutine.close(self.activeMovementCoroutines[playerId])
		self.activeMovementCoroutines[playerId] = nil
	end

	-- Create and start new coroutine
	local co = coroutine.create(function()
		self:MovePlayerAlongPath(playerId, path, availableDirections)
	end)

	self.activeMovementCoroutines[playerId] = co
	local success = coroutine.resume(co)

	if not success then
		self.activeMovementCoroutines[playerId] = nil
	end
end

function BoardController:MovePlayerAlongPath(playerId, path, availableDirections)
	-- Get player and character
	local targetPlayer = Players:GetPlayerByUserId(playerId)
	if not targetPlayer then self.activeMovementCoroutines[playerId] = nil return end

	local character = targetPlayer.Character
	if not character then self.activeMovementCoroutines[playerId] = nil return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoid or not rootPart then self.activeMovementCoroutines[playerId] = nil return end

	if rootPart.Anchored then rootPart.Anchored = false end

	-- Disable controls for local player
	if playerId == player.UserId then self:DisableControls() end
	humanoid.WalkSpeed = 16

	-- Move through path
	local movementSuccess = true
	for i = 2, #path do
		-- Check if coroutine was cancelled
		if not self.activeMovementCoroutines[playerId] or 
			coroutine.status(self.activeMovementCoroutines[playerId]) == "dead" then
			movementSuccess = false
			break
		end

		local nextTileId = path[i]
		local targetPosition = self:GetTilePosition(nextTileId)

		if targetPosition then
			humanoid:MoveTo(targetPosition)
			local success, result = pcall(function() 
				return humanoid.MoveToFinished:Wait(STEP_TIMEOUT) 
			end)

			if not success or not result then
				rootPart.CFrame = CFrame.new(targetPosition + Vector3.new(0, 3, 0))
			end

			task.wait(DELAY_BETWEEN_STEPS)
		else
			movementSuccess = false
			break
		end
	end

	-- Clean up and handle UI
	if movementSuccess and self.activeMovementCoroutines[playerId] then
		if playerId == player.UserId then
			if availableDirections and #availableDirections > 0 then
				self:ShowPathSelectionUI(availableDirections)
			else
				self:EnableControls()
			end
		end
	elseif playerId == player.UserId then
		self:EnableControls()
	end

	-- Clear coroutine reference
	if self.activeMovementCoroutines[playerId] == coroutine.running() then
		self.activeMovementCoroutines[playerId] = nil
	end
end

function BoardController:ShowPathSelectionUI(availableDirections)
	if not PathSelectionContainer then return end

	-- Clear previous connections
	for _, connection in pairs(self.uiConnections) do
		if connection.Connected then connection:Disconnect() end
	end
	self.uiConnections = {}

	-- Show container and hide all buttons
	PathSelectionContainer.Visible = true
	ForwardButton.Visible = false
	LeftButton.Visible = false
	RightButton.Visible = false

	-- Update steps remaining text
	local steps = availableDirections[1].stepsRemaining or "N/A"
	RemainingStepsText.Text = "Steps: " .. steps

	-- Show and connect buttons based on available directions
	for _, dirInfo in ipairs(availableDirections) do
		local button
		local directionEnum

		if dirInfo.direction == DIRECTIONS.FRONT then 
			button = ForwardButton
			directionEnum = DIRECTIONS.FRONT
		elseif dirInfo.direction == DIRECTIONS.LEFT then 
			button = LeftButton
			directionEnum = DIRECTIONS.LEFT
		elseif dirInfo.direction == DIRECTIONS.RIGHT then 
			button = RightButton
			directionEnum = DIRECTIONS.RIGHT
		end

		if button then
			button.Visible = true
			local connection = button.Activated:Connect(function()
				self:ChooseDirection(directionEnum)
			end)
			table.insert(self.uiConnections, connection)
		end
	end
end

function BoardController:ChooseDirection(direction)
	if PathSelectionContainer then
		PathSelectionContainer.Visible = false
	end

	if self.controlsDisabled then
		self:EnableControls()
	end

	self.remotes.choosePath:FireServer(direction)
end

function BoardController:DisableControls()
	if self.controlsDisabled then return end
	Controls:Disable()
	self.controlsDisabled = true
end

function BoardController:EnableControls()
	if self.activeMovementCoroutines[player.UserId] then return end
	if not self.controlsDisabled then return end
	Controls:Enable()
	self.controlsDisabled = false
end

function BoardController:GetTilePosition(tileId)
	-- Check cache first
	if self.tilePositions[tileId] then
		return self.tilePositions[tileId]
	end

	-- Look in Workspace
	local tilesFolder = Workspace:FindFirstChild("BoardTiles")
	if not tilesFolder then return nil end

	local tileName1 = "Tile" .. tostring(tileId)
	local tileName2 = tostring(tileId)
	local tilePart = tilesFolder:FindFirstChild(tileName1) or tilesFolder:FindFirstChild(tileName2)

	if not tilePart or not tilePart:IsA("BasePart") then return nil end

	-- Cache and return position
	self.tilePositions[tileId] = tilePart.Position
	return tilePart.Position
end

function BoardController:ShowTileEffect(playerId, tileId, tileType)
	-- Only show effects for local player
	if playerId ~= player.UserId then return end

	local tilePosition = self:GetTilePosition(tileId)
	if not tilePosition then return end

	-- Choose color based on tile type
	local color = Color3.fromRGB(200, 200, 200) -- Default gray
	if tileType == "shop" then color = Color3.fromRGB(255, 215, 0)      -- Gold
	elseif tileType == "battle" then color = Color3.fromRGB(255, 0, 0)  -- Red
	elseif tileType == "item" then color = Color3.fromRGB(0, 255, 0)    -- Green
	elseif tileType == "money" then color = Color3.fromRGB(255, 255, 0) -- Yellow
	elseif tileType == "casino" then color = Color3.fromRGB(255, 0, 255) -- Magenta
	elseif tileType == "bank" then color = Color3.fromRGB(0, 0, 255)    -- Blue
	elseif tileType == "castle" then color = Color3.fromRGB(128, 0, 128) -- Purple
	end

	self:CreateParticleEffect(tilePosition, color, tileType:upper())
	self:PlayTileSound(tileType)
end

function BoardController:CreateParticleEffect(position, color, effectType)
	local effectPart = Instance.new("Part")
	effectPart.Anchored = true
	effectPart.CanCollide = false
	effectPart.Transparency = 0.5
	effectPart.Size = Vector3.new(2, 2, 2)
	effectPart.Position = position + Vector3.new(0, 3, 0)
	effectPart.Color = color
	effectPart.Material = Enum.Material.Neon
	effectPart.Shape = Enum.PartType.Ball
	effectPart.Parent = Workspace.CurrentCamera

	-- Animate with tween
	local tween = TweenService:Create(
		effectPart, 
		TweenInfo.new(EFFECT_DURATION, Enum.EasingStyle.Linear), 
		{
			Orientation = effectPart.Orientation + Vector3.new(0, 360, 0),
			Transparency = 1,
			Size = Vector3.new(0.1, 0.1, 0.1)
		}
	)
	tween:Play()

	-- Remove part after animation
	tween.Completed:Connect(function()
		effectPart:Destroy()
	end)
end

function BoardController:PlayTileSound(tileType)
	local soundId

	if tileType == "shop" then soundId = "rbxassetid://4067980844"
	elseif tileType == "battle" then soundId = "rbxassetid://4067980844"
	elseif tileType == "item" then soundId = "rbxassetid://4067980844"
	elseif tileType == "money" then soundId = "rbxassetid://4067980844"
	else soundId = "rbxassetid://4067980844" -- Default sound
	end

	if soundId then
		local sound = Instance.new("Sound")
		sound.SoundId = soundId
		sound.Volume = SOUND_VOLUME

		local soundParent = player.Character and 
			(player.Character:FindFirstChild("Head") or 
				player.Character:FindFirstChild("HumanoidRootPart"))

		if soundParent then
			sound.Parent = soundParent
			sound:Play()
			Debris:AddItem(sound, sound.TimeLength + 0.5)
		end
	end
end

return BoardController.new()	
