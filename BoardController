-- BoardController.lua (Client-Side)
-- Manages movement, path selection UI, current tile display, and control locking
-- Version: 3.0.0 (Optimized)

local BoardController = {}
BoardController.__index = BoardController

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

-- Local variables
local player = Players.LocalPlayer
local PlayerModule = require(player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
local Controls = PlayerModule:GetControls()

-- Constants
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }
local STEP_TIMEOUT = 5.0
local DELAY_BETWEEN_STEPS = 0.1
local MOVEMENT_COMPLETE_DELAY = 0.5

-- UI References
local DiceRollUI, PathSelectionContainer, RemainingStepsText
local ForwardButton, LeftButton, RightButton
local CurrentTileText

function BoardController.new()
	local self = setmetatable({}, BoardController)

	self.tilePositions = {}
	self.controlsDisabled = false
	self.remotes = self:GetRemoteEvents()
	self.uiConnections = {}
	self.activeMovementCoroutines = {}
	self.pendingMovementConfirmations = {}

	self:InitializeUIReferences()
	self:ConnectEvents()
	self:UpdateCurrentTileUI(nil)

	return self
end

function BoardController:InitializeUIReferences()
	local PlayerGui = player:WaitForChild("PlayerGui")
	if not PlayerGui then return end
	
	local PopupUI = PlayerGui:WaitForChild("PopupUI")
	if not PopupUI then return end
	
	DiceRollUI = PopupUI:WaitForChild("DiceRollUI")

	if not DiceRollUI then
		warn("[BoardController] DiceRollUI not found!")
		return
	end

	PathSelectionContainer = DiceRollUI:FindFirstChild("PathSelectionContainer")
	if not PathSelectionContainer then
		warn("[BoardController] PathSelectionContainer not found!")
	else
		RemainingStepsText = PathSelectionContainer:FindFirstChild("RemainingStepsText")
		ForwardButton = PathSelectionContainer:FindFirstChild("ForwardButton")
		LeftButton = PathSelectionContainer:FindFirstChild("LeftButton")
		RightButton = PathSelectionContainer:FindFirstChild("RightButton")
	end

	CurrentTileText = PopupUI:FindFirstChild("CurrentTileText")
end

function BoardController:GetRemoteEvents()
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")

	return {
		playerArrivedAtTile = boardRemotes:WaitForChild("PlayerArrivedAtTile"),
		choosePath = boardRemotes:WaitForChild("ChoosePath"),
		startPlayerMovementPath = boardRemotes:WaitForChild("StartPlayerMovementPath"),
		tileTriggerEvent = boardRemotes:WaitForChild("TileTriggerEvent"),
		activityComplete = boardRemotes:WaitForChild("ActivityComplete"),
		movementVisualizationComplete = boardRemotes:FindFirstChild("MovementVisualizationComplete") or
			Instance.new("RemoteEvent", boardRemotes)
	}
end

function BoardController:ConnectEvents()
	if self.remotes.movementVisualizationComplete.Name ~= "MovementVisualizationComplete" then
		self.remotes.movementVisualizationComplete.Name = "MovementVisualizationComplete"
	end

	self.remotes.startPlayerMovementPath.OnClientEvent:Connect(function(playerId, movementData)
		if type(movementData) ~= "table" or type(movementData.path) ~= "table" or #movementData.path == 0 then
			warn("[BoardController] Received invalid movement data for playerId:", playerId)
			return
		end
		
		if movementData.directions and type(movementData.directions) ~= "table" then
			movementData.directions = nil
		end
		
		if movementData.requiresConfirmation ~= nil and type(movementData.requiresConfirmation) ~= "boolean" then
			movementData.requiresConfirmation = false
		end
		
		self:StartMoveAlongPath(playerId, movementData.path, movementData.directions, movementData.requiresConfirmation)
	end)

	self.remotes.tileTriggerEvent.OnClientEvent:Connect(function(playerId, tileId, tileType)
		self:ShowTileEffect(playerId, tileId, tileType)
	end)
end

function BoardController:StartMoveAlongPath(playerId, path, availableDirections, requiresConfirmation)
	if self.activeMovementCoroutines[playerId] then
		if playerId == player.UserId then
			task.spawn(coroutine.close, self.activeMovementCoroutines[playerId])
		end
		self.activeMovementCoroutines[playerId] = nil
	end

	if playerId == player.UserId then
		self:DisableControls()
	end

	if requiresConfirmation then
		self.pendingMovementConfirmations[playerId] = { path = path, finalTileId = path[#path] }
	else
		self.pendingMovementConfirmations[playerId] = nil
	end

	local co = coroutine.create(function()
		self:MovePlayerAlongPath(playerId, path, availableDirections, requiresConfirmation)
	end)
	
	self.activeMovementCoroutines[playerId] = co
	local success, err = coroutine.resume(co)

	if not success then
		warn("[BoardController] Coroutine failed for playerId:", playerId, "Error:", err)
		
		if self.activeMovementCoroutines[playerId] == co then
			self.activeMovementCoroutines[playerId] = nil
		end
		
		if playerId == player.UserId then
			self:EnableControls()
			self:UpdateCurrentTileUI(path[#path])
		end
		
		if requiresConfirmation and playerId == player.UserId then
			self:ConfirmMovementCompletion(playerId, path[#path])
		end
	end
end

function BoardController:MovePlayerAlongPath(playerId, path, availableDirections, requiresConfirmation)
	local currentCoroutine = coroutine.running()

	local targetPlayer = Players:GetPlayerByUserId(playerId)
	if not targetPlayer then
		warn("[BoardController] Player not found:", playerId)
		if self.activeMovementCoroutines[playerId] == currentCoroutine then self.activeMovementCoroutines[playerId] = nil end
		if playerId == player.UserId then self:EnableControls(); self:UpdateCurrentTileUI(path[#path]) end
		if requiresConfirmation and playerId == player.UserId then self:ConfirmMovementCompletion(playerId, path[#path]) end
		return
	end

	local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait(5)
	if not character then
		warn("[BoardController] Character not found for player:", playerId)
		if self.activeMovementCoroutines[playerId] == currentCoroutine then self.activeMovementCoroutines[playerId] = nil end
		if playerId == player.UserId then self:EnableControls(); self:UpdateCurrentTileUI(path[#path]) end
		if requiresConfirmation and playerId == player.UserId then self:ConfirmMovementCompletion(playerId, path[#path]) end
		return
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoid or not rootPart then
		warn("[BoardController] Humanoid or RootPart not found for player:", playerId)
		if self.activeMovementCoroutines[playerId] == currentCoroutine then self.activeMovementCoroutines[playerId] = nil end
		if playerId == player.UserId then self:EnableControls(); self:UpdateCurrentTileUI(path[#path]) end
		if requiresConfirmation and playerId == player.UserId then self:ConfirmMovementCompletion(playerId, path[#path]) end
		return
	end

	if rootPart.Anchored then rootPart.Anchored = false end
	humanoid.WalkSpeed = 16

	local movementSuccess = true
	local lastReachedTileIndex = 1
	
	for i = 2, #path do
		if self.activeMovementCoroutines[playerId] ~= currentCoroutine or coroutine.status(currentCoroutine) == "dead" then
			movementSuccess = false
			break
		end

		local nextTileId = path[i]
		local targetPosition = self:GetTilePosition(nextTileId)

		if targetPosition then
			humanoid:MoveTo(targetPosition)
			local success, result = pcall(function() return humanoid.MoveToFinished:Wait(STEP_TIMEOUT) end)

			if not success then
				warn("[BoardController] MoveToFinished Wait errored for playerId:", playerId, "Error:", result)
				rootPart.CFrame = CFrame.new(targetPosition + Vector3.new(0, 3, 0))
				movementSuccess = false
				break
			elseif not result then
				warn("[BoardController] MoveTo timed out for playerId:", playerId, "Teleporting to target.")
				rootPart.CFrame = CFrame.new(targetPosition + Vector3.new(0, 3, 0))
				lastReachedTileIndex = i
			else
				lastReachedTileIndex = i
			end
			
			task.wait(DELAY_BETWEEN_STEPS)
		else
			warn("[BoardController] Target position not found for Tile ID:", nextTileId, "for playerId:", playerId)
			movementSuccess = false
			break
		end
	end

	local finalTileId = path[lastReachedTileIndex]

	if self.activeMovementCoroutines[playerId] ~= currentCoroutine then
		-- Coroutine was replaced or cancelled
	else
		if movementSuccess then
			task.wait(MOVEMENT_COMPLETE_DELAY)

			if self.activeMovementCoroutines[playerId] ~= currentCoroutine then
				-- Coroutine changed during delay
			elseif playerId == player.UserId then
				if availableDirections and #availableDirections > 0 then
					self:UpdateCurrentTileUI(finalTileId)
					self:ShowPathSelectionUI(availableDirections)
				else
					self.activeMovementCoroutines[playerId] = nil
					self:EnableControls()
					self:UpdateCurrentTileUI(finalTileId)
					if requiresConfirmation then
						self:ConfirmMovementCompletion(playerId, finalTileId)
					end
				end
			else
				self.activeMovementCoroutines[playerId] = nil
			end
		else
			warn("[BoardController] Movement failed or interrupted for playerId:", playerId, "Last reached Tile:", finalTileId)
			self.activeMovementCoroutines[playerId] = nil
			if playerId == player.UserId then
				self:EnableControls()
				self:UpdateCurrentTileUI(finalTileId)
			end
			if requiresConfirmation and playerId == player.UserId then
				self:ConfirmMovementCompletion(playerId, finalTileId)
			end
		end
	end

	if playerId == player.UserId and self.controlsDisabled and not self.activeMovementCoroutines[playerId] then
		self:EnableControls()
		if finalTileId then self:UpdateCurrentTileUI(finalTileId) end
	end
end

function BoardController:ConfirmMovementCompletion(playerId, finalTileId)
	if playerId ~= player.UserId then return end

	local pendingData = self.pendingMovementConfirmations[playerId]
	if not pendingData then
		if finalTileId then self:UpdateCurrentTileUI(finalTileId) end
		return
	end

	if pendingData.finalTileId ~= finalTileId then
		warn("[BoardController] Mismatched finalTileId for confirmation. Expected:", pendingData.finalTileId, "Got:", finalTileId, ". Sending confirmation for the received tile anyway.")
	end

	self.pendingMovementConfirmations[playerId] = nil
	self.remotes.movementVisualizationComplete:FireServer(finalTileId)
	self:UpdateCurrentTileUI(finalTileId)
end

function BoardController:UpdateCurrentTileUI(tileId)
	if not CurrentTileText then return end

	if tileId then
		CurrentTileText.Text = "Tile: " .. tostring(tileId)
		CurrentTileText.Visible = true
	else
		CurrentTileText.Text = "Tile: -"
		CurrentTileText.Visible = false
	end
end

function BoardController:ShowPathSelectionUI(availableDirections)
	if not PathSelectionContainer or not RemainingStepsText or not ForwardButton or not LeftButton or not RightButton then
		warn("[BoardController] Cannot show Path Selection UI - Elements missing.")
		if self.activeMovementCoroutines[player.UserId] then
			self.activeMovementCoroutines[player.UserId] = nil
		end
		self:EnableControls()
		return
	end

	for _, connection in pairs(self.uiConnections) do
		if connection.Connected then connection:Disconnect() end
	end
	self.uiConnections = {}

	PathSelectionContainer.Visible = true
	ForwardButton.Visible = false
	LeftButton.Visible = false
	RightButton.Visible = false

	local steps = availableDirections[1] and availableDirections[1].stepsRemaining or "N/A"
	RemainingStepsText.Text = "Steps: " .. steps

	local buttonVisibleCount = 0
	for _, dirInfo in ipairs(availableDirections) do
		local button
		local directionEnum
		
		if dirInfo.direction == DIRECTIONS.FRONT then 
			button, directionEnum = ForwardButton, DIRECTIONS.FRONT
		elseif dirInfo.direction == DIRECTIONS.LEFT then 
			button, directionEnum = LeftButton, DIRECTIONS.LEFT
		elseif dirInfo.direction == DIRECTIONS.RIGHT then 
			button, directionEnum = RightButton, DIRECTIONS.RIGHT
		end

		if button then
			button.Visible = true
			buttonVisibleCount = buttonVisibleCount + 1
			local connection = button.Activated:Connect(function()
				if PathSelectionContainer.Visible then
					self:ChooseDirection(directionEnum)
				else
					warn("[BoardController] PathSelectionContainer was already hidden when button activated.")
					if self.activeMovementCoroutines[player.UserId] then self.activeMovementCoroutines[player.UserId] = nil end
					self:EnableControls()
				end
			end)
			table.insert(self.uiConnections, connection)
		end
	end

	if buttonVisibleCount == 0 then
		warn("[BoardController] No valid direction buttons to show in Path Selection UI.")
		PathSelectionContainer.Visible = false
		if self.activeMovementCoroutines[player.UserId] then
			self.activeMovementCoroutines[player.UserId] = nil
		end
		self:EnableControls()
	end
end

function BoardController:ChooseDirection(direction)
	if not PathSelectionContainer then return end

	PathSelectionContainer.Visible = false

	for _, connection in pairs(self.uiConnections) do
		if connection.Connected then connection:Disconnect() end
	end
	self.uiConnections = {}

	if self.activeMovementCoroutines[player.UserId] then
		self.activeMovementCoroutines[player.UserId] = nil
	end

	self:EnableControls()

	local pendingConfirmation = self.pendingMovementConfirmations[player.UserId]
	if pendingConfirmation then
		self:ConfirmMovementCompletion(player.UserId, pendingConfirmation.finalTileId)
	end

	self.remotes.choosePath:FireServer(direction)
end

function BoardController:DisableControls()
	if self.controlsDisabled then return end
	
	if Controls and typeof(Controls.Disable) == "function" then
		pcall(function() Controls:Disable() end)
	end
	
	self.controlsDisabled = true
end

function BoardController:EnableControls()
	if self.activeMovementCoroutines[player.UserId] then
		return
	end
	
	if not self.controlsDisabled then
		return
	end
	
	if Controls and typeof(Controls.Enable) == "function" then
		pcall(function() Controls:Enable() end)
	end
	
	self.controlsDisabled = false
end

function BoardController:GetTilePosition(tileId)
	if self.tilePositions[tileId] then
		return self.tilePositions[tileId]
	end
	
	local tilesFolder = Workspace:FindFirstChild("BoardTiles")
	if not tilesFolder then warn("[BoardController] BoardTiles folder not found!") return nil end
	
	local tileName1 = "Tile" .. tostring(tileId)
	local tileName2 = tostring(tileId)
	local tilePart = tilesFolder:FindFirstChild(tileName1) or tilesFolder:FindFirstChild(tileName2)
	
	if not tilePart or not tilePart:IsA("BasePart") then return nil end
	
	self.tilePositions[tileId] = tilePart.Position
	return tilePart.Position
end

function BoardController:ShowTileEffect(playerId, tileId, tileType)
	local tilePosition = self:GetTilePosition(tileId)
	if not tilePosition then return end
	
	local lowerTileType = string.lower(tostring(tileType or ""))
	local color = Color3.fromRGB(200, 200, 200)
	
	if lowerTileType == "shop" then 
		color = Color3.fromRGB(255, 215, 0)
	elseif lowerTileType == "battle" then 
		color = Color3.fromRGB(255, 0, 0)
	elseif lowerTileType == "item" then 
		color = Color3.fromRGB(0, 255, 0)
	elseif lowerTileType == "money" then 
		color = Color3.fromRGB(255, 255, 0)
	elseif lowerTileType == "casino" then 
		color = Color3.fromRGB(255, 0, 255)
	elseif lowerTileType == "bank" then 
		color = Color3.fromRGB(0, 0, 255)
	elseif lowerTileType == "castle" then 
		color = Color3.fromRGB(128, 0, 128)
	end
	
	self:CreateParticleEffect(tilePosition, color, tileType and tileType:upper() or "UNKNOWN")
	self:PlayTileSound(lowerTileType, playerId, tileId)
end

function BoardController:CreateParticleEffect(position, color, effectType)
	local effectContainer = Instance.new("Model", Workspace.CurrentCamera)
	effectContainer.Name = "TileEffect_" .. effectType .. "_" .. math.random(1000)
	Debris:AddItem(effectContainer, 1.5)
	
	local effectPart = Instance.new("Part")
	effectPart.Anchored = true
	effectPart.CanCollide = false
	effectPart.Transparency = 0.5
	effectPart.Size = Vector3.new(4, 0.5, 4)
	effectPart.Position = position + Vector3.new(0, 0.5, 0)
	effectPart.Color = color
	effectPart.Material = Enum.Material.Neon
	effectPart.Shape = Enum.PartType.Cylinder
	effectPart.Orientation = Vector3.new(0, 0, 90)
	effectPart.Parent = effectContainer
	
	local emitter = Instance.new("ParticleEmitter", effectPart)
	emitter.Color = ColorSequence.new(color)
	emitter.LightEmission = 0.5
	emitter.Size = NumberSequence.new(0.5, 0.1)
	emitter.Transparency = NumberSequence.new(0, 1)
	emitter.Lifetime = NumberRange.new(0.5, 1.5)
	emitter.Rate = 30
	emitter.Speed = NumberRange.new(2, 5)
	emitter.SpreadAngle = Vector2.new(360, 360)
	emitter.Enabled = true
	
	local tween = TweenService:Create(effectPart, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
		{ Orientation = effectPart.Orientation + Vector3.new(0, 360, 0), Transparency = 1, Size = effectPart.Size * 0.1 })
	tween:Play()
	tween.Completed:Connect(function() if emitter and emitter.Parent then emitter.Enabled = false end end)
end

function BoardController:PlayTileSound(tileType, playerId, tileId)
	local soundId = "rbxassetid://4067980844" -- Default sound
	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	sound.Volume = 0.6
	
	local soundParent
	local targetPlayerInstance = Players:GetPlayerByUserId(playerId)
	if targetPlayerInstance then 
		local character = targetPlayerInstance.Character
		soundParent = character and (character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")) 
	end
	
	if not soundParent then
		local tilePos = self:GetTilePosition(tileId)
		if tilePos then
			local soundPart = Instance.new("Part", Workspace.CurrentCamera)
			soundPart.Anchored = true
			soundPart.CanCollide = false
			soundPart.Transparency = 1
			soundPart.Position = tilePos
			soundPart.Size = Vector3.one
			soundPart.Name = "TempSoundPart"
			sound.Parent = soundPart
			local soundDuration = (sound.TimeLength > 0 and sound.TimeLength) or 2
			Debris:AddItem(soundPart, soundDuration + 0.5)
		else 
			sound:Destroy()
			return 
		end
	else
		sound.Parent = soundParent
		local soundDuration = (sound.TimeLength > 0 and sound.TimeLength) or 2
		Debris:AddItem(sound, soundDuration + 0.5)
	end
	
	sound:Play()
end

local instance = BoardController.new()
return instance
