print("!!! BOARD CONTROLLER SCRIPT HAS STARTED !!!") -- DEBUG: ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ß‡πà‡∏≤ Script ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô

--[[
	BoardController.lua (Client-Side)
	‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö Step-by-Step,
	‡πÅ‡∏™‡∏î‡∏á UI ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á, ‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏ö‡∏ô Client
	Version: 2.1 (Refactored)
--]]

local BoardController = {}
BoardController.__index = BoardController

--==============================================================================
-- Services (‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏Ç‡∏≠‡∏á Roblox)
--==============================================================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris") -- ‡πÄ‡∏û‡∏¥‡πà‡∏° Debris Service ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á

--==============================================================================
-- Local Player & Controls (‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°)
--==============================================================================
local player = Players.LocalPlayer
local PlayerScripts = player:WaitForChild("PlayerScripts")
local PlayerModule = require(PlayerScripts:WaitForChild("PlayerModule"))
local Controls = PlayerModule:GetControls()

--==============================================================================
-- Constants (‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏á‡∏ó‡∏µ‡πà)
--==============================================================================
local DIRECTIONS = { FRONT = "FRONT", LEFT = "LEFT", RIGHT = "RIGHT" }
local STEP_TIMEOUT = 5.0        -- ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ñ‡∏∂‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ä‡πà‡∏≠‡∏á (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
local DELAY_BETWEEN_STEPS = 0.1 -- ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡πâ‡∏≤‡∏ß (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
local EFFECT_DURATION = 1.5     -- ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
local SOUND_VOLUME = 0.6        -- ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á

--==============================================================================
-- Module Variables (‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÇ‡∏°‡∏î‡∏π‡∏•)
--==============================================================================
local DiceRollUI = nil              -- Cache reference to DiceRollUI
local PathSelectionContainer = nil  -- Cache reference to PathSelectionContainer
local RemainingStepsText = nil      -- Cache reference to RemainingStepsText
local ForwardButton = nil           -- Cache reference to ForwardButton
local LeftButton = nil              -- Cache reference to LeftButton
local RightButton = nil             -- Cache reference to RightButton

--==============================================================================
-- Initialization (‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô)
--==============================================================================

function BoardController.new()
	local self = setmetatable({}, BoardController)

	self.tilePositions = {}              -- Cache ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏≠‡∏á {tileId = Vector3}
	self.controlsDisabled = false        -- ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Controls
	self.remotes = self:GetRemoteEvents() -- Remote Events
	self.uiConnections = {}              -- ‡πÄ‡∏Å‡πá‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Event ‡∏Ç‡∏≠‡∏á‡∏õ‡∏∏‡πà‡∏° UI
	self.activeMovementCoroutines = {} -- ‡πÄ‡∏Å‡πá‡∏ö Coroutine ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà {playerId = coroutine}

	self:InitializeUIReferences()       -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ UI elements
	self:ConnectEvents()                -- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Remote Events

	print("[BoardController] Initialized")
	return self
end

-- ‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö Reference ‡∏Ç‡∏≠‡∏á UI elements ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ö‡πà‡∏≠‡∏¢
function BoardController:InitializeUIReferences()
	local PlayerGui = player:WaitForChild("PlayerGui")
	if not PlayerGui then warn("[BoardController] PlayerGui not found!") return end
	local PopupUI = PlayerGui:WaitForChild("PopupUI")
	if not PopupUI then warn("[BoardController] PopupUI not found!") return end
	DiceRollUI = PopupUI:WaitForChild("DiceRollUI")
	if not DiceRollUI then warn("[BoardController] DiceRollUI not found!") return end

	PathSelectionContainer = DiceRollUI:FindFirstChild("PathSelectionContainer")
	if not PathSelectionContainer then warn("[BoardController] PathSelectionContainer not found!") return end

	RemainingStepsText = PathSelectionContainer:FindFirstChild("RemainingStepsText")
	ForwardButton = PathSelectionContainer:FindFirstChild("ForwardButton")
	LeftButton = PathSelectionContainer:FindFirstChild("LeftButton")
	RightButton = PathSelectionContainer:FindFirstChild("RightButton")

	if not RemainingStepsText or not ForwardButton or not LeftButton or not RightButton then
		warn("[BoardController] One or more path selection UI components are missing!")
	end
	print("[BoardController] UI References Initialized.")
end

-- ‡∏£‡∏±‡∏ö Remote Events ‡∏à‡∏≤‡∏Å ReplicatedStorage
function BoardController:GetRemoteEvents()
	print("[BoardController] Getting Remote Events...")
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local boardRemotes = remotes:WaitForChild("BoardRemotes")
	local events = {
		-- ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ rollDice ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏ñ‡πâ‡∏≤ DiceRollHandler ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á Event ‡πÄ‡∏≠‡∏á
		-- rollDice = boardRemotes:WaitForChild("RollDice"),
		playerArrivedAtTile = boardRemotes:WaitForChild("PlayerArrivedAtTile"),
		choosePath = boardRemotes:WaitForChild("ChoosePath"),
		startPlayerMovementPath = boardRemotes:WaitForChild("StartPlayerMovementPath"),
		tileTriggerEvent = boardRemotes:WaitForChild("TileTriggerEvent"),
		activityComplete = boardRemotes:WaitForChild("ActivityComplete")
	}
	print("[BoardController] Remote Events Acquired.")
	return events
end

-- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏±‡∏ö Remote Events ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å Server
function BoardController:ConnectEvents()
	print("[BoardController] Connecting Remote Events...")

	-- ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà (path ‡πÅ‡∏•‡∏∞ directions)
	self.remotes.startPlayerMovementPath.OnClientEvent:Connect(function(playerId, movementData)
		print(string.format("[DEBUG] Received startPlayerMovementPath for Player %d. Data Type: %s", playerId, type(movementData)))
		if type(movementData) ~= "table" or not movementData.path or type(movementData.path) ~= "table" or #movementData.path == 0 then
			warn("[DEBUG] Received invalid movement data!")
			if type(movementData) == "table" then print("[DEBUG] Data Content:", movementData) end
			return
		end
		local path = movementData.path
		local directions = movementData.directions -- ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô nil
		print(string.format("[DEBUG] Received Path: {%s}, Directions: %s", table.concat(path, ", "), directions and #directions .. " options" or "nil"))
		self:StartMoveAlongPath(playerId, path, directions) -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà
	end)

	-- ‡∏£‡∏±‡∏ö Event ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡∏Ç‡∏≠‡∏á‡∏ä‡πà‡∏≠‡∏á
	self.remotes.tileTriggerEvent.OnClientEvent:Connect(function(playerId, tileId, tileType)
		print(string.format("[DEBUG] Received TileTriggerEvent for Player %d on Tile %s (%s)", playerId, tostring(tileId), tileType))
		self:ShowTileEffect(playerId, tileId, tileType)
	end)

	-- ‡∏£‡∏±‡∏ö Event ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏à‡∏≤‡∏Å Server ‡∏ß‡πà‡∏≤‡∏ñ‡∏∂‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á (‡∏ó‡∏≤‡∏á Logic)
	self.remotes.playerArrivedAtTile.OnClientEvent:Connect(function(playerId, tileId)
		print(string.format("[DEBUG] Server confirmed Player %d arrived logically at Tile %s", playerId, tostring(tileId)))
		-- ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡πÉ‡∏ä‡πâ Event ‡∏ô‡∏µ‡πâ‡∏ó‡∏≥‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÑ‡∏î‡πâ ‡πÄ‡∏ä‡πà‡∏ô ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
	end)

	print("[BoardController] Remote Events Connected.")
end

--==============================================================================
-- Movement Logic (Logic ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å)
--==============================================================================

-- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Coroutine ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
function BoardController:StartMoveAlongPath(playerId, path, availableDirections)
	print(string.format("[DEBUG] StartMoveAlongPath called for Player %d", playerId))
	-- ‡∏´‡∏¢‡∏∏‡∏î Coroutine ‡πÄ‡∏Å‡πà‡∏≤ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏°‡πà
	if self.activeMovementCoroutines[playerId] then
		print("[DEBUG] Cancelling previous movement coroutine for Player " .. playerId)
		coroutine.close(self.activeMovementCoroutines[playerId])
		self.activeMovementCoroutines[playerId] = nil
	end

	-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏° Coroutine ‡πÉ‡∏´‡∏°‡πà
	local co = coroutine.create(function()
		print(string.format("[DEBUG] Coroutine created for Player %d movement", playerId))
		self:MovePlayerAlongPath(playerId, path, availableDirections)
	end)

	self.activeMovementCoroutines[playerId] = co
	print(string.format("[DEBUG] Resuming coroutine for Player %d", playerId))
	local success, err = coroutine.resume(co)
	if not success then
		warn(string.format("[DEBUG] Error resuming movement coroutine for Player %d: %s", playerId, tostring(err)))
		self.activeMovementCoroutines[playerId] = nil -- ‡∏•‡πâ‡∏≤‡∏á ref ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
	else
		print(string.format("[DEBUG] Coroutine for Player %d resumed successfully.", playerId))
	end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô Coroutine ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏ó‡∏µ‡∏•‡∏∞‡∏Å‡πâ‡∏≤‡∏ß
function BoardController:MovePlayerAlongPath(playerId, path, availableDirections)
	print(string.format("[DEBUG] MovePlayerAlongPath started inside coroutine for Player %d", playerId))
	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô (Player, Character, Humanoid, RootPart)
	local targetPlayer = Players:GetPlayerByUserId(playerId)
	if not targetPlayer then warn("[DEBUG] MovePlayerAlongPath: Cannot find player ID: " .. playerId) self.activeMovementCoroutines[playerId] = nil return end
	local character = targetPlayer.Character
	if not character then warn("[DEBUG] MovePlayerAlongPath: Cannot find character for " .. targetPlayer.Name) self.activeMovementCoroutines[playerId] = nil return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then warn("[DEBUG] MovePlayerAlongPath: Cannot find Humanoid for " .. targetPlayer.Name) self.activeMovementCoroutines[playerId] = nil return end
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then warn("[DEBUG] MovePlayerAlongPath: Cannot find HumanoidRootPart for " .. targetPlayer.Name) self.activeMovementCoroutines[playerId] = nil return end
	print(string.format("[DEBUG] Found Character, Humanoid, RootPart for Player %d. RootPart Anchored: %s", playerId, tostring(rootPart.Anchored)))
	if rootPart.Anchored then warn("[DEBUG] HumanoidRootPart is Anchored! Setting to false.") rootPart.Anchored = false end

	print(string.format("[DEBUG] Starting step-by-step movement for Player %d along path: %s", playerId, table.concat(path, " -> ")))
	-- ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡πâ‡∏≠‡∏á‡∏ñ‡∏¥‡πà‡∏ô
	if playerId == player.UserId then self:DisableControls() end
	humanoid.WalkSpeed = 16 -- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô

	-- ‡∏ß‡∏ô Loop ‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡πà‡∏≠‡∏á
	print(string.format("[DEBUG] Path length: %d. Starting loop from i=2.", #path))
	local movementSuccess = true -- Track if all steps were successful
	for i = 2, #path do
		print(string.format("[DEBUG] Loop iteration i = %d", i))
		-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Coroutine ‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
		if not self.activeMovementCoroutines[playerId] or coroutine.status(self.activeMovementCoroutines[playerId]) == "dead" then
			print("[DEBUG] Movement coroutine cancelled/cleared during loop for Player " .. playerId)
			movementSuccess = false
			break -- ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Loop
		end

		local currentTileId = path[i-1]
		local nextTileId = path[i]
		print(string.format("[DEBUG] Current Tile: %s, Next Tile: %s", tostring(currentTileId), tostring(nextTileId)))
		local targetPosition = self:GetTilePosition(nextTileId) -- ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏≠‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ

		if targetPosition then
			print(string.format("[DEBUG] Target Position for Tile %s: %s", tostring(nextTileId), tostring(targetPosition)))
			print(string.format("[DEBUG] Calling MoveTo for Player %d to %s", playerId, tostring(targetPosition)))
			humanoid:MoveTo(targetPosition) -- ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏î‡∏¥‡∏ô
			print(string.format("[DEBUG] Waiting for MoveToFinished for Player %d (Timeout: %.1fs)...", playerId, STEP_TIMEOUT))
			local success, result = pcall(function() return humanoid.MoveToFinished:Wait(STEP_TIMEOUT) end) -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏î‡∏¥‡∏ô‡∏ñ‡∏∂‡∏á (‡∏û‡∏£‡πâ‡∏≠‡∏° Timeout)

			if success then
				print(string.format("[DEBUG] MoveToFinished Wait completed for Player %d. Result (Finished=true/Timeout=false): %s", playerId, tostring(result)))
				if not result then -- ‡∏ñ‡πâ‡∏≤ Timeout
					warn(string.format("[DEBUG] MoveToFinished timed out for Player %d moving to Tile %s. Warping...", playerId, tostring(nextTileId)))
					rootPart.CFrame = CFrame.new(targetPosition + Vector3.new(0, 3, 0)) -- ‡∏ß‡∏≤‡∏£‡πå‡∏õ‡πÑ‡∏õ‡πÄ‡∏•‡∏¢
				end
			else -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î Error ‡∏ï‡∏≠‡∏ô Wait
				warn(string.format("[DEBUG] Error during MoveToFinished:Wait() for Player %d: %s. Warping...", playerId, tostring(result)))
				rootPart.CFrame = CFrame.new(targetPosition + Vector3.new(0, 3, 0)) -- ‡∏ß‡∏≤‡∏£‡πå‡∏õ‡πÑ‡∏õ‡πÄ‡∏•‡∏¢
			end

			print(string.format("[DEBUG] Waiting delay between steps (%.2f s)", DELAY_BETWEEN_STEPS))
			task.wait(DELAY_BETWEEN_STEPS) -- ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
		else
			warn(string.format("[DEBUG] Cannot find position for Tile %s in path for Player %d. Stopping movement.", tostring(nextTileId), playerId))
			movementSuccess = false
			break -- ‡∏´‡∏¢‡∏∏‡∏î Loop ‡∏ñ‡πâ‡∏≤‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠
		end
	end -- ‡∏à‡∏ö Loop ‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô

	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Coroutine ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏•‡∏±‡∏á Loop ‡∏à‡∏ö
	if not self.activeMovementCoroutines[playerId] or coroutine.status(self.activeMovementCoroutines[playerId]) == "dead" then
		print("[DEBUG] Movement coroutine cancelled/cleared after loop completion for Player " .. playerId)
		movementSuccess = false
	end

	if movementSuccess then
		print(string.format("[DEBUG] Finished step-by-step movement loop successfully for Player %d at Tile %s", playerId, tostring(path[#path])))
		-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á UI ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏≤‡∏á ‡∏´‡∏£‡∏∑‡∏≠ ‡πÄ‡∏õ‡∏¥‡∏î Controls
		if playerId == player.UserId then
			if availableDirections and #availableDirections > 0 then
				print("[DEBUG] Movement finished, showing path selection UI.")
				self:ShowPathSelectionUI(availableDirections)
			else
				print("[DEBUG] Movement finished, no directions to choose. Enabling controls.")
				self:EnableControls()
			end
		end
	else
		print(string.format("[DEBUG] Movement loop finished (possibly prematurely) for Player %d.", playerId))
		-- ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å ‡∏´‡∏£‡∏∑‡∏≠ ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏ï‡πà‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà‡πÄ‡∏õ‡∏¥‡∏î Controls
		if playerId == player.UserId then
			print("[DEBUG] Enabling controls after unsuccessful/cancelled movement.")
			self:EnableControls()
		end
	end

	-- ‡∏•‡πâ‡∏≤‡∏á Coroutine reference ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡πá‡∏ô Coroutine ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
	if self.activeMovementCoroutines[playerId] == co then
		print(string.format("[DEBUG] Clearing completed coroutine reference for Player %d", playerId))
		self.activeMovementCoroutines[playerId] = nil
	end
end

--==============================================================================
-- UI Handling (‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ User Interface)
--==============================================================================

-- ‡πÅ‡∏™‡∏î‡∏á UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
function BoardController:ShowPathSelectionUI(availableDirections)
	print("[DEBUG] ShowPathSelectionUI called with " .. #availableDirections .. " directions.")
	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö UI elements ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
	if not PathSelectionContainer or not RemainingStepsText or not ForwardButton or not LeftButton or not RightButton then
		warn("[DEBUG] Cannot show path selection, UI components missing or not initialized.")
		return
	end

	-- ‡∏•‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Event ‡∏Ç‡∏≠‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏Å‡πà‡∏≤
	for _, connection in pairs(self.uiConnections) do
		if connection.Connected then connection:Disconnect() end
	end
	self.uiConnections = {}

	-- ‡πÅ‡∏™‡∏î‡∏á Container ‡πÅ‡∏•‡∏∞‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô
	PathSelectionContainer.Visible = true
	ForwardButton.Visible = false
	LeftButton.Visible = false
	RightButton.Visible = false

	-- ‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡πâ‡∏≤‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)
	local steps = "N/A"
	if #availableDirections > 0 and availableDirections[1].stepsRemaining then
		steps = availableDirections[1].stepsRemaining
	end
	RemainingStepsText.Text = "Steps: " .. steps
	print("[DEBUG] Steps Remaining for Selection UI: " .. steps)

	-- ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ ‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Event 'Activated'
	for _, dirInfo in ipairs(availableDirections) do
		local button = nil
		local directionEnum = nil

		if dirInfo.direction == DIRECTIONS.FRONT then button = ForwardButton; directionEnum = DIRECTIONS.FRONT
		elseif dirInfo.direction == DIRECTIONS.LEFT then button = LeftButton; directionEnum = DIRECTIONS.LEFT
		elseif dirInfo.direction == DIRECTIONS.RIGHT then button = RightButton; directionEnum = DIRECTIONS.RIGHT
		end

		if button then
			button.Visible = true
			print("[DEBUG] Enabling button for direction: " .. dirInfo.direction)
			local connection = button.Activated:Connect(function() -- ‡πÉ‡∏ä‡πâ Activated ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° Click ‡πÅ‡∏•‡∏∞ Touch
				print("[DEBUG] Button Activated for direction: " .. directionEnum)
				self:ChooseDirection(directionEnum)
			end)
			table.insert(self.uiConnections, connection) -- ‡πÄ‡∏Å‡πá‡∏ö connection ‡πÑ‡∏ß‡πâ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á disconnect
		end
	end
end

-- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
function BoardController:ChooseDirection(direction)
	print("[DEBUG] ChooseDirection called: " .. direction)
	-- ‡∏ã‡πà‡∏≠‡∏ô UI ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
	if PathSelectionContainer then
		print("[DEBUG] Hiding PathSelectionContainer after choice")
		PathSelectionContainer.Visible = false
	end

	-- ‡πÄ‡∏õ‡∏¥‡∏î Controls ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡∏°‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á
	-- Server ‡∏à‡∏∞‡∏™‡πà‡∏á path ‡πÉ‡∏´‡∏°‡πà‡∏°‡∏≤ ‡πÅ‡∏•‡∏∞ Client ‡∏à‡∏∞ Disable Controls ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏ô‡∏Å‡πâ‡∏≤‡∏ß‡∏ï‡πà‡∏≠‡πÑ‡∏õ
	if self.controlsDisabled then
		self:EnableControls()
	end

	-- ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏õ‡∏¢‡∏±‡∏á Server
	print("[DEBUG] Sending ChoosePath event to server: " .. direction)
	self.remotes.choosePath:FireServer(direction)
end

--==============================================================================
-- Utility Functions (‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ï‡πà‡∏≤‡∏á‡πÜ)
--==============================================================================

-- ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏≠‡∏á)
function BoardController:DisableControls()
	if self.controlsDisabled then print("[DEBUG] Controls already disabled.") return end
	print("üîí [DEBUG] Disabling Controls")
	Controls:Disable()
	self.controlsDisabled = true
end

-- ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
function BoardController:EnableControls()
	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ Coroutine ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏á Local Player ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà
	if self.activeMovementCoroutines[player.UserId] then
		print("‚ùï [DEBUG] Cannot enable controls yet, movement coroutine active for local player.")
		return
	end
	if not self.controlsDisabled then print("[DEBUG] Controls already enabled.") return end
	print("üîì [DEBUG] Enabling Controls")
	Controls:Enable()
	self.controlsDisabled = false
end

-- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á Vector3 ‡∏Ç‡∏≠‡∏á‡∏ä‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å Tile ID
function BoardController:GetTilePosition(tileId)
	print(string.format("[DEBUG] GetTilePosition called for Tile ID: %s (Type: %s)", tostring(tileId), type(tileId)))
	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Cache ‡∏Å‡πà‡∏≠‡∏ô
	if self.tilePositions[tileId] then
		print(string.format("[DEBUG] Found Tile %s position in cache: %s", tostring(tileId), tostring(self.tilePositions[tileId])))
		return self.tilePositions[tileId]
	end

	-- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô Workspace
	local tilesFolder = Workspace:FindFirstChild("BoardTiles")
	if not tilesFolder then warn("[DEBUG] BoardTiles folder not found!") return nil end
	print("[DEBUG] Found BoardTiles folder.")

	-- ‡∏•‡∏≠‡∏á‡∏´‡∏≤ Part ‡∏î‡πâ‡∏ß‡∏¢‡∏ä‡∏∑‡πà‡∏≠ "Tile<ID>" ‡∏´‡∏£‡∏∑‡∏≠ "<ID>"
	local tileName1 = "Tile" .. tostring(tileId)
	local tileName2 = tostring(tileId)
	print(string.format("[DEBUG] Trying to find Part named '%s' or '%s'", tileName1, tileName2))
	local tilePart = tilesFolder:FindFirstChild(tileName1) or tilesFolder:FindFirstChild(tileName2)

	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏à‡∏≠ Part ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô BasePart ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if not tilePart or not tilePart:IsA("BasePart") then
		warn(string.format("[DEBUG] Could not find valid BasePart named '%s' or '%s'.", tileName1, tileName2))
		return nil
	end

	-- ‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏ô Cache ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤
	print(string.format("[DEBUG] Found Tile Part: %s. Position: %s", tilePart.Name, tostring(tilePart.Position)))
	self.tilePositions[tileId] = tilePart.Position
	return tilePart.Position
end

--==============================================================================
-- Visual Effects (‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡∏µ‡∏¢‡∏á)
--==============================================================================

-- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡∏Å‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏ä‡πà‡∏≠‡∏á
function BoardController:ShowTileEffect(playerId, tileId, tileType)
	print(string.format("[DEBUG] ShowTileEffect called for Player %d, Tile %s, Type %s", playerId, tostring(tileId), tileType))
	-- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡πâ‡∏≠‡∏á‡∏ñ‡∏¥‡πà‡∏ô
	if playerId ~= player.UserId then return end

	local tilePosition = self:GetTilePosition(tileId)
	if not tilePosition then warn("[DEBUG] ShowTileEffect: Could not get position for Tile " .. tostring(tileId)) return end

	-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ä‡πà‡∏≠‡∏á
	local color = Color3.fromRGB(200, 200, 200) -- ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤ (Default)
	if tileType == "shop" then color = Color3.fromRGB(255, 215, 0) -- ‡∏™‡∏µ‡∏ó‡∏≠‡∏á
	elseif tileType == "battle" then color = Color3.fromRGB(255, 0, 0) -- ‡∏™‡∏µ‡πÅ‡∏î‡∏á
	elseif tileType == "item" then color = Color3.fromRGB(0, 255, 0) -- ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
	elseif tileType == "money" then color = Color3.fromRGB(255, 255, 0) -- ‡∏™‡∏µ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á
	elseif tileType == "casino" then color = Color3.fromRGB(255, 0, 255) -- ‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á‡πÅ‡∏î‡∏á
	elseif tileType == "bank" then color = Color3.fromRGB(0, 0, 255) -- ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô
	elseif tileType == "castle" then color = Color3.fromRGB(128, 0, 128) -- ‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á
	end

	self:CreateParticleEffect(tilePosition, color, tileType:upper()) -- ‡∏™‡∏£‡πâ‡∏≤‡∏á Particle
	self:PlayTileSound(tileType) -- ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Particle Effect ‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
function BoardController:CreateParticleEffect(position, color, effectType)
	print("[DEBUG] Creating Particle Effect: " .. effectType)
	local effectPart = Instance.new("Part")
	effectPart.Anchored = true
	effectPart.CanCollide = false
	effectPart.Transparency = 0.5
	effectPart.Size = Vector3.new(2, 2, 2)
	effectPart.Position = position + Vector3.new(0, 3, 0) -- ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
	effectPart.Color = color
	effectPart.Material = Enum.Material.Neon
	effectPart.Shape = Enum.PartType.Ball
	effectPart.Parent = Workspace.CurrentCamera -- ‡πÉ‡∏™‡πà‡πÉ‡∏ô Camera ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏•‡∏≠‡∏î

	-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Animation ‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏∏‡∏ô, ‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÉ‡∏™, ‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á
	local tweenInfo = TweenInfo.new(EFFECT_DURATION, Enum.EasingStyle.Linear)
	local goal = {
		Orientation = effectPart.Orientation + Vector3.new(0, 360, 0),
		Transparency = 1,
		Size = Vector3.new(0.1, 0.1, 0.1)
	}
	local tween = TweenService:Create(effectPart, tweenInfo, goal)
	tween:Play()

	-- ‡∏•‡∏ö Part ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å Animation ‡∏à‡∏ö
	tween.Completed:Connect(function()
		effectPart:Destroy()
	end)
end

-- ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏ä‡πà‡∏≠‡∏á
function BoardController:PlayTileSound(tileType)
	print("[DEBUG] Playing Tile Sound for type: " .. tileType)
	local soundId = nil
	-- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Sound ID ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó (‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô ID ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
	if tileType == "shop" then soundId = "rbxassetid://89427667950628" -- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
	elseif tileType == "battle" then soundId = "rbxassetid://89427667950628" -- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏î‡∏≤‡∏ö
	elseif tileType == "item" then soundId = "rbxassetid://89427667950628" -- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡∏≠‡∏á
	elseif tileType == "money" then soundId = "rbxassetid://89427667950628" -- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
		-- ... ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏∑‡πà‡∏ô‡πÜ ...
	else soundId = "rbxassetid://4067980844" -- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πâ‡∏≤‡∏ß‡πÄ‡∏ó‡πâ‡∏≤‡πÄ‡∏ö‡∏≤‡πÜ (Default)
	end

	if soundId then
		local sound = Instance.new("Sound")
		sound.SoundId = soundId
		sound.Volume = SOUND_VOLUME
		-- ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏™‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Head ‡∏´‡∏£‡∏∑‡∏≠ RootPart)
		local soundParent = player.Character and (player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart"))
		if soundParent then
			sound.Parent = soundParent
			sound:Play()
			-- ‡πÉ‡∏ä‡πâ Debris Service ‡∏•‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏à‡∏ö + buffer ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
			Debris:AddItem(sound, sound.TimeLength + 0.5)
		else
			warn("[DEBUG] Cannot find Head or HumanoidRootPart to play tile sound.")
		end
	else
		print("[DEBUG] No sound ID defined for tile type: " .. tileType)
	end
end

--==============================================================================
-- Initialization Call (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Controller)
--==============================================================================
local boardControllerInstance = BoardController.new()
return boardControllerInstance -- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ Instance ‡∏Ç‡∏≠‡∏á Controller
