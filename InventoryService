-- InventoryService.server.lua
-- Server-side inventory management service
-- Location: ServerScriptService/Services/InventoryService.server.lua
-- Version: 1.0.0

-- Services
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- Debug mode for detailed logging
local DEBUG_MODE = false

-- Helper function for logging
local function debugLog(message)
	if DEBUG_MODE then
		print("[InventoryService] " .. message)
	end
end

-- Load dependencies
local Modules = ServerStorage:WaitForChild("Modules")
local InventorySystem = require(Modules:WaitForChild("InventorySystem"))

-- Try to load ItemData module
local ItemData = nil
local success, result = pcall(function()
	return require(ReplicatedStorage:FindFirstChild("SharedModules"):WaitForChild("ItemData"))
end)

if success then
	ItemData = result
	debugLog("Successfully loaded ItemData module")
else
	warn("[InventoryService] Failed to load ItemData module: " .. tostring(result))
	-- Create a simple ItemData fallback
	ItemData = {
		ITEM_TYPES = {
			GENERAL = 1,
			EQUIPMENT = 2,
			SKILL = 3,
			SPECIAL = 4
		},
		EQUIPMENT_SLOTS = {
			WEAPON = 1,
			HELMET = 2,
			ARMOR = 3,
			GLOVES = 4,
			BOOTS = 5,
			ACCESSORY = 6
		},
		Items = {},
		Equipment = {},
		GetItemById = function(itemId)
			return ItemData.Items[itemId] or ItemData.Equipment[itemId]
		end
	}
end

-- Initialize remote events
local function initializeRemotes()
	debugLog("Initializing remote events...")

	local remotes = ReplicatedStorage:WaitForChild("Remotes")

	-- Create InventoryRemotes folder if needed
	local inventoryRemotes = remotes:FindFirstChild("InventoryRemotes")
	if not inventoryRemotes then
		inventoryRemotes = Instance.new("Folder")
		inventoryRemotes.Name = "InventoryRemotes"
		inventoryRemotes.Parent = remotes
	end

	-- Define remotes we need
	local remoteEvents = {
		"UpdateInventory",
		"AddItem",
		"RemoveItem",
		"UseItem",
		"EquipItem",
		"UnequipItem",
		"SortInventory",
		"InspectItem",
		"EquipmentSlotClicked",
		"EquipmentChanged",
		"DiceBonus"
	}

	-- Create required RemoteEvents
	for _, eventName in ipairs(remoteEvents) do
		if not inventoryRemotes:FindFirstChild(eventName) then
			local event = Instance.new("RemoteEvent")
			event.Name = eventName
			event.Parent = inventoryRemotes
			debugLog("Created RemoteEvent: " .. eventName)
		end
	end

	return inventoryRemotes
end

-- Player inventory cache
local playerInventories = {}

-- Track dice bonus uses
local playerDiceBonusUses = {}

-- Get GameManager reference
local function getGameManager()
	local startTime = tick()
	local attempts = 0
	local maxAttempts = 20

	while not _G.GameManager and attempts < maxAttempts do
		wait(0.5)
		attempts = attempts + 1
		debugLog("Waiting for GameManager... Attempt " .. attempts)
	end

	if not _G.GameManager then
		warn("[InventoryService] Failed to get GameManager after " .. maxAttempts .. " attempts.")
	else
		debugLog("GameManager found successfully.")
	end

	return _G.GameManager
end

-- Main service
local InventoryService = {}

-- Initialize player inventory
function InventoryService.InitializePlayer(player)
	if playerInventories[player.UserId] then
		return playerInventories[player.UserId]
	end

	local inventory = InventorySystem.new()

	-- Give starting items to the player
	InventoryService.GiveStartingItems(player, inventory)

	-- Cache the inventory
	playerInventories[player.UserId] = inventory

	-- Send initial inventory data to client
	InventoryService.SendInventoryToClient(player)

	return inventory
end

-- Give starting items based on player class
function InventoryService.GiveStartingItems(player, inventory)
	-- Get player data
	local gameManager = getGameManager()
	local playerData = gameManager and gameManager.playerManager and gameManager.playerManager:GetPlayerData(player)
	local playerClass = playerData and playerData.class or "Unknown"

	debugLog("Giving starting items to " .. player.Name .. " (Class: " .. playerClass .. ")")

	-- Base items that everyone gets
	if ItemData.Items.health_potion_small then
		inventory:AddItem(ItemData.Items.health_potion_small, 3)
		debugLog("Added 3x Small Health Potions")
	end

	if ItemData.Items.mana_potion_small then
		inventory:AddItem(ItemData.Items.mana_potion_small, 3)
		debugLog("Added 3x Small Mana Potions")
	end

	-- Class-specific starter equipment
	if playerClass == "Warrior" then
		if ItemData.Equipment.bronze_sword then
			inventory:AddItem(ItemData.Equipment.bronze_sword)
			debugLog("Added Bronze Sword for Warrior")
		end
	elseif playerClass == "Mage" then
		if ItemData.Equipment.apprentice_staff then
			inventory:AddItem(ItemData.Equipment.apprentice_staff)
			debugLog("Added Apprentice Staff for Mage")
		end
	elseif playerClass == "Thief" then
		if ItemData.Equipment.bronze_dagger then
			inventory:AddItem(ItemData.Equipment.bronze_dagger)
			debugLog("Added Bronze Dagger for Thief")
		end
	end

	-- Everyone gets basic armor
	if ItemData.Equipment.leather_armor then
		inventory:AddItem(ItemData.Equipment.leather_armor)
		debugLog("Added Leather Armor")
	end

	-- Add dice bonus items for testing
	if ItemData.Items.dice_bonus_1 then
		inventory:AddItem(ItemData.Items.dice_bonus_1, 2)
		debugLog("Added 2x Lucky Dice +1")
	end

	return true
end

-- Get player inventory
function InventoryService.GetPlayerInventory(player)
	if not playerInventories[player.UserId] then
		return InventoryService.InitializePlayer(player)
	end

	return playerInventories[player.UserId]
end

-- Send inventory data to client
function InventoryService.SendInventoryToClient(player)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false
	end

	-- Filter necessary data for client
	local clientData = {
		items = inventory:GetAllItems(),
		equippedItems = inventory:GetEquippedItems(),
		maxSize = inventory.maxSize
	}

	-- Send data via Remote
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local inventoryRemotes = remotes:WaitForChild("InventoryRemotes")
	local updateEvent = inventoryRemotes:WaitForChild("UpdateInventory")
	updateEvent:FireClient(player, clientData)

	return true
end

-- Add item to player inventory
function InventoryService.AddItemToPlayer(player, itemId, quantity)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false, "Failed to get player inventory"
	end

	-- Find item data
	local itemData = ItemData.GetItemById(itemId)
	if not itemData then
		return false, "Item not found"
	end

	-- Add item to inventory
	local success, message = inventory:AddItem(itemData, quantity)

	-- Send updated inventory to client
	if success then
		InventoryService.SendInventoryToClient(player)
		debugLog("Added item " .. itemId .. " x" .. tostring(quantity) .. " to player " .. player.Name)
	end

	return success, message
end

-- Remove item from player inventory
function InventoryService.RemoveItemFromPlayer(player, inventoryId, quantity)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false, "Failed to get player inventory"
	end

	-- Find item to log info
	local item = inventory:FindItemByInventoryId(inventoryId)
	local itemName = item and item.name or "Unknown Item"

	-- Remove item from inventory
	local success, message = inventory:RemoveItem(inventoryId, quantity)

	-- Send updated inventory to client
	if success then
		InventoryService.SendInventoryToClient(player)
		debugLog("Removed item " .. itemName .. " from player " .. player.Name)
	end

	return success, message
end

-- Update player stats based on equipment
function InventoryService.UpdatePlayerStats(player, equipmentStats)
	local gameManager = getGameManager()
	if not gameManager or not gameManager.playerManager then
		return false, "Player manager not available"
	end

	local playerData = gameManager.playerManager:GetPlayerData(player)
	if not playerData or not playerData.stats then
		return false, "Player data not found"
	end

	-- Store base stats if not already present
	local baseStats = playerData.baseStats
	if not baseStats then
		debugLog("Creating new baseStats from current stats for " .. player.Name)

		-- Create baseStats from current stats
		baseStats = {
			maxHp = playerData.stats.maxHp,
			hp = playerData.stats.hp,
			maxMp = playerData.stats.maxMp,
			mp = playerData.stats.mp,
			attack = playerData.stats.attack,
			defense = 0, -- Always 0 as per requirements
			magic = playerData.stats.magic,
			money = playerData.stats.money or 100
		}
		playerData.baseStats = baseStats
	end

	-- Log baseStats and equipmentStats for debugging
	debugLog("Base Stats for " .. player.Name .. ":")
	for stat, value in pairs(baseStats) do
		debugLog("  " .. stat .. " = " .. value)
	end

	debugLog("Equipment Stats for " .. player.Name .. ":")
	for stat, value in pairs(equipmentStats) do
		debugLog("  " .. stat .. " = " .. value)
	end

	-- Calculate total stats from base + equipment
	local newStats = {}
	for stat, baseValue in pairs(baseStats) do
		if equipmentStats[stat] then
			newStats[stat] = baseValue + equipmentStats[stat]
		else
			newStats[stat] = baseValue
		end
	end
	-- Allow defense to be modified by equipment

	-- Ensure HP/MP don't exceed maximums
	newStats.hp = math.min(playerData.stats.hp, newStats.maxHp)
	newStats.mp = math.min(playerData.stats.mp, newStats.maxMp)

	-- Apply the new stats
	for stat, value in pairs(newStats) do
		playerData.stats[stat] = value
	end

	-- Update stats on client
	gameManager.playerManager:UpdatePlayerStats(player, newStats)

	debugLog("Updated stats with equipment bonuses for " .. player.Name)
	return true
end

-- Equip item for player
function InventoryService.EquipItemForPlayer(player, inventoryId)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false, "Failed to get player inventory"
	end

	-- Find the item
	local item = inventory:FindItemByInventoryId(inventoryId)
	if not item then
		return false, "Item not found"
	end

	-- Check if item can be equipped
	if not item.equippable and item.type ~= InventorySystem.GetItemTypes().EQUIPMENT then
		return false, "Item cannot be equipped"
	end

	-- Check class restriction if applicable
	if item.classRestriction then
		local gameManager = getGameManager()
		local playerClass = nil

		if gameManager and gameManager.classSystem then
			playerClass = gameManager.classSystem:GetPlayerClass(player)
		end

		if not playerClass or playerClass ~= item.classRestriction then
			return false, "This item is restricted to " .. item.classRestriction .. " class"
		end
	end

	-- Equip the item
	local success, message = inventory:EquipItem(inventoryId)

	if success then
		-- Calculate new equipment stats
		local equipmentStats = inventory:CalculateEquipmentStats()

		-- Update player stats with equipment bonuses
		InventoryService.UpdatePlayerStats(player, equipmentStats)

		-- Send updated inventory to client
		InventoryService.SendInventoryToClient(player)

		-- Notify clients about equipment change
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local inventoryRemotes = remotes:WaitForChild("InventoryRemotes")
		local equipmentChangedEvent = inventoryRemotes:WaitForChild("EquipmentChanged")
		equipmentChangedEvent:FireClient(player, item.subType, item)

		debugLog(player.Name .. " equipped " .. item.name)
	end

	return success, message
end

-- Unequip item for player
function InventoryService.UnequipItemForPlayer(player, slotType)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false, "Failed to get player inventory"
	end

	-- Get the currently equipped item first
	local currentItem = inventory:GetEquippedItemInSlot(slotType)
	if not currentItem then
		return false, "No item equipped in this slot"
	end

	-- Unequip the item
	local success, message = inventory:UnequipItem(slotType)

	if success then
		-- Calculate new equipment stats
		local equipmentStats = inventory:CalculateEquipmentStats()

		-- Update player stats with equipment bonuses
		InventoryService.UpdatePlayerStats(player, equipmentStats)

		-- Send updated inventory to client
		InventoryService.SendInventoryToClient(player)

		-- Notify clients about equipment change
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local inventoryRemotes = remotes:WaitForChild("InventoryRemotes")
		local equipmentChangedEvent = inventoryRemotes:WaitForChild("EquipmentChanged")
		equipmentChangedEvent:FireClient(player, slotType, nil)

		debugLog(player.Name .. " unequipped " .. currentItem.name)
	end

	return success, message
end

-- Handle using items
function InventoryService.UseItemForPlayer(player, inventoryId)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false, "Failed to get player inventory"
	end

	-- Find the item
	local item = inventory:FindItemByInventoryId(inventoryId)
	if not item then
		return false, "Item not found"
	end

	local itemName = item.name or "Unknown Item"
	local itemId = item.id

	-- Check if item can be used
	if not item.usable then
		return false, "Item cannot be used"
	end

	-- Check if it's a dice bonus item
	local isDiceBonus = item.stats and item.stats.diceBonus and item.stats.diceBonus > 0

	if isDiceBonus then
		-- Check if it's the player's turn
		local gameManager = getGameManager()
		local turnSystem = gameManager and gameManager.turnSystem

		if not turnSystem then
			return false, "Turn system not available"
		end

		if turnSystem:GetCurrentPlayerTurn() ~= player.UserId then
			return false, "You can only use this item during your turn"
		end

		-- Check if player already used a dice bonus item this turn
		if playerDiceBonusUses[player.UserId] then
			return false, "You already used a dice bonus item this turn"
		end
	end

	-- Define use function
	local useFunction

	-- Check if there's a custom use handler in ItemData
	if ItemData.UseHandlers and ItemData.UseHandlers[item.id] then
		useFunction = function(itemData)
			return ItemData.UseHandlers[item.id](player, itemData)
		end
	else
		-- Default use function
		useFunction = function(itemData)
			-- Check item type
			if itemData.type == InventorySystem.GetItemTypes().GENERAL then
				-- If it's a general item like a potion
				if itemData.stats then
					local gameManager = getGameManager()
					if gameManager and gameManager.playerManager then
						local playerData = gameManager.playerManager:GetPlayerData(player)
						if playerData and playerData.stats then
							local changed = false

							-- Apply stat changes
							for statName, statValue in pairs(itemData.stats) do
								if statName == "diceBonus" then
									-- Handle dice bonus
									if gameManager.diceBonusService then
										gameManager.diceBonusService.SetPlayerDiceBonus(player, statValue)
									end

									-- Record that we used a dice bonus item this turn
									playerDiceBonusUses[player.UserId] = {
										itemId = itemId,
										bonusAmount = statValue,
										timestamp = os.time()
									}

									debugLog(player.Name .. " used dice bonus +" .. statValue)
									changed = true
								elseif playerData.stats[statName] ~= nil then
									-- Apply stat change (e.g., healing)
									if statName == "hp" then
										local newHP = math.min(playerData.stats.hp + statValue, playerData.stats.maxHp)
										gameManager.playerManager:UpdatePlayerHP(player, newHP)
									elseif statName == "mp" then
										local newMP = math.min(playerData.stats.mp + statValue, playerData.stats.maxMp)
										gameManager.playerManager:UpdatePlayerMP(player, newMP)
									else
										playerData.stats[statName] = playerData.stats[statName] + statValue
									end
									changed = true
								end
							end

							-- Update stats if changed
							if changed and not isDiceBonus then
								gameManager.playerManager:SyncPlayerStats(player)
							end
						end
					end
				end
			elseif itemData.type == InventorySystem.GetItemTypes().SKILL then
				-- Handle skill books
				local skillId = itemData.skillId
				if skillId and gameManager and gameManager.skillSystem then
					local success = gameManager.skillSystem:LearnSkill(player, skillId)
					if success then
						return true, "Learned new skill: " .. (itemData.skillName or "Unknown Skill")
					else
						return false, "Could not learn this skill"
					end
				end
			end

			return true, "Used " .. itemData.name
		end
	end

	-- Assign the use function to the item
	item.useFunction = useFunction

	-- Use the item
	local success, message = inventory:UseItem(inventoryId)

	-- Update client inventory
	if success then
		InventoryService.SendInventoryToClient(player)
		debugLog(player.Name .. " used " .. itemName)
	end

	return success, message
end

-- Reset dice bonus use when turn changes
function InventoryService.ResetDiceBonusUse(player)
	if not player then return false end

	local playerId = typeof(player) == "number" and player or player.UserId

	if playerDiceBonusUses[playerId] then
		playerDiceBonusUses[playerId] = nil
		debugLog("Reset dice bonus use for player: " .. playerId)
		return true
	end

	return false
end

-- Handle equipment slot click
function InventoryService.HandleEquipmentSlotClick(player, slotType)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then
		return false, "Failed to get player inventory"
	end

	-- Check if there's an item in this slot
	if inventory:HasEquippedItemInSlot(slotType) then
		-- If there is, unequip it
		return InventoryService.UnequipItemForPlayer(player, slotType)
	else
		-- If slot is empty, do nothing or show inventory with items that can go in this slot
		local remotes = ReplicatedStorage:WaitForChild("Remotes")
		local inventoryRemotes = remotes:WaitForChild("InventoryRemotes")
		local equipmentSlotClickedEvent = inventoryRemotes:WaitForChild("EquipmentSlotClicked")
		equipmentSlotClickedEvent:FireClient(player, slotType)

		return true, "Opening equipment selection for slot " .. slotType
	end
end

-- Set up remote events
local function setupRemoteEvents()
	debugLog("Setting up remote events...")

	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local inventoryRemotes = initializeRemotes()

	-- Add Item
	local addItemEvent = inventoryRemotes:WaitForChild("AddItem")
	addItemEvent.OnServerEvent:Connect(function(player, itemId, quantity)
		InventoryService.AddItemToPlayer(player, itemId, quantity)
	end)

	-- Remove Item
	local removeItemEvent = inventoryRemotes:WaitForChild("RemoveItem")
	removeItemEvent.OnServerEvent:Connect(function(player, inventoryId, quantity)
		InventoryService.RemoveItemFromPlayer(player, inventoryId, quantity)
	end)

	-- Equip Item
	local equipItemEvent = inventoryRemotes:WaitForChild("EquipItem")
	equipItemEvent.OnServerEvent:Connect(function(player, inventoryId)
		InventoryService.EquipItemForPlayer(player, inventoryId)
	end)

	-- Unequip Item
	local unequipItemEvent = inventoryRemotes:WaitForChild("UnequipItem")
	unequipItemEvent.OnServerEvent:Connect(function(player, slotType)
		InventoryService.UnequipItemForPlayer(player, slotType)
	end)

	-- Use Item
	local useItemEvent = inventoryRemotes:WaitForChild("UseItem")
	useItemEvent.OnServerEvent:Connect(function(player, inventoryId)
		InventoryService.UseItemForPlayer(player, inventoryId)
	end)

	-- Equipment Slot Clicked
	local slotClickEvent = inventoryRemotes:WaitForChild("EquipmentSlotClicked")
	slotClickEvent.OnServerEvent:Connect(function(player, slotType)
		InventoryService.HandleEquipmentSlotClick(player, slotType)
	end)

	-- Inspect Item
	local inspectItemEvent = inventoryRemotes:WaitForChild("InspectItem")
	inspectItemEvent.OnServerEvent:Connect(function(player, inventoryId)
		local inventory = InventoryService.GetPlayerInventory(player)
		if not inventory then return end

		local item = inventory:FindItemByInventoryId(inventoryId)
		if item then
			inspectItemEvent:FireClient(player, item)
		end
	end)

	debugLog("Remote events set up successfully")
end

-- Set up player events
local function setupPlayerEvents()
	debugLog("Setting up player events...")

	-- Player joining
	Players.PlayerAdded:Connect(function(player)
		-- Initialize inventory when player joins
		InventoryService.InitializePlayer(player)
	end)

	-- Player leaving
	Players.PlayerRemoving:Connect(function(player)
		-- Clear from cache
		playerInventories[player.UserId] = nil

		-- Reset dice bonus use data
		if playerDiceBonusUses[player.UserId] then
			playerDiceBonusUses[player.UserId] = nil
		end
	end)

	-- Initialize for existing players
	for _, player in pairs(Players:GetPlayers()) do
		task.spawn(function()
			InventoryService.InitializePlayer(player)
		end)
	end

	-- Connect to turn system
	local remotes = ReplicatedStorage:WaitForChild("Remotes")
	local gameRemotes = remotes:WaitForChild("GameRemotes", 10)

	if gameRemotes then
		local updateTurnEvent = gameRemotes:WaitForChild("UpdateTurn", 10)
		if updateTurnEvent then
			updateTurnEvent.OnServerEvent:Connect(function(_, playerId)
				-- Reset dice bonus uses for new turn
				for pid, _ in pairs(playerDiceBonusUses) do
					if pid ~= playerId then
						playerDiceBonusUses[pid] = nil
						debugLog("Reset dice bonus use for player " .. pid .. " on turn change")
					end
				end
			end)
		end
	end

	debugLog("Player events set up successfully")
end

-- Initialize the service
local function init()
	debugLog("Initializing InventoryService...")

	-- Register with GameManager if available
	local gameManager = getGameManager()
	if gameManager then
		gameManager.inventoryService = InventoryService
		debugLog("InventoryService registered with GameManager")
	end

	-- Set up remote events
	setupRemoteEvents()

	-- Set up player events
	setupPlayerEvents()

	-- Add testing function
	_G.TestDiceBonus = function(player, bonusAmount)
		-- If no player specified, use first player in server
		if not player then
			local players = Players:GetPlayers()
			if #players == 0 then 
				warn("[InventoryService] No players in game")
				return false 
			end
			player = players[1]
		end

		bonusAmount = bonusAmount or 1

		-- Check if it's the player's turn
		local gameManager = getGameManager()
		local turnSystem = gameManager and gameManager.turnSystem
		if turnSystem and turnSystem:GetCurrentPlayerTurn() ~= player.UserId then
			warn("[InventoryService] Not " .. player.Name .. "'s turn")
			return false
		end

		-- Set dice bonus
		if gameManager and gameManager.diceBonusService then
			gameManager.diceBonusService.SetPlayerDiceBonus(player, bonusAmount)

			-- Record that we used a dice bonus
			playerDiceBonusUses[player.UserId] = {
				itemId = "test_dice_bonus",
				bonusAmount = bonusAmount,
				timestamp = os.time()
			}

			debugLog("Test dice bonus +" .. bonusAmount .. " set for " .. player.Name)
			return true
		else
			warn("[InventoryService] DiceBonusService not found")
			return false
		end
	end

	debugLog("InventoryService initialized successfully")
end

-- Enable/disable debug mode
function InventoryService.SetDebugMode(enabled)
	DEBUG_MODE = enabled
	debugLog("Debug mode " .. (enabled and "enabled" or "disabled"))
end

-- Initialize with debug mode off
InventoryService.SetDebugMode(false)

-- Start initialization
init()

return InventoryService
