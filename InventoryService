-- InventoryService.server.lua
-- Version: 4.1.3 (Formatted - No Debug, No Comments)

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Modules = ServerStorage:WaitForChild("Modules")
local InventorySystem = require(Modules:WaitForChild("InventorySystem"))
local ItemData

local success, result = pcall(function()
	return require(ReplicatedStorage:FindFirstChild("SharedModules"):WaitForChild("ItemData"))
end)

if success then
	ItemData = result
else
	ItemData = {
		Items = {
			test_item = { id = "test_item", name = "Test Item", description = "A test item", type = 1, rarity = 1, stackable = true, maxStack = 99, iconId = "", stats = { hp = 50 } },
			dice_bonus_1 = { id = "dice_bonus_1", name = "Lucky Dice +1", description = "Add +1 to your next dice roll", type = 1, rarity = 2, stackable = true, maxStack = 5, usable = true, consumable = true, stats = { diceRollBonus = 1 } },
			crystal_1 = { id = "crystal_1", name = "Crystal 1", description = "Move exactly 1 space automatically", type = 1, rarity = 1, stackable = true, maxStack = 5, usable = true, consumable = true, stats = { move = 1 } },
			crystal_2 = { id = "crystal_2", name = "Crystal 2", description = "Move exactly 2 spaces automatically", type = 1, rarity = 2, stackable = true, maxStack = 5, usable = true, consumable = true, stats = { move = 2 } },
			crystal_3 = { id = "crystal_3", name = "Crystal 3", description = "Move exactly 3 spaces automatically", type = 1, rarity = 3, stackable = true, maxStack = 5, usable = true, consumable = true, stats = { move = 3 } }
		},
		Equipment = {
			test_equipment = { id = "test_equipment", name = "Test Equipment", description = "A test equipment", type = 2, subType = 1, rarity = 2, stackable = false, iconId = "", stats = { attack = 10, defense = 5 } }
		},
		GetItemById = function(itemId)
			return ItemData.Items[itemId] or ItemData.Equipment[itemId]
		end
	}
end

local remotes = ReplicatedStorage:WaitForChild("Remotes")
local inventoryRemotes = remotes:FindFirstChild("InventoryRemotes")
if not inventoryRemotes then
	inventoryRemotes = Instance.new("Folder")
	inventoryRemotes.Name = "InventoryRemotes"
	inventoryRemotes.Parent = remotes
end

local remoteEvents = {
	"UpdateInventory", "AddItem", "RemoveItem", "UseItem", "EquipItem", "UnequipItem",
	"SortInventory", "DropItem", "TransferItem", "InspectItem", "EquipmentSlotClicked",
	"DiceBonus", "CrystalMove", "CrystalUIReset", "CrystalMoveComplete",
	"ItemPermissionUpdate", "ItemPermissionResponse"
}
for _, eventName in ipairs(remoteEvents) do
	if not inventoryRemotes:FindFirstChild(eventName) then
		local event = Instance.new("RemoteEvent")
		event.Name = eventName
		event.Parent = inventoryRemotes
	end
end

local playerInventories = {}
local playerHealedItems = {}
local playerDiceBonusUses = {}
local playerCrystalMovements = {}

local function getDiceBonusService()
	return _G.DiceBonusService or (_G.GameManager and _G.GameManager.diceBonusService)
end

local function getGameManager()
	if _G.GameManager then return _G.GameManager end
	local startTime = tick()
	while not _G.GameManager and tick() - startTime < 5 do
		task.wait(0.1)
	end
	return _G.GameManager
end

local function getBoardSystem()
	local gm = getGameManager()
	return _G.BoardSystem or (gm and gm.boardSystem)
end

local function getPlayerData(player)
	if not player then return nil end
	local gm = getGameManager()
	if not gm or not gm.playerManager then return nil end
	return gm.playerManager:GetPlayerData(player)
end

local InventoryService = {}

function InventoryService.InitializePlayer(player)
	if playerInventories[player.UserId] then
		return playerInventories[player.UserId]
	end
	local inventory = InventorySystem.new()
	InventoryService.GiveStartingItems(player, inventory)
	playerInventories[player.UserId] = inventory
	InventoryService.SendInventoryToClient(player)
	return inventory
end

function InventoryService.GiveStartingItems(player, inventory)
	local playerData = getPlayerData(player)
	local playerClass = playerData and playerData.class or "Unknown"
	inventory:AddItem(ItemData.Items.test_item, 3)
	if ItemData.Items.dice_bonus_1 then inventory:AddItem(ItemData.Items.dice_bonus_1, 2) end
	if ItemData.Items.dice_bonus_2 then inventory:AddItem(ItemData.Items.dice_bonus_2, 1) end
	if ItemData.Items.crystal_1 then inventory:AddItem(ItemData.Items.crystal_1, 2) end
	if ItemData.Items.crystal_2 then inventory:AddItem(ItemData.Items.crystal_2, 1) end
	if ItemData.Items.crystal_3 then inventory:AddItem(ItemData.Items.crystal_3, 1) end
	inventory:AddItem(ItemData.Equipment.test_equipment)
	return true
end

function InventoryService.GetPlayerInventory(player)
	return playerInventories[player.UserId] or InventoryService.InitializePlayer(player)
end

function InventoryService.SendInventoryToClient(player)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false end
	local clientData = {
		items = inventory:GetAllItems(),
		equippedItems = inventory:GetEquippedItems(),
		maxSize = inventory.maxSize
	}
	inventoryRemotes:WaitForChild("UpdateInventory"):FireClient(player, clientData)
	return true
end

function InventoryService.AddItemToPlayer(player, itemId, quantity)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false, "Failed to get player inventory" end
	local itemData = ItemData.GetItemById(itemId)
	if not itemData then return false, "Item not found" end
	local success, message = inventory:AddItem(itemData, quantity)
	if success then InventoryService.SendInventoryToClient(player) end
	return success, message
end

function InventoryService.RemoveItemFromPlayer(player, inventoryId, quantity)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false, "Failed to get player inventory" end
	local success, message = inventory:RemoveItem(inventoryId, quantity)
	if success then InventoryService.SendInventoryToClient(player) end
	return success, message
end

function InventoryService.HealToMax(player)
	if not player then return false end
	local playerData = getPlayerData(player)
	if not playerData or not playerData.stats then return false end
	local oldHp = playerData.stats.hp
	playerData.stats.hp = playerData.stats.maxHp
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		player.Character.Humanoid.Health = playerData.stats.maxHp
	end
	local gm = getGameManager()
	if gm and gm.playerManager then
		if gm.playerManager.UpdatePlayerHP then
			gm.playerManager:UpdatePlayerHP(player, playerData.stats.maxHp)
		elseif gm.playerManager.updatePlayerStatsEvent then
			gm.playerManager.updatePlayerStatsEvent:FireClient(player, player.UserId, { hp = playerData.stats.maxHp, maxHp = playerData.stats.maxHp })
		end
	end
	return true
end

function InventoryService.UpdatePlayerStats(player, equipmentStats)
	local gm = getGameManager()
	if not gm or not gm.playerManager then return false end
	local playerData = gm.playerManager:GetPlayerData(player)
	if not playerData or not playerData.stats then return false end

	if not playerData.baseStats or type(playerData.baseStats) ~= "table" then
		local className = playerData.class
		local freshStats = gm.playerManager.GetDefaultStatsForClass and gm.playerManager:GetDefaultStatsForClass(className)
		if freshStats then
			playerData.baseStats = table.clone(freshStats)
		else
			playerData.baseStats = {
				maxHp = playerData.stats.maxHp, hp = playerData.stats.hp, maxMp = playerData.stats.maxMp, mp = playerData.stats.mp,
				attack = playerData.stats.attack, defense = playerData.stats.defense, magic = playerData.stats.magic, money = playerData.stats.money or 100
			}
		end
	end

	local oldMaxHp = playerData.stats.maxHp
	local oldHp = playerData.stats.hp
	local hpRatio = oldMaxHp > 0 and (oldHp / oldMaxHp) or 1
	local newStats = {}
	for k, v in pairs(playerData.baseStats) do newStats[k] = v end
	for k, v in pairs(equipmentStats) do newStats[k] = (newStats[k] or 0) + v end
	if equipmentStats.defense then
		newStats.maxHp = playerData.baseStats.maxHp + (equipmentStats.defense * 5)
	end

	local newMaxHp = newStats.maxHp
	local maxHpDiff = newMaxHp - oldMaxHp
	local newHp = 0
	if maxHpDiff >= 0 then
		newHp = math.floor(newMaxHp * hpRatio)
		newHp = math.max(newHp, oldHp)
	else
		newHp = math.floor(newMaxHp * hpRatio)
	end
	newHp = math.max(1, math.min(newHp, newMaxHp))
	newStats.hp = newHp

	for k, v in pairs(newStats) do playerData.stats[k] = v end

	if gm.playerManager.UpdatePlayerStats then
		gm.playerManager:UpdatePlayerStats(player, playerData.stats)
	elseif gm.playerManager.SyncPlayerStats then
		gm.playerManager:SyncPlayerStats(player)
	elseif gm.playerManager.UpdatePlayerHP then
		gm.playerManager:UpdatePlayerHP(player, newHp)
	end
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		player.Character.Humanoid.Health = playerData.stats.hp
	end
	return true
end

function InventoryService.EquipItemForPlayer(player, inventoryId)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false, "Failed to get player inventory" end
	local playerData = getPlayerData(player)
	local oldMaxHp = 0
	if playerData and playerData.stats then oldMaxHp = playerData.stats.maxHp end
	local success, message = inventory:EquipItem(inventoryId)
	if success then
		local equipmentStats = inventory:CalculateEquipmentStats()
		InventoryService.UpdatePlayerStats(player, equipmentStats)
		if playerData and playerData.stats then
			local newMaxHp = playerData.stats.maxHp
			local hpIncrease = newMaxHp - oldMaxHp
			if hpIncrease >= (oldMaxHp * 0.25) then
				InventoryService.HealToMax(player)
			end
		end
		InventoryService.SendInventoryToClient(player)
	end
	return success, message
end

function InventoryService.UnequipItemForPlayer(player, slotType)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false, "Failed to get player inventory" end
	local success, message = inventory:UnequipItem(slotType)
	if success then
		local equipmentStats = inventory:CalculateEquipmentStats()
		InventoryService.UpdatePlayerStats(player, equipmentStats)
		InventoryService.SendInventoryToClient(player)
	end
	return success, message
end

function InventoryService.HandleEquipmentSlotClick(player, slotType)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false, "Failed to get player inventory" end
	local item = inventory:GetEquippedItemInSlot(slotType)
	if not item then return false, "No item in slot" end
	inventoryRemotes:WaitForChild("InspectItem"):FireClient(player, item)
	return true
end

function InventoryService.IsPlayerUsingCrystal(player)
	if not player then return false end
	local playerId = typeof(player) == "number" and player or player.UserId
	if playerCrystalMovements[playerId] then return true end
	local boardSystem = getBoardSystem()
	if not boardSystem then return false end
	if boardSystem.activeCrystalMovements and boardSystem.activeCrystalMovements[playerId] then return true end
	if boardSystem.lastMovementData and boardSystem.lastMovementData[playerId] and boardSystem.lastMovementData[playerId].isCrystalMove then return true end
	if boardSystem.playerMovementState and boardSystem.playerMovementState[playerId] and (boardSystem.playerMovementState[playerId] == "auto_complete" or boardSystem.playerMovementState[playerId] == "need_choice") then
		if boardSystem.playerRemainingSteps and boardSystem.playerRemainingSteps[playerId] and boardSystem.playerRemainingSteps[playerId] > 0 then return true end
	end
	return false
end

function InventoryService.UseItemForPlayer(player, inventoryId)
	local inventory = InventoryService.GetPlayerInventory(player)
	if not inventory then return false, "Failed to get player inventory" end
	local item = inventory:FindItemByInventoryId(inventoryId)
	if not item then return false, "Item not found" end
	if not item.usable then return false, "Item cannot be used" end
	if InventoryService.IsPlayerUsingCrystal(player) then return false, "You can't use items while crystal movement is active" end

	local isCrystal = item.stats and item.stats.move and item.stats.move > 0
	if isCrystal then
		local gm = getGameManager()
		local turnSystem = gm and gm.turnSystem
		if not turnSystem then return false, "Turn system not available" end
		if turnSystem:GetCurrentPlayerTurn() ~= player.UserId then return false, "You can only use crystals during your turn" end
		local boardSystem = getBoardSystem()
		if not boardSystem then return false, "Board system not available" end
		if boardSystem.playerMovementState and boardSystem.playerMovementState[player.UserId] and (boardSystem.playerMovementState[player.UserId] == "auto_complete" or boardSystem.playerMovementState[player.UserId] == "need_choice") then return false, "You cannot use crystals while moving" end
		if boardSystem.playerRemainingSteps and boardSystem.playerRemainingSteps[player.UserId] and boardSystem.playerRemainingSteps[player.UserId] > 0 then return false, "You cannot use crystals while moving" end

		local steps = item.stats.move
		playerCrystalMovements[player.UserId] = { steps = steps, timestamp = os.time(), itemId = item.id }
		if boardSystem.ProcessCrystalMove then
			local success = boardSystem:ProcessCrystalMove(player, steps)
			if not success then
				playerCrystalMovements[player.UserId] = nil
				return false, "Cannot use crystal at this time"
			end
			local crystalMoveEvent = inventoryRemotes:FindFirstChild("CrystalMove")
			if crystalMoveEvent then crystalMoveEvent:FireClient(player, steps) end
			task.delay(15, function()
				if playerCrystalMovements[player.UserId] then playerCrystalMovements[player.UserId] = nil end
			end)
			local success, message = inventory:RemoveItem(inventoryId, 1)
			if success then InventoryService.SendInventoryToClient(player) end
			return true, "Moving with crystal " .. steps .. " step(s)"
		else
			playerCrystalMovements[player.UserId] = nil
			return false, "Board system does not support crystal movement"
		end
	end

	local isDiceBonus = item.stats and item.stats.diceRollBonus and item.stats.diceRollBonus > 0
	if isDiceBonus then
		local gm = getGameManager()
		local turnSystem = gm and gm.turnSystem
		if not turnSystem then return false, "Turn system not available" end
		if turnSystem:GetCurrentPlayerTurn() ~= player.UserId then return false, "You can only use this item during your turn" end
		if playerDiceBonusUses[player.UserId] then return false, "You already used a dice bonus item this turn" end
	end

	local useFunction
	if ItemData.UseHandlers and ItemData.UseHandlers[item.id] then
		useFunction = function(itemData) return ItemData.UseHandlers[item.id](player, itemData) end
	else
		useFunction = function(itemData)
			if itemData.type == InventorySystem.GetItemTypes().GENERAL then
				if itemData.stats then
					local playerData = getPlayerData(player)
					if playerData and playerData.stats then
						local changed = false
						for statName, statValue in pairs(itemData.stats) do
							if statName == "diceRollBonus" then
								local diceBonusService = getDiceBonusService()
								if diceBonusService then
									diceBonusService.SetPlayerDiceBonus(player, statValue)
									changed = true
									playerDiceBonusUses[player.UserId] = { itemId = item.id, bonusAmount = statValue, timestamp = os.time() }
								end
							elseif statName == "move" then
								return true, "Moving with crystal " .. statValue .. " step(s)"
							elseif playerData.stats[statName] ~= nil then
								playerData.stats[statName] = playerData.stats[statName] + statValue
								changed = true
							end
						end
						if itemData.stats.hp and playerHealedItems[player.UserId] then
							playerHealedItems[player.UserId] = {}
						end
						if changed and not isDiceBonus and not isCrystal then
							if itemData.stats.hp and itemData.stats.hp > 0 then
								task.delay(0.05, function() InventoryService.HealToMax(player) end)
							else
								local gm = getGameManager()
								if gm and gm.playerManager then gm.playerManager:UpdatePlayerStats(player) end
							end
						end
						return true, "Used " .. itemData.name
					end
				end
			elseif itemData.type == InventorySystem.GetItemTypes().SKILL then
				local skillId = itemData.skillId
				if skillId then
					local gm = getGameManager()
					if gm and gm.skillSystem then
						local success = gm.skillSystem:LearnSkill(player, skillId)
						if success then return true, "Learned new skill: " .. (itemData.skillName or "Unknown Skill")
						else return false, "Could not learn this skill" end
					end
				end
			elseif itemData.stats and itemData.stats.move and itemData.stats.move > 0 then
				return true, "Moving with crystal " .. itemData.stats.move .. " step(s)"
			end
			return true, "Used " .. itemData.name
		end
	end

	item.useFunction = useFunction
	local success, message = inventory:UseItem(inventoryId)
	if success then InventoryService.SendInventoryToClient(player) end
	return success, message
end

function InventoryService.ResetDiceBonusUse(player)
	if not player then return false end
	local playerId = typeof(player) == "number" and player or player.UserId
	if playerDiceBonusUses[playerId] then
		playerDiceBonusUses[playerId] = nil
		return true
	end
	return false
end

function InventoryService.ResetCrystalMovement(player)
	if not player then return false end
	local playerId = typeof(player) == "number" and player or player.UserId
	if playerCrystalMovements[playerId] then
		playerCrystalMovements[playerId] = nil
		local crystalUIResetEvent = inventoryRemotes:FindFirstChild("CrystalUIReset")
		if crystalUIResetEvent then
			local playerObj = typeof(player) == "Instance" and player or Players:GetPlayerByUserId(playerId)
			if playerObj then crystalUIResetEvent:FireClient(playerObj) end
		end
		return true
	end
	return false
end

local function setupRemoteEvents()
	inventoryRemotes:WaitForChild("AddItem").OnServerEvent:Connect(InventoryService.AddItemToPlayer)
	inventoryRemotes:WaitForChild("RemoveItem").OnServerEvent:Connect(InventoryService.RemoveItemFromPlayer)
	inventoryRemotes:WaitForChild("EquipItem").OnServerEvent:Connect(InventoryService.EquipItemForPlayer)
	inventoryRemotes:WaitForChild("UnequipItem").OnServerEvent:Connect(InventoryService.UnequipItemForPlayer)
	inventoryRemotes:WaitForChild("UseItem").OnServerEvent:Connect(InventoryService.UseItemForPlayer)
	inventoryRemotes:WaitForChild("EquipmentSlotClicked").OnServerEvent:Connect(InventoryService.HandleEquipmentSlotClick)
	inventoryRemotes:WaitForChild("DropItem").OnServerEvent:Connect(function(player, inventoryId, quantity) end)
	inventoryRemotes:WaitForChild("InspectItem").OnServerEvent:Connect(function(player, inventoryId)
		local inventory = InventoryService.GetPlayerInventory(player)
		if not inventory then return end
		local item = inventory:FindItemByInventoryId(inventoryId)
		if item then inventoryRemotes:WaitForChild("InspectItem"):FireClient(player, item) end
	end)

	local crystalMoveCompleteEvent = inventoryRemotes:FindFirstChild("CrystalMoveComplete")
	if crystalMoveCompleteEvent then
		crystalMoveCompleteEvent.OnServerEvent:Connect(function(player)
			local playerId = player.UserId
			if playerCrystalMovements[playerId] then
				playerCrystalMovements[playerId] = nil
				local serverCrystalCompleteEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BoardRemotes"):FindFirstChild("CrystalMoveComplete")
				if serverCrystalCompleteEvent then serverCrystalCompleteEvent:FireServer() end
			end
		end)
	end

	local crystalMoveEvent = inventoryRemotes:FindFirstChild("CrystalMove")
	if crystalMoveEvent then
		crystalMoveEvent.OnServerEvent:Connect(function(player, steps)
			local boardSystem = getBoardSystem()
			if boardSystem and boardSystem.ProcessCrystalMove then boardSystem:ProcessCrystalMove(player, steps) end
		end)
	end

	local ItemPermissionUpdateEvent = inventoryRemotes:FindFirstChild("ItemPermissionUpdate")
	local ItemPermissionResponseEvent = inventoryRemotes:FindFirstChild("ItemPermissionResponse")
	if ItemPermissionUpdateEvent and ItemPermissionResponseEvent then
		ItemPermissionUpdateEvent.OnServerEvent:Connect(function(player)
			local gm = getGameManager()
			local turnSystem = gm and gm.turnSystem
			if turnSystem then
				local isPlayerTurn = turnSystem:GetCurrentPlayerTurn() == player.UserId
				ItemPermissionResponseEvent:FireClient(player, isPlayerTurn)
			end
		end)
	end
end

local function setupPlayerEvents()
	Players.PlayerAdded:Connect(function(player)
		InventoryService.InitializePlayer(player)
		task.delay(3, function()
			local playerData = getPlayerData(player)
			if not playerData or not playerData.stats then return end
			local maxHp = playerData.stats.maxHp
			local currentHp = playerData.stats.hp
			if currentHp < maxHp and currentHp >= (maxHp * 0.8) then
				InventoryService.HealToMax(player)
			end
		end)
	end)
	Players.PlayerRemoving:Connect(function(player)
		local userId = player.UserId
		playerInventories[userId] = nil
		playerHealedItems[userId] = nil
		playerDiceBonusUses[userId] = nil
		playerCrystalMovements[userId] = nil
	end)
	for _, player in pairs(Players:GetPlayers()) do
		task.spawn(InventoryService.InitializePlayer, player)
	end
end

local function init()
	local gm = getGameManager()
	if gm then gm.inventoryService = InventoryService end
	setupRemoteEvents()
	setupPlayerEvents()
end

init()
return InventoryService
